{
  "registrations": {
    "bevy_core_pipeline::tonemapping::Tonemapping": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": " Bypass tonemapping."
          },
          {
            "kind": "unit",
            "name": "Reinhard",
            "docs": " Suffers from lots hue shifting, brights don't desaturate naturally.\n Bright primaries and secondaries don't desaturate at all."
          },
          {
            "kind": "unit",
            "name": "ReinhardLuminance",
            "docs": " Suffers from hue shifting. Brights don't desaturate much at all across the spectrum."
          },
          {
            "kind": "unit",
            "name": "AcesFitted",
            "docs": " Same base implementation that Godot 4.0 uses for Tonemap ACES.\n <https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl>\n Not neutral, has a very specific aesthetic, intentional and dramatic hue shifting.\n Bright greens and reds turn orange. Bright blues turn magenta.\n Significantly increased contrast. Brights desaturate across the spectrum."
          },
          {
            "kind": "unit",
            "name": "AgX",
            "docs": " By Troy Sobotka\n <https://github.com/sobotka/AgX>\n Very neutral. Image is somewhat desaturated when compared to other tonemappers.\n Little to no hue shifting. Subtle [Abney shifting](https://en.wikipedia.org/wiki/Abney_effect).\n NOTE: Requires the `tonemapping_luts` cargo feature."
          },
          {
            "kind": "unit",
            "name": "SomewhatBoringDisplayTransform",
            "docs": " By Tomasz Stachowiak\n Has little hue shifting in the darks and mids, but lots in the brights. Brights desaturate across the spectrum.\n Is sort of between Reinhard and `ReinhardLuminance`. Conceptually similar to reinhard-jodie.\n Designed as a compromise if you want e.g. decent skin tones in low light, but can't afford to re-do your\n VFX to look good without hue shifting."
          },
          {
            "kind": "unit",
            "name": "TonyMcMapface",
            "docs": " Current Bevy default.\n By Tomasz Stachowiak\n <https://github.com/h3r2tic/tony-mc-mapface>\n Very neutral. Subtle but intentional hue shifting. Brights desaturate across the spectrum.\n Comment from author:\n Tony is a display transform intended for real-time applications such as games.\n It is intentionally boring, does not increase contrast or saturation, and stays close to the\n input stimulus where compression isn't necessary.\n Brightness-equivalent luminance of the input stimulus is compressed. The non-linearity resembles Reinhard.\n Color hues are preserved during compression, except for a deliberate [Bezold–Brücke shift](https://en.wikipedia.org/wiki/Bezold%E2%80%93Br%C3%BCcke_shift).\n To avoid posterization, selective desaturation is employed, with care to avoid the [Abney effect](https://en.wikipedia.org/wiki/Abney_effect).\n NOTE: Requires the `tonemapping_luts` cargo feature."
          },
          {
            "kind": "unit",
            "name": "BlenderFilmic",
            "docs": " Default Filmic Display Transform from blender.\n Somewhat neutral. Suffers from hue shifting. Brights desaturate across the spectrum.\n NOTE: Requires the `tonemapping_luts` cargo feature."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::tonemapping::Tonemapping",
        "short_type_path": "Tonemapping",
        "ident": "Tonemapping",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::tonemapping"
      },
      "default": "{\"bevy_core_pipeline::tonemapping::Tonemapping\":\"TonyMcMapface\"}",
      "docs": " Optionally enables a tonemapping shader that attempts to map linear input stimulus into a perceptually uniform image for a given [`Camera`] entity.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::UiBoxShadowSamples": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "u32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::UiBoxShadowSamples",
        "short_type_path": "UiBoxShadowSamples",
        "ident": "UiBoxShadowSamples",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": null,
      "docs": " Number of shadow samples.\n A larger value will result in higher quality shadows.\n Default is 4, values higher than ~10 offer diminishing returns.\n\n ```\n use bevy_core_pipeline::prelude::*;\n use bevy_ecs::prelude::*;\n use bevy_ui::prelude::*;\n\n fn spawn_camera(mut commands: Commands) {\n     commands.spawn((\n         Camera2d,\n         UiBoxShadowSamples(6),\n     ));\n }\n ```",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_gltf::GltfMesh>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_gltf::GltfMesh>",
        "short_type_path": "AssetId<GltfMesh>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<(bevy_ecs::entity::Entity, bevy_picking::backend::HitData)>": {
      "info": {
        "kind": "list",
        "item_type_path": "(bevy_ecs::entity::Entity, bevy_picking::backend::HitData)"
      },
      "path_table": {
        "path": "alloc::vec::Vec<(bevy_ecs::entity::Entity, bevy_picking::backend::HitData)>",
        "short_type_path": "Vec<(Entity, HitData)>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::IVec2": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "i32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "i32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::IVec2",
        "short_type_path": "IVec2",
        "ident": "IVec2",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::IVec2\":[0,0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::widget::text::TextNodeFlags": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "needs_measure_fn",
            "type_path": "bool",
            "docs": " If set then a new measure function for the text node will be created."
          },
          {
            "name": "needs_recompute",
            "type_path": "bool",
            "docs": " If set then the text will be recomputed."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::widget::text::TextNodeFlags",
        "short_type_path": "TextNodeFlags",
        "ident": "TextNodeFlags",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::widget::text"
      },
      "default": "{\"bevy_ui::widget::text::TextNodeFlags\":{\"needs_measure_fn\":true,\"needs_recompute\":true}}",
      "docs": " UI text system flags.\n\n Used internally by [`measure_text_system`] and [`text_system`] to schedule text for processing.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_core_pipeline::core_3d::camera_3d::ScreenSpaceTransmissionQuality": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Low",
            "docs": " Best performance at the cost of quality. Suitable for lower end GPUs. (e.g. Mobile)\n\n `num_taps` = 4"
          },
          {
            "kind": "unit",
            "name": "Medium",
            "docs": " A balanced option between quality and performance.\n\n `num_taps` = 8"
          },
          {
            "kind": "unit",
            "name": "High",
            "docs": " Better quality. Suitable for high end GPUs. (e.g. Desktop)\n\n `num_taps` = 16"
          },
          {
            "kind": "unit",
            "name": "Ultra",
            "docs": " The highest quality, suitable for non-realtime rendering. (e.g. Pre-rendered cinematics and photo mode)\n\n `num_taps` = 32"
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::core_3d::camera_3d::ScreenSpaceTransmissionQuality",
        "short_type_path": "ScreenSpaceTransmissionQuality",
        "ident": "ScreenSpaceTransmissionQuality",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::core_3d::camera_3d"
      },
      "default": "{\"bevy_core_pipeline::core_3d::camera_3d::ScreenSpaceTransmissionQuality\":\"Medium\"}",
      "docs": " The quality of the screen space transmission blur effect, applied to whatever's “behind” transmissive\n objects when their `roughness` is greater than `0.0`.\n\n Higher qualities are more GPU-intensive.\n\n **Note:** You can get better-looking results at any quality level by enabling TAA. See: [`TemporalAntiAliasPlugin`](crate::experimental::taa::TemporalAntiAliasPlugin).",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_pbr::light::Cascade": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "world_from_cascade",
            "type_path": "glam::Mat4",
            "docs": " The transform of the light, i.e. the view to world matrix."
          },
          {
            "name": "clip_from_cascade",
            "type_path": "glam::Mat4",
            "docs": " The orthographic projection for this cascade."
          },
          {
            "name": "clip_from_world",
            "type_path": "glam::Mat4",
            "docs": " The view-projection matrix for this cascade, converting world space into light clip space.\n Importantly, this is derived and stored separately from `view_transform` and `projection` to\n ensure shadow stability."
          },
          {
            "name": "texel_size",
            "type_path": "f32",
            "docs": " Size of each shadow map texel in world units."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::Cascade",
        "short_type_path": "Cascade",
        "ident": "Cascade",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::Affine2": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "matrix2",
            "type_path": "glam::Mat2",
            "docs": null
          },
          {
            "name": "translation",
            "type_path": "glam::Vec2",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Affine2",
        "short_type_path": "Affine2",
        "ident": "Affine2",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Affine2\":[1.0,0.0,0.0,1.0,0.0,0.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::time::Time<()>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "context",
            "type_path": "()",
            "docs": null
          },
          {
            "name": "wrap_period",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "delta_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed_wrapped",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped_f64",
            "type_path": "f64",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::time::Time<()>",
        "short_type_path": "Time<()>",
        "ident": "Time",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::time"
      },
      "default": "{\"bevy_time::time::Time<()>\":{\"context\":[],\"wrap_period\":{\"secs\":3600,\"nanos\":0},\"delta\":{\"secs\":0,\"nanos\":0},\"delta_secs\":0.0,\"delta_secs_f64\":0.0,\"elapsed\":{\"secs\":0,\"nanos\":0},\"elapsed_secs\":0.0,\"elapsed_secs_f64\":0.0,\"elapsed_wrapped\":{\"secs\":0,\"nanos\":0},\"elapsed_secs_wrapped\":0.0,\"elapsed_secs_wrapped_f64\":0.0}}",
      "docs": " A generic clock resource that tracks how much it has advanced since its\n previous update and since its creation.\n\n Multiple instances of this resource are inserted automatically by\n [`TimePlugin`](crate::TimePlugin):\n\n - [`Time<Real>`](crate::real::Real) tracks real wall-clock time elapsed.\n - [`Time<Virtual>`](crate::virt::Virtual) tracks virtual game time that may\n   be paused or scaled.\n - [`Time<Fixed>`](crate::fixed::Fixed) tracks fixed timesteps based on\n   virtual time.\n - [`Time`] is a generic clock that corresponds to \"current\" or \"default\"\n   time for systems. It contains [`Time<Virtual>`](crate::virt::Virtual)\n   except inside the [`FixedMain`](bevy_app::FixedMain) schedule when it\n   contains [`Time<Fixed>`](crate::fixed::Fixed).\n\n The time elapsed since the previous time this clock was advanced is saved as\n [`delta()`](Time::delta) and the total amount of time the clock has advanced\n is saved as [`elapsed()`](Time::elapsed). Both are represented as exact\n [`Duration`] values with fixed nanosecond precision. The clock does not\n support time moving backwards, but it can be updated with [`Duration::ZERO`]\n which will set [`delta()`](Time::delta) to zero.\n\n These values are also available in seconds as `f32` via\n [`delta_secs()`](Time::delta_secs) and\n [`elapsed_secs()`](Time::elapsed_secs), and also in seconds as `f64`\n via [`delta_secs_f64()`](Time::delta_secs_f64) and\n [`elapsed_secs_f64()`](Time::elapsed_secs_f64).\n\n Since [`elapsed_secs()`](Time::elapsed_secs) will grow constantly and\n is `f32`, it will exhibit gradual precision loss. For applications that\n require an `f32` value but suffer from gradual precision loss there is\n [`elapsed_secs_wrapped()`](Time::elapsed_secs_wrapped) available. The\n same wrapped value is also available as [`Duration`] and `f64` for\n consistency. The wrap period is by default 1 hour, and can be set by\n [`set_wrap_period()`](Time::set_wrap_period).\n\n # Accessing clocks\n\n By default, any systems requiring current [`delta()`](Time::delta) or\n [`elapsed()`](Time::elapsed) should use `Res<Time>` to access the default\n time configured for the program. By default, this refers to\n [`Time<Virtual>`](crate::virt::Virtual) except during the\n [`FixedMain`](bevy_app::FixedMain) schedule when it refers to\n [`Time<Fixed>`](crate::fixed::Fixed). This ensures your system can be used\n either in [`Update`](bevy_app::Update) or\n [`FixedUpdate`](bevy_app::FixedUpdate) schedule depending on what is needed.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn ambivalent_system(time: Res<Time>) {\n     println!(\"this how I see time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system needs to react based on real time (wall clock time), like for\n user interfaces, it should use `Res<Time<Real>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will always\n correspond to real time and will not be affected by pause, time scaling or\n other tweaks.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn real_time_system(time: Res<Time<Real>>) {\n     println!(\"this will always be real time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system specifically needs to access fixed timestep clock, even when\n placed in `Update` schedule, you should use `Res<Time<Fixed>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will\n correspond to the latest fixed timestep that has been run.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Fixed>>) {\n     println!(\"this will always be the last executed fixed timestep: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n Finally, if your system specifically needs to know the current virtual game\n time, even if placed inside [`FixedUpdate`](bevy_app::FixedUpdate), for\n example to know if the game is [`was_paused()`](Time::was_paused) or to use\n [`effective_speed()`](Time::effective_speed), you can use\n `Res<Time<Virtual>>`. However, if the system is placed in\n [`FixedUpdate`](bevy_app::FixedUpdate), extra care must be used because your\n system might be run multiple times with the same [`delta()`](Time::delta)\n and [`elapsed()`](Time::elapsed) values as the virtual game time has not\n changed between the iterations.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Virtual>>) {\n     println!(\"this will be virtual time for this update: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n     println!(\"also the relative speed of the game is now {}\", time.effective_speed());\n }\n ```\n\n If you need to change the settings for any of the clocks, for example to\n [`pause()`](Time::pause) the game, you should use `ResMut<Time<Virtual>>`.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n #[derive(Event)]\n struct PauseEvent(bool);\n\n fn pause_system(mut time: ResMut<Time<Virtual>>, mut events: EventReader<PauseEvent>) {\n     for ev in events.read() {\n         if ev.0 {\n             time.pause();\n         } else {\n             time.unpause();\n         }\n     }\n }\n ```\n\n # Adding custom clocks\n\n New custom clocks can be created by creating your own struct as a context\n and passing it to [`new_with()`](Time::new_with). These clocks can be\n inserted as resources as normal and then accessed by systems. You can use\n the [`advance_by()`](Time::advance_by) or [`advance_to()`](Time::advance_to)\n methods to move the clock forwards based on your own logic.\n\n If you want to add methods for your time instance and they require access to\n both your context and the generic time part, it's probably simplest to add a\n custom trait for them and implement it for `Time<Custom>`.\n\n Your context struct will need to implement the [`Default`] trait because\n [`Time`] structures support reflection. It also makes initialization trivial\n by being able to call `app.init_resource::<Time<Custom>>()`.\n\n You can also replace the \"generic\" `Time` clock resource if the \"default\"\n time for your game should not be the default virtual time provided. You can\n get a \"generic\" snapshot of your clock by calling `as_generic()` and then\n overwrite the [`Time`] resource with it. The default systems added by\n [`TimePlugin`](crate::TimePlugin) will overwrite the [`Time`] clock during\n [`First`](bevy_app::First) and [`FixedUpdate`](bevy_app::FixedUpdate)\n schedules.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n # use bevy_utils::Instant;\n #\n #[derive(Debug)]\n struct Custom {\n     last_external_time: Instant,\n }\n\n impl Default for Custom {\n     fn default() -> Self {\n         Self {\n             last_external_time: Instant::now(),\n         }\n     }\n }\n\n trait CustomTime {\n     fn update_from_external(&mut self, instant: Instant);\n }\n\n impl CustomTime for Time<Custom> {\n     fn update_from_external(&mut self, instant: Instant) {\n          let delta = instant - self.context().last_external_time;\n          self.advance_by(delta);\n          self.context_mut().last_external_time = instant;\n     }\n }\n ```",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_gizmos::light::LightGizmoColor": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Manual",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::color::Color",
                "docs": null
              }
            ],
            "docs": " User-specified color."
          },
          {
            "kind": "unit",
            "name": "Varied",
            "docs": " Random color derived from the light's [`Entity`]."
          },
          {
            "kind": "unit",
            "name": "MatchLightColor",
            "docs": " Take the color of the represented light."
          },
          {
            "kind": "unit",
            "name": "ByLightType",
            "docs": " Take the color provided by [`LightGizmoConfigGroup`] depending on the light kind."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gizmos::light::LightGizmoColor",
        "short_type_path": "LightGizmoColor",
        "ident": "LightGizmoColor",
        "crate_name": "bevy_gizmos",
        "module_path": "bevy_gizmos::light"
      },
      "default": null,
      "docs": " Configures how a color is attributed to a light gizmo.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::view::visibility::NoFrustumCulling": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_render::view::visibility::NoFrustumCulling",
        "short_type_path": "NoFrustumCulling",
        "ident": "NoFrustumCulling",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::visibility"
      },
      "default": "{\"bevy_render::view::visibility::NoFrustumCulling\":{}}",
      "docs": " Use this component to opt-out of built-in frustum culling for entities, see\n [`Frustum`].\n\n It can be used for example:\n - when a [`Mesh`] is updated but its [`Aabb`] is not, which might happen with animations,\n - when using some light effects, like wanting a [`Mesh`] out of the [`Frustum`]\n     to appear in the reflection of a [`Mesh`] within.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "u16": {
      "info": {
        "kind": "opaque",
        "item_type_path": "u16"
      },
      "path_table": {
        "path": "u16",
        "short_type_path": "u16",
        "ident": "u16",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"u16\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::borrow::Cow<str>": {
      "info": {
        "kind": "opaque",
        "item_type_path": "alloc::borrow::Cow<str>"
      },
      "path_table": {
        "path": "alloc::borrow::Cow<str>",
        "short_type_path": "Cow<str>",
        "ident": "Cow",
        "crate_name": "alloc",
        "module_path": "alloc::borrow"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::lcha::Lcha": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "lightness",
            "type_path": "f32",
            "docs": " The lightness channel. [0.0, 1.5]"
          },
          {
            "name": "chroma",
            "type_path": "f32",
            "docs": " The chroma channel. [0.0, 1.5]"
          },
          {
            "name": "hue",
            "type_path": "f32",
            "docs": " The hue channel. [0.0, 360.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::lcha::Lcha",
        "short_type_path": "Lcha",
        "ident": "Lcha",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::lcha"
      },
      "default": "{\"bevy_color::lcha::Lcha\":{\"lightness\":1.0,\"chroma\":0.0,\"hue\":0.0,\"alpha\":1.0}}",
      "docs": " Color in LCH color space, with alpha\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::RepeatAnimation": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Never",
            "docs": " The animation will finish after running once."
          },
          {
            "kind": "tuple",
            "name": "Count",
            "fields": [
              {
                "index": 0,
                "type_path": "u32",
                "docs": null
              }
            ],
            "docs": " The animation will finish after running \"n\" times."
          },
          {
            "kind": "unit",
            "name": "Forever",
            "docs": " The animation will never finish."
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::RepeatAnimation",
        "short_type_path": "RepeatAnimation",
        "ident": "RepeatAnimation",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": " Repetition behavior of an animation.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::mesh::components::Mesh2d": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::mesh::components::Mesh2d",
        "short_type_path": "Mesh2d",
        "ident": "Mesh2d",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::mesh::components"
      },
      "default": "{\"bevy_render::mesh::components::Mesh2d\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A component for 2D meshes. Requires a [`MeshMaterial2d`] to be rendered, commonly using a [`ColorMaterial`].\n\n [`MeshMaterial2d`]: <https://docs.rs/bevy/latest/bevy/sprite/struct.MeshMaterial2d.html>\n [`ColorMaterial`]: <https://docs.rs/bevy/latest/bevy/sprite/struct.ColorMaterial.html>\n\n # Example\n\n ```ignore\n # use bevy_sprite::{ColorMaterial, Mesh2d, MeshMaterial2d};\n # use bevy_ecs::prelude::*;\n # use bevy_render::mesh::Mesh;\n # use bevy_color::palettes::basic::RED;\n # use bevy_asset::Assets;\n # use bevy_math::primitives::Circle;\n #\n // Spawn an entity with a mesh using `ColorMaterial`.\n fn setup(\n     mut commands: Commands,\n     mut meshes: ResMut<Assets<Mesh>>,\n     mut materials: ResMut<Assets<ColorMaterial>>,\n ) {\n     commands.spawn((\n         Mesh2d(meshes.add(Circle::new(50.0))),\n         MeshMaterial2d(materials.add(ColorMaterial::from_color(RED))),\n     ));\n }\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_color::laba::Laba": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "lightness",
            "type_path": "f32",
            "docs": " The lightness channel. [0.0, 1.5]"
          },
          {
            "name": "a",
            "type_path": "f32",
            "docs": " The a axis. [-1.5, 1.5]"
          },
          {
            "name": "b",
            "type_path": "f32",
            "docs": " The b axis. [-1.5, 1.5]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::laba::Laba",
        "short_type_path": "Laba",
        "ident": "Laba",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::laba"
      },
      "default": "{\"bevy_color::laba::Laba\":{\"lightness\":1.0,\"a\":0.0,\"b\":0.0,\"alpha\":1.0}}",
      "docs": " Color in LAB color space, with alpha\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::prepass::MotionVectorPrepass": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_core_pipeline::prepass::MotionVectorPrepass",
        "short_type_path": "MotionVectorPrepass",
        "ident": "MotionVectorPrepass",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::prepass"
      },
      "default": "{\"bevy_core_pipeline::prepass::MotionVectorPrepass\":{}}",
      "docs": " If added to a [`crate::prelude::Camera3d`] then screen space motion vectors will be copied to a separate texture available to the main pass.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::light::Cascades": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "cascades",
            "type_path": "bevy_utils::hashbrown::HashMap<bevy_ecs::entity::Entity, alloc::vec::Vec<bevy_pbr::light::Cascade>, bevy_ecs::entity::hash::EntityHash>",
            "docs": " Map from a view to the configuration of each of its [`Cascade`]s."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::Cascades",
        "short_type_path": "Cascades",
        "ident": "Cascades",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": "{\"bevy_pbr::light::Cascades\":{\"cascades\":{}}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::focus::Interaction": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Pressed",
            "docs": " The node has been pressed.\n\n Note: This does not capture click/press-release action."
          },
          {
            "kind": "unit",
            "name": "Hovered",
            "docs": " The node has been hovered over"
          },
          {
            "kind": "unit",
            "name": "None",
            "docs": " Nothing has happened"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::focus::Interaction",
        "short_type_path": "Interaction",
        "ident": "Interaction",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::focus"
      },
      "default": "{\"bevy_ui::focus::Interaction\":\"None\"}",
      "docs": " Describes what type of input interaction has occurred for a UI node.\n\n This is commonly queried with a `Changed<Interaction>` filter.\n\n Updated in [`ui_focus_system`].\n\n If a UI node has both [`Interaction`] and [`ViewVisibility`] components,\n [`Interaction`] will always be [`Interaction::None`]\n when [`ViewVisibility::get()`] is false.\n This ensures that hidden UI nodes are not interactable,\n and do not end up stuck in an active state if hidden at the wrong time.\n\n Note that you can also control the visibility of a node using the [`Display`](crate::ui_node::Display) property,\n which fully collapses it during layout calculations.\n\n # See also\n\n - [`Button`](crate::widget::Button) which requires this component\n - [`RelativeCursorPosition`] to obtain the position of the cursor relative to current node",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_scene::components::SceneRoot": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_asset::handle::Handle<bevy_scene::scene::Scene>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_scene::components::SceneRoot",
        "short_type_path": "SceneRoot",
        "ident": "SceneRoot",
        "crate_name": "bevy_scene",
        "module_path": "bevy_scene::components"
      },
      "default": null,
      "docs": " Adding this component will spawn the scene as a child of that entity.\n Once it's spawned, the entity will have a [`SceneInstance`](crate::SceneInstance) component.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::prepass::DeferredPrepass": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_core_pipeline::prepass::DeferredPrepass",
        "short_type_path": "DeferredPrepass",
        "ident": "DeferredPrepass",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::prepass"
      },
      "default": "{\"bevy_core_pipeline::prepass::DeferredPrepass\":{}}",
      "docs": " If added to a [`crate::prelude::Camera3d`] then deferred materials will be rendered to the deferred gbuffer texture and will be available to subsequent passes.\n Note the default deferred lighting plugin also requires `DepthPrepass` to work correctly.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_pbr::pbr_material::StandardMaterial>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "path",
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_pbr::pbr_material::StandardMaterial>",
        "short_type_path": "AssetPlaceholder<StandardMaterial>",
        "ident": "AssetPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::asset_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::camera::clear_color::ClearColorConfig": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Default",
            "docs": " The clear color is taken from the world's [`ClearColor`] resource."
          },
          {
            "kind": "tuple",
            "name": "Custom",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::color::Color",
                "docs": null
              }
            ],
            "docs": " The given clear color is used, overriding the [`ClearColor`] resource defined in the world."
          },
          {
            "kind": "unit",
            "name": "None",
            "docs": " No clear color is used: the camera will simply draw on top of anything already in the viewport.\n\n This can be useful when multiple cameras are rendering to the same viewport."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::clear_color::ClearColorConfig",
        "short_type_path": "ClearColorConfig",
        "ident": "ClearColorConfig",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::clear_color"
      },
      "default": "{\"bevy_render::camera::clear_color::ClearColorConfig\":\"Default\"}",
      "docs": " For a camera, specifies the color used to clear the viewport before rendering.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::texture_slice::slicer::SliceScaleMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " The slice will be stretched to fit the area"
          },
          {
            "kind": "struct",
            "name": "Tile",
            "fields": [
              {
                "name": "stretch_value",
                "type_path": "f32",
                "docs": " The slice will repeat when the ratio between the *drawing dimensions* of texture and the\n *original texture size* are above `stretch_value`.\n\n Example: `1.0` means that a 10 pixel wide image would repeat after 10 screen pixels.\n `2.0` means it would repeat after 20 screen pixels.\n\n Note: The value should be inferior or equal to `1.0` to avoid quality loss.\n\n Note: the value will be clamped to `0.001` if lower"
              }
            ],
            "docs": " The slice will be tiled to fit the area"
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::texture_slice::slicer::SliceScaleMode",
        "short_type_path": "SliceScaleMode",
        "ident": "SliceScaleMode",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::texture_slice::slicer"
      },
      "default": null,
      "docs": " Defines how a texture slice scales when resized",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_picking::input::PointerInputPlugin": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "is_touch_enabled",
            "type_path": "bool",
            "docs": " Should touch inputs be updated?"
          },
          {
            "name": "is_mouse_enabled",
            "type_path": "bool",
            "docs": " Should mouse inputs be updated?"
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::input::PointerInputPlugin",
        "short_type_path": "PointerInputPlugin",
        "ident": "PointerInputPlugin",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking::input"
      },
      "default": "{\"bevy_picking::input::PointerInputPlugin\":{\"is_touch_enabled\":true,\"is_mouse_enabled\":true}}",
      "docs": " Adds mouse and touch inputs for picking pointers to your app. This is a default input plugin,\n that you can replace with your own plugin as needed.\n\n [`crate::PickingPlugin::is_input_enabled`] can be used to toggle whether\n the core picking plugin processes the inputs sent by this, or other input plugins, in one place.\n\n This plugin contains several settings, and is added to the world as a resource after initialization.\n You can configure pointer input settings at runtime by accessing the resource.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "core::option::Option<bevy_math::rects::rect::Rect>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_math::rects::rect::Rect",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_math::rects::rect::Rect>",
        "short_type_path": "Option<Rect>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::Display": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Flex",
            "docs": " Use Flexbox layout model to determine the position of this [`Node`]'s children."
          },
          {
            "kind": "unit",
            "name": "Grid",
            "docs": " Use CSS Grid layout model to determine the position of this [`Node`]'s children."
          },
          {
            "kind": "unit",
            "name": "Block",
            "docs": " Use CSS Block layout model to determine the position of this [`Node`]'s children."
          },
          {
            "kind": "unit",
            "name": "None",
            "docs": " Use no layout, don't render this node and its children.\n\n If you want to hide a node and its children,\n but keep its layout in place, set its [`Visibility`] component instead."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::Display",
        "short_type_path": "Display",
        "ident": "Display",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::Display\":\"Flex\"}",
      "docs": " Defines the layout model used by this node.\n\n Part of the [`Node`] component.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::num::NonZeroU16": {
      "info": {
        "kind": "opaque",
        "item_type_path": "core::num::NonZeroU16"
      },
      "path_table": {
        "path": "core::num::NonZeroU16",
        "short_type_path": "NonZeroU16",
        "ident": "NonZeroU16",
        "crate_name": "core",
        "module_path": "core::num"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_animation::graph::AnimationGraph>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_animation::graph::AnimationGraph>",
        "short_type_path": "AssetId<AnimationGraph>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<u16>": {
      "info": {
        "kind": "list",
        "item_type_path": "u16"
      },
      "path_table": {
        "path": "alloc::vec::Vec<u16>",
        "short_type_path": "Vec<u16>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::transition::AnimationTransitions": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "main_animation",
            "type_path": "core::option::Option<petgraph::graph::NodeIndex>",
            "docs": null
          },
          {
            "name": "transitions",
            "type_path": "alloc::vec::Vec<bevy_animation::transition::AnimationTransition>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::transition::AnimationTransitions",
        "short_type_path": "AnimationTransitions",
        "ident": "AnimationTransitions",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation::transition"
      },
      "default": "{\"bevy_animation::transition::AnimationTransitions\":{\"main_animation\":null,\"transitions\":[]}}",
      "docs": " Manages fade-out of animation blend factors, allowing for smooth transitions\n between animations.\n\n To use this component, place it on the same entity as the\n [`AnimationPlayer`] and [`AnimationGraphHandle`](crate::AnimationGraphHandle). It'll take\n responsibility for adjusting the weight on the [`ActiveAnimation`] in order\n to fade out animations smoothly.\n\n When using an [`AnimationTransitions`] component, you should play all\n animations through the [`AnimationTransitions::play`] method, rather than by\n directly manipulating the [`AnimationPlayer`]. Playing animations through\n the [`AnimationPlayer`] directly will cause the [`AnimationTransitions`]\n component to get confused about which animation is the \"main\" animation, and\n transitions will usually be incorrect as a result.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_animation::graph::AnimationGraph>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_animation::graph::AnimationGraph>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_animation::graph::AnimationGraph>",
        "short_type_path": "Handle<AnimationGraph>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_animation::graph::AnimationGraph>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::text::JustifyText": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Left",
            "docs": " Leftmost character is immediately to the right of the render position.\n Bounds start from the render position and advance rightwards."
          },
          {
            "kind": "unit",
            "name": "Center",
            "docs": " Leftmost & rightmost characters are equidistant to the render position.\n Bounds start from the render position and advance equally left & right."
          },
          {
            "kind": "unit",
            "name": "Right",
            "docs": " Rightmost character is immediately to the left of the render position.\n Bounds start from the render position and advance leftwards."
          },
          {
            "kind": "unit",
            "name": "Justified",
            "docs": " Words are spaced so that leftmost & rightmost characters\n align with their margins.\n Bounds start from the render position and advance equally left & right."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::JustifyText",
        "short_type_path": "JustifyText",
        "ident": "JustifyText",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": null,
      "docs": " Describes the horizontal alignment of multiple lines of text relative to each other.\n\n This only affects the internal positioning of the lines of text within a text entity and\n does not affect the text entity's position.\n\n _Has no affect on a single line text entity._",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<bevy_ecs::entity::Entity>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_ecs::entity::Entity",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_ecs::entity::Entity>",
        "short_type_path": "Option<Entity>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_picking::pointer::PointerLocation": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_picking::pointer::PointerLocation",
        "short_type_path": "PointerLocation",
        "ident": "PointerLocation",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking::pointer"
      },
      "default": "{\"bevy_picking::pointer::PointerLocation\":{}}",
      "docs": " Component that tracks a pointer's current [`Location`].",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_gltf::GltfSkin>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_gltf::GltfSkin>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_gltf::GltfSkin>",
        "short_type_path": "Handle<GltfSkin>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_gltf::GltfSkin>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::hsva::Hsva": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "hue",
            "type_path": "f32",
            "docs": " The hue channel. [0.0, 360.0]"
          },
          {
            "name": "saturation",
            "type_path": "f32",
            "docs": " The saturation channel. [0.0, 1.0]"
          },
          {
            "name": "value",
            "type_path": "f32",
            "docs": " The value channel. [0.0, 1.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::hsva::Hsva",
        "short_type_path": "Hsva",
        "ident": "Hsva",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::hsva"
      },
      "default": "{\"bevy_color::hsva::Hsva\":{\"hue\":0.0,\"saturation\":0.0,\"value\":1.0,\"alpha\":1.0}}",
      "docs": " Color in Hue-Saturation-Value (HSV) color space with alpha.\n Further information on this color model can be found on [Wikipedia](https://en.wikipedia.org/wiki/HSL_and_HSV).\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::num::NonZeroI16": {
      "info": {
        "kind": "opaque",
        "item_type_path": "core::num::NonZeroI16"
      },
      "path_table": {
        "path": "core::num::NonZeroI16",
        "short_type_path": "NonZeroI16",
        "ident": "NonZeroI16",
        "crate_name": "core",
        "module_path": "core::num"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::xyza::Xyza": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "f32",
            "docs": " The x-axis. [0.0, 1.0]"
          },
          {
            "name": "y",
            "type_path": "f32",
            "docs": " The y-axis, intended to represent luminance. [0.0, 1.0]"
          },
          {
            "name": "z",
            "type_path": "f32",
            "docs": " The z-axis. [0.0, 1.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::xyza::Xyza",
        "short_type_path": "Xyza",
        "ident": "Xyza",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::xyza"
      },
      "default": "{\"bevy_color::xyza::Xyza\":{\"x\":0.0,\"y\":0.0,\"z\":0.0,\"alpha\":1.0}}",
      "docs": " [CIE 1931](https://en.wikipedia.org/wiki/CIE_1931_color_space) color space, also known as XYZ, with an alpha channel.\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::SpriteSource": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_sprite::SpriteSource",
        "short_type_path": "SpriteSource",
        "ident": "SpriteSource",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite"
      },
      "default": "{\"bevy_sprite::SpriteSource\":{}}",
      "docs": " A component that marks entities that aren't themselves sprites but become\n sprites during rendering.\n\n Right now, this is used for `Text`.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_audio::pitch::Pitch>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_audio::pitch::Pitch>",
        "short_type_path": "AssetId<Pitch>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::AnimationTargetId": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "uuid::Uuid",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::AnimationTargetId",
        "short_type_path": "AnimationTargetId",
        "ident": "AnimationTargetId",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": " A unique [UUID] for an animation target (e.g. bone in a skinned mesh).\n\n The [`AnimationClip`] asset and the [`AnimationTarget`] component both use\n this to refer to targets (e.g. bones in a skinned mesh) to be animated.\n\n When importing an armature or an animation clip, asset loaders typically use\n the full path name from the armature to the bone to generate these UUIDs.\n The ID is unique to the full path name and based only on the names. So, for\n example, any imported armature with a bone at the root named `Hips` will\n assign the same [`AnimationTargetId`] to its root bone. Likewise, any\n imported animation clip that animates a root bone named `Hips` will\n reference the same [`AnimationTargetId`]. Any animation is playable on any\n armature as long as the bone names match, which allows for easy animation\n retargeting.\n\n Note that asset loaders generally use the *full* path name to generate the\n [`AnimationTargetId`]. Thus a bone named `Chest` directly connected to a\n bone named `Hips` will have a different ID from a bone named `Chest` that's\n connected to a bone named `Stomach`.\n\n [UUID]: https://en.wikipedia.org/wiki/Universally_unique_identifier",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::fog::DistanceFog": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": " The color of the fog effect.\n\n **Tip:** The alpha channel of the color can be used to “modulate” the fog effect without\n changing the fog falloff mode or parameters."
          },
          {
            "name": "directional_light_color",
            "type_path": "bevy_color::color::Color",
            "docs": " Color used to modulate the influence of directional light colors on the\n fog, where the view direction aligns with each directional light direction,\n producing a “glow” or light dispersion effect. (e.g. around the sun)\n\n Use [`Color::NONE`] to disable the effect."
          },
          {
            "name": "directional_light_exponent",
            "type_path": "f32",
            "docs": " The exponent applied to the directional light alignment calculation.\n A higher value means a more concentrated “glow”."
          },
          {
            "name": "falloff",
            "type_path": "bevy_pbr::fog::FogFalloff",
            "docs": " Determines which falloff mode to use, and its parameters."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::fog::DistanceFog",
        "short_type_path": "DistanceFog",
        "ident": "DistanceFog",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::fog"
      },
      "default": "{\"bevy_pbr::fog::DistanceFog\":{\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"directional_light_color\":{\"LinearRgba\":{\"red\":0.0,\"green\":0.0,\"blue\":0.0,\"alpha\":0.0}},\"directional_light_exponent\":8.0,\"falloff\":{\"Linear\":{\"start\":0.0,\"end\":100.0}}}}",
      "docs": " Configures the “classic” computer graphics [distance fog](https://en.wikipedia.org/wiki/Distance_fog) effect,\n in which objects appear progressively more covered in atmospheric haze the further away they are from the camera.\n Affects meshes rendered via the PBR [`StandardMaterial`](crate::StandardMaterial).\n\n ## Falloff\n\n The rate at which fog intensity increases with distance is controlled by the falloff mode.\n Currently, the following fog falloff modes are supported:\n\n - [`FogFalloff::Linear`]\n - [`FogFalloff::Exponential`]\n - [`FogFalloff::ExponentialSquared`]\n - [`FogFalloff::Atmospheric`]\n\n ## Example\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_render::prelude::*;\n # use bevy_core_pipeline::prelude::*;\n # use bevy_pbr::prelude::*;\n # use bevy_color::Color;\n # fn system(mut commands: Commands) {\n commands.spawn((\n     // Setup your camera as usual\n     Camera3d::default(),\n     // Add fog to the same entity\n     DistanceFog {\n         color: Color::WHITE,\n         falloff: FogFalloff::Exponential { density: 1e-3 },\n         ..Default::default()\n     },\n ));\n # }\n # bevy_ecs::system::assert_is_system(system);\n ```\n\n ## Material Override\n\n Once enabled for a specific camera, the fog effect can also be disabled for individual\n [`StandardMaterial`](crate::StandardMaterial) instances via the `fog_enabled` flag.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_text::bounds::TextBounds": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "width",
            "type_path": "core::option::Option<f32>",
            "docs": " The maximum width of text in logical pixels.\n If `None`, the width is unbounded."
          },
          {
            "name": "height",
            "type_path": "core::option::Option<f32>",
            "docs": " The maximum height of text in logical pixels.\n If `None`, the height is unbounded."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::bounds::TextBounds",
        "short_type_path": "TextBounds",
        "ident": "TextBounds",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::bounds"
      },
      "default": "{\"bevy_text::bounds::TextBounds\":{\"width\":null,\"height\":null}}",
      "docs": " The maximum width and height of text. The text will wrap according to the specified size.\n\n Characters out of the bounds after wrapping will be truncated. Text is aligned according to the\n specified [`JustifyText`](crate::text::JustifyText).\n\n Note: only characters that are completely out of the bounds will be truncated, so this is not a\n reliable limit if it is necessary to contain the text strictly in the bounds. Currently this\n component is mainly useful for text wrapping only.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_sprite::mesh2d::color_material::ColorMaterial": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": null
          },
          {
            "name": "alpha_mode",
            "type_path": "bevy_sprite::mesh2d::material::AlphaMode2d",
            "docs": null
          },
          {
            "name": "texture",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::mesh2d::color_material::ColorMaterial",
        "short_type_path": "ColorMaterial",
        "ident": "ColorMaterial",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::mesh2d::color_material"
      },
      "default": "{\"bevy_sprite::mesh2d::color_material::ColorMaterial\":{\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"alpha_mode\":\"Blend\",\"texture\":null}}",
      "docs": " A [2d material](Material2d) that renders [2d meshes](crate::Mesh2d) with a texture tinted by a uniform color",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<f32>": {
      "info": {
        "kind": "list",
        "item_type_path": "f32"
      },
      "path_table": {
        "path": "alloc::vec::Vec<f32>",
        "short_type_path": "Vec<f32>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::sprite::SpriteImageMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Auto",
            "docs": " The sprite will take on the size of the image by default, and will be stretched or shrunk if [`Sprite::custom_size`] is set."
          },
          {
            "kind": "tuple",
            "name": "Sliced",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_sprite::texture_slice::slicer::TextureSlicer",
                "docs": null
              }
            ],
            "docs": " The texture will be cut in 9 slices, keeping the texture in proportions on resize"
          },
          {
            "kind": "struct",
            "name": "Tiled",
            "fields": [
              {
                "name": "tile_x",
                "type_path": "bool",
                "docs": " Should the image repeat horizontally"
              },
              {
                "name": "tile_y",
                "type_path": "bool",
                "docs": " Should the image repeat vertically"
              },
              {
                "name": "stretch_value",
                "type_path": "f32",
                "docs": " The texture will repeat when the ratio between the *drawing dimensions* of texture and the\n *original texture size* are above this value."
              }
            ],
            "docs": " The texture will be repeated if stretched beyond `stretched_value`"
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::sprite::SpriteImageMode",
        "short_type_path": "SpriteImageMode",
        "ident": "SpriteImageMode",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::sprite"
      },
      "default": null,
      "docs": " Controls how the image is altered when scaled.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::BorderRadius": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "top_left",
            "type_path": "bevy_ui::geometry::Val",
            "docs": null
          },
          {
            "name": "top_right",
            "type_path": "bevy_ui::geometry::Val",
            "docs": null
          },
          {
            "name": "bottom_left",
            "type_path": "bevy_ui::geometry::Val",
            "docs": null
          },
          {
            "name": "bottom_right",
            "type_path": "bevy_ui::geometry::Val",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::BorderRadius",
        "short_type_path": "BorderRadius",
        "ident": "BorderRadius",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::BorderRadius\":{\"top_left\":{\"Px\":0.0},\"top_right\":{\"Px\":0.0},\"bottom_left\":{\"Px\":0.0},\"bottom_right\":{\"Px\":0.0}}}",
      "docs": " Used to add rounded corners to a UI node. You can set a UI node to have uniformly\n rounded corners or specify different radii for each corner. If a given radius exceeds half\n the length of the smallest dimension between the node's height or width, the radius will\n calculated as half the smallest dimension.\n\n Elliptical nodes are not supported yet. Percentage values are based on the node's smallest\n dimension, either width or height.\n\n # Example\n ```rust\n # use bevy_ecs::prelude::*;\n # use bevy_ui::prelude::*;\n # use bevy_color::palettes::basic::{BLUE};\n fn setup_ui(mut commands: Commands) {\n     commands.spawn((\n         Node {\n             width: Val::Px(100.),\n             height: Val::Px(100.),\n             border: UiRect::all(Val::Px(2.)),\n             ..Default::default()\n         },\n         BackgroundColor(BLUE.into()),\n         BorderRadius::new(\n             // top left\n             Val::Px(10.),\n             // top right\n             Val::Px(20.),\n             // bottom right\n             Val::Px(30.),\n             // bottom left\n             Val::Px(40.),\n         ),\n     ));\n }\n ```\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius>",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_utils::Instant": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_utils::Instant"
      },
      "path_table": {
        "path": "bevy_utils::Instant",
        "short_type_path": "Instant",
        "ident": "Instant",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_animation::AnimationClip>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "path",
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_animation::AnimationClip>",
        "short_type_path": "AssetPlaceholder<AnimationClip>",
        "ident": "AssetPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::asset_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_sprite::texture_atlas::TextureAtlasLayout>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_sprite::texture_atlas::TextureAtlasLayout>",
        "short_type_path": "AssetId<TextureAtlasLayout>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::timer::Timer": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "stopwatch",
            "type_path": "bevy_time::stopwatch::Stopwatch",
            "docs": null
          },
          {
            "name": "duration",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "mode",
            "type_path": "bevy_time::timer::TimerMode",
            "docs": null
          },
          {
            "name": "finished",
            "type_path": "bool",
            "docs": null
          },
          {
            "name": "times_finished_this_tick",
            "type_path": "u32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::timer::Timer",
        "short_type_path": "Timer",
        "ident": "Timer",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::timer"
      },
      "default": "{\"bevy_time::timer::Timer\":{\"stopwatch\":{\"elapsed\":{\"secs\":0,\"nanos\":0},\"is_paused\":false},\"duration\":{\"secs\":0,\"nanos\":0},\"mode\":\"Once\",\"finished\":false,\"times_finished_this_tick\":0}}",
      "docs": " Tracks elapsed time. Enters the finished state once `duration` is reached.\n\n Non repeating timers will stop tracking and stay in the finished state until reset.\n Repeating timers will only be in the finished state on each tick `duration` is reached or\n exceeded, and can still be reset at any given point.\n\n Paused timers will not have elapsed time increased.\n\n Note that in order to advance the timer [`tick`](Timer::tick) **MUST** be called.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::cluster::ClusterFarZMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "MaxClusterableObjectRange",
            "docs": " Calculate the required maximum z-depth based on currently visible\n clusterable objects.  Makes better use of available clusters, speeding\n up GPU lighting operations at the expense of some CPU time and using\n more indices in the clusterable object index lists."
          },
          {
            "kind": "tuple",
            "name": "Constant",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Constant max z-depth"
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::cluster::ClusterFarZMode",
        "short_type_path": "ClusterFarZMode",
        "ident": "ClusterFarZMode",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::cluster"
      },
      "default": null,
      "docs": " Configure the far z-plane mode used for the furthest depth slice for clustered forward\n rendering",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::OverflowAxis": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Visible",
            "docs": " Show overflowing items."
          },
          {
            "kind": "unit",
            "name": "Clip",
            "docs": " Hide overflowing items by clipping."
          },
          {
            "kind": "unit",
            "name": "Hidden",
            "docs": " Hide overflowing items by influencing layout and then clipping."
          },
          {
            "kind": "unit",
            "name": "Scroll",
            "docs": " Scroll overflowing items."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::OverflowAxis",
        "short_type_path": "OverflowAxis",
        "ident": "OverflowAxis",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::OverflowAxis\":\"Visible\"}",
      "docs": " Whether to show or hide overflowing items",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<alloc::vec::Vec<alloc::string::String>>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::vec::Vec<alloc::string::String>",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<alloc::vec::Vec<alloc::string::String>>",
        "short_type_path": "Option<Vec<String>>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::UiScale": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::UiScale",
        "short_type_path": "UiScale",
        "ident": "UiScale",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui"
      },
      "default": "{\"bevy_ui::UiScale\":1.0}",
      "docs": " The current scale of the UI.\n\n A multiplier to fixed-sized ui values.\n **Note:** This will only affect fixed ui values like [`Val::Px`]",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_asset::id::AssetId<bevy_pbr::pbr_material::StandardMaterial>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_pbr::pbr_material::StandardMaterial>",
        "short_type_path": "AssetId<StandardMaterial>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::primitives::CubemapFrusta": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_render::primitives::CubemapFrusta",
        "short_type_path": "CubemapFrusta",
        "ident": "CubemapFrusta",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::primitives"
      },
      "default": "{\"bevy_render::primitives::CubemapFrusta\":{}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::view::ColorGrading": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "global",
            "type_path": "bevy_render::view::ColorGradingGlobal",
            "docs": " Filmic color grading values applied to the image as a whole (as opposed\n to individual sections, like shadows and highlights)."
          },
          {
            "name": "shadows",
            "type_path": "bevy_render::view::ColorGradingSection",
            "docs": " Color grading values that are applied to the darker parts of the image.\n\n The cutoff points can be customized with the\n [`ColorGradingGlobal::midtones_range`] field."
          },
          {
            "name": "midtones",
            "type_path": "bevy_render::view::ColorGradingSection",
            "docs": " Color grading values that are applied to the parts of the image with\n intermediate brightness.\n\n The cutoff points can be customized with the\n [`ColorGradingGlobal::midtones_range`] field."
          },
          {
            "name": "highlights",
            "type_path": "bevy_render::view::ColorGradingSection",
            "docs": " Color grading values that are applied to the lighter parts of the image.\n\n The cutoff points can be customized with the\n [`ColorGradingGlobal::midtones_range`] field."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::ColorGrading",
        "short_type_path": "ColorGrading",
        "ident": "ColorGrading",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view"
      },
      "default": null,
      "docs": " Configures filmic color grading parameters to adjust the image appearance.\n\n Color grading is applied just before tonemapping for a given\n [`Camera`](crate::camera::Camera) entity, with the sole exception of the\n `post_saturation` value in [`ColorGradingGlobal`], which is applied after\n tonemapping.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_math::primitives::dim2::Circle": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "radius",
            "type_path": "f32",
            "docs": " The radius of the circle"
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::primitives::dim2::Circle",
        "short_type_path": "Circle",
        "ident": "Circle",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::primitives::dim2"
      },
      "default": "{\"bevy_math::primitives::dim2::Circle\":{\"radius\":0.5}}",
      "docs": " A circle primitive, representing the set of points some distance from the origin",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_asset::assets::LoadedUntypedAsset>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_asset::assets::LoadedUntypedAsset>",
        "short_type_path": "AssetId<LoadedUntypedAsset>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_mesh::mesh::Mesh>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>",
        "short_type_path": "Handle<Mesh>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::text::FontSmoothing": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": " No antialiasing. Useful for when you want to render text with a pixel art aesthetic.\n\n Combine this with `UiAntiAlias::Off` and `Msaa::Off` on your 2D camera for a fully pixelated look.\n\n **Note:** Due to limitations of the underlying text rendering library,\n this may require specially-crafted pixel fonts to look good, especially at small sizes."
          },
          {
            "kind": "unit",
            "name": "AntiAliased",
            "docs": " The default grayscale antialiasing. Produces text that looks smooth,\n even at small font sizes and low resolutions with modern vector fonts."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::FontSmoothing",
        "short_type_path": "FontSmoothing",
        "ident": "FontSmoothing",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": null,
      "docs": " Determines which antialiasing method to use when rendering text. By default, text is\n rendered with grayscale antialiasing, but this can be changed to achieve a pixelated look.\n\n **Note:** Subpixel antialiasing is not currently supported.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_image::image::Image>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_image::image::Image>",
        "short_type_path": "AssetId<Image>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::text::ComputedTextBlock": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "entities",
            "type_path": "smallvec::SmallVec<[bevy_text::text::TextEntity; 1]>",
            "docs": " Entities for all text spans in the block, including the root-level text.\n\n The [`TextEntity::depth`] field can be used to reconstruct the hierarchy."
          },
          {
            "name": "needs_rerender",
            "type_path": "bool",
            "docs": " Flag set when any change has been made to this block that should cause it to be rerendered.\n\n Includes:\n - [`TextLayout`] changes.\n - [`TextFont`] or `Text2d`/`Text`/`TextSpan` changes anywhere in the block's entity hierarchy."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::ComputedTextBlock",
        "short_type_path": "ComputedTextBlock",
        "ident": "ComputedTextBlock",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": "{\"bevy_text::text::ComputedTextBlock\":{\"entities\":[],\"needs_rerender\":true}}",
      "docs": " Computed information for a text block.\n\n See [`TextLayout`].\n\n Automatically updated by 2d and UI text systems.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_hierarchy::components::children::Children": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "smallvec::SmallVec<[bevy_ecs::entity::Entity; 8]>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_hierarchy::components::children::Children",
        "short_type_path": "Children",
        "ident": "Children",
        "crate_name": "bevy_hierarchy",
        "module_path": "bevy_hierarchy::components::children"
      },
      "default": null,
      "docs": " Contains references to the child entities of this entity.\n\n Each child must contain a [`Parent`] component that points back to this entity.\n This component rarely needs to be created manually,\n consider using higher level utilities like [`BuildChildren::with_children`]\n which are safer and easier to use.\n\n See [`HierarchyQueryExt`] for hierarchy related methods on [`Query`].\n\n [`HierarchyQueryExt`]: crate::query_extension::HierarchyQueryExt\n [`Query`]: bevy_ecs::system::Query\n [`Parent`]: crate::components::parent::Parent\n [`BuildChildren::with_children`]: crate::child_builder::BuildChildren::with_children",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_text::text::TextColor": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_color::color::Color",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::TextColor",
        "short_type_path": "TextColor",
        "ident": "TextColor",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": "{\"bevy_text::text::TextColor\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}}}",
      "docs": " The color of the text for this section.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "glam::UVec2": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "u32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "u32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::UVec2",
        "short_type_path": "UVec2",
        "ident": "UVec2",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::UVec2\":[0,0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gltf::GltfMeshExtras": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "value",
            "type_path": "alloc::string::String",
            "docs": " Content of the extra data."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gltf::GltfMeshExtras",
        "short_type_path": "GltfMeshExtras",
        "ident": "GltfMeshExtras",
        "crate_name": "bevy_gltf",
        "module_path": "bevy_gltf"
      },
      "default": "{\"bevy_gltf::GltfMeshExtras\":{\"value\":\"\"}}",
      "docs": " Additional untyped data that can be present on most glTF types at the mesh level.\n\n See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "smallvec::SmallVec<[u64; 1]>": {
      "info": {
        "kind": "list",
        "item_type_path": "u64"
      },
      "path_table": {
        "path": "smallvec::SmallVec<[u64; 1]>",
        "short_type_path": "SmallVec<[u64; 1]>",
        "ident": "SmallVec",
        "crate_name": "smallvec",
        "module_path": "smallvec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_math::primitives::dim3::Cuboid": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "half_size",
            "type_path": "glam::Vec3",
            "docs": " Half of the width, height and depth of the cuboid"
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::primitives::dim3::Cuboid",
        "short_type_path": "Cuboid",
        "ident": "Cuboid",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::primitives::dim3"
      },
      "default": "{\"bevy_math::primitives::dim3::Cuboid\":{\"half_size\":[0.5,0.5,0.5]}}",
      "docs": " A cuboid primitive, which is like a cube, except that the x, y, and z dimensions are not\n required to be the same.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_gltf::GltfNode>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_gltf::GltfNode>",
        "short_type_path": "AssetId<GltfNode>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::ssao::ScreenSpaceAmbientOcclusion": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "quality_level",
            "type_path": "bevy_pbr::ssao::ScreenSpaceAmbientOcclusionQualityLevel",
            "docs": " Quality of the SSAO effect."
          },
          {
            "name": "constant_object_thickness",
            "type_path": "f32",
            "docs": " A constant estimated thickness of objects.\n\n This value is used to decide how far behind an object a ray of light needs to be in order\n to pass behind it. Any ray closer than that will be occluded."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::ssao::ScreenSpaceAmbientOcclusion",
        "short_type_path": "ScreenSpaceAmbientOcclusion",
        "ident": "ScreenSpaceAmbientOcclusion",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::ssao"
      },
      "default": "{\"bevy_pbr::ssao::ScreenSpaceAmbientOcclusion\":{\"quality_level\":\"High\",\"constant_object_thickness\":0.25}}",
      "docs": " Component to apply screen space ambient occlusion to a 3d camera.\n\n Screen space ambient occlusion (SSAO) approximates small-scale,\n local occlusion of _indirect_ diffuse light between objects, based on what's visible on-screen.\n SSAO does not apply to direct lighting, such as point or directional lights.\n\n This darkens creases, e.g. on staircases, and gives nice contact shadows\n where objects meet, giving entities a more \"grounded\" feel.\n\n # Usage Notes\n\n Requires that you add [`ScreenSpaceAmbientOcclusionPlugin`] to your app.\n\n It strongly recommended that you use SSAO in conjunction with\n TAA ([`bevy_core_pipeline::experimental::taa::TemporalAntiAliasing`]).\n Doing so greatly reduces SSAO noise.\n\n SSAO is not supported on `WebGL2`, and is not currently supported on `WebGPU`.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::camera::projection::OrthographicProjection": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "near",
            "type_path": "f32",
            "docs": " The distance of the near clipping plane in world units.\n\n Objects closer than this will not be rendered.\n\n Defaults to `0.0`"
          },
          {
            "name": "far",
            "type_path": "f32",
            "docs": " The distance of the far clipping plane in world units.\n\n Objects further than this will not be rendered.\n\n Defaults to `1000.0`"
          },
          {
            "name": "viewport_origin",
            "type_path": "glam::Vec2",
            "docs": " Specifies the origin of the viewport as a normalized position from 0 to 1, where (0, 0) is the bottom left\n and (1, 1) is the top right. This determines where the camera's position sits inside the viewport.\n\n When the projection scales due to viewport resizing, the position of the camera, and thereby `viewport_origin`,\n remains at the same relative point.\n\n Consequently, this is pivot point when scaling. With a bottom left pivot, the projection will expand\n upwards and to the right. With a top right pivot, the projection will expand downwards and to the left.\n Values in between will caused the projection to scale proportionally on each axis.\n\n Defaults to `(0.5, 0.5)`, which makes scaling affect opposite sides equally, keeping the center\n point of the viewport centered."
          },
          {
            "name": "scaling_mode",
            "type_path": "bevy_render::camera::projection::ScalingMode",
            "docs": " How the projection will scale to the viewport.\n\n Defaults to [`ScalingMode::WindowSize`],\n and works in concert with [`OrthographicProjection::scale`] to determine the final effect.\n\n For simplicity, zooming should be done by changing [`OrthographicProjection::scale`],\n rather than changing the parameters of the scaling mode."
          },
          {
            "name": "scale",
            "type_path": "f32",
            "docs": " Scales the projection.\n\n As scale increases, the apparent size of objects decreases, and vice versa.\n\n Note: scaling can be set by [`scaling_mode`](Self::scaling_mode) as well.\n This parameter scales on top of that.\n\n This property is particularly useful in implementing zoom functionality.\n\n Defaults to `1.0`, which under standard settings corresponds to a 1:1 mapping of world units to rendered pixels.\n See [`ScalingMode::WindowSize`] for more information."
          },
          {
            "name": "area",
            "type_path": "bevy_math::rects::rect::Rect",
            "docs": " The area that the projection covers relative to `viewport_origin`.\n\n Bevy's [`camera_system`](crate::camera::camera_system) automatically\n updates this value when the viewport is resized depending on `OrthographicProjection`'s other fields.\n In this case, `area` should not be manually modified.\n\n It may be necessary to set this manually for shadow projections and such."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::projection::OrthographicProjection",
        "short_type_path": "OrthographicProjection",
        "ident": "OrthographicProjection",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::projection"
      },
      "default": null,
      "docs": " Project a 3D space onto a 2D surface using parallel lines, i.e., unlike [`PerspectiveProjection`],\n the size of objects remains the same regardless of their distance to the camera.\n\n The volume contained in the projection is called the *view frustum*. Since the viewport is rectangular\n and projection lines are parallel, the view frustum takes the shape of a cuboid.\n\n Note that the scale of the projection and the apparent size of objects are inversely proportional.\n As the size of the projection increases, the size of objects decreases.\n\n # Examples\n\n Configure the orthographic projection to one world unit per 100 window pixels:\n\n ```\n # use bevy_render::camera::{OrthographicProjection, Projection, ScalingMode};\n let projection = Projection::Orthographic(OrthographicProjection {\n     scaling_mode: ScalingMode::WindowSize,\n     scale: 0.01,\n     ..OrthographicProjection::default_2d()\n });\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_scene::components::DynamicSceneRoot": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_asset::handle::Handle<bevy_scene::dynamic_scene::DynamicScene>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_scene::components::DynamicSceneRoot",
        "short_type_path": "DynamicSceneRoot",
        "ident": "DynamicSceneRoot",
        "crate_name": "bevy_scene",
        "module_path": "bevy_scene::components"
      },
      "default": null,
      "docs": " Adding this component will spawn the scene as a child of that entity.\n Once it's spawned, the entity will have a [`SceneInstance`](crate::SceneInstance) component.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gizmos::light::LightGizmoConfigGroup": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "draw_all",
            "type_path": "bool",
            "docs": " Draw a gizmo for all lights if true.\n\n Defaults to `false`."
          },
          {
            "name": "color",
            "type_path": "bevy_gizmos::light::LightGizmoColor",
            "docs": " Default color strategy for all light gizmos.\n\n Defaults to [`LightGizmoColor::MatchLightColor`]."
          },
          {
            "name": "point_light_color",
            "type_path": "bevy_color::color::Color",
            "docs": " [`Color`] to use for drawing a [`PointLight`] gizmo when [`LightGizmoColor::ByLightType`] is used.\n\n Defaults to [`RED`]."
          },
          {
            "name": "spot_light_color",
            "type_path": "bevy_color::color::Color",
            "docs": " [`Color`] to use for drawing a [`SpotLight`] gizmo when [`LightGizmoColor::ByLightType`] is used.\n\n Defaults to [`GREEN`]."
          },
          {
            "name": "directional_light_color",
            "type_path": "bevy_color::color::Color",
            "docs": " [`Color`] to use for drawing a [`DirectionalLight`] gizmo when [`LightGizmoColor::ByLightType`] is used.\n\n Defaults to [`BLUE`]."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gizmos::light::LightGizmoConfigGroup",
        "short_type_path": "LightGizmoConfigGroup",
        "ident": "LightGizmoConfigGroup",
        "crate_name": "bevy_gizmos",
        "module_path": "bevy_gizmos::light"
      },
      "default": null,
      "docs": " The [`GizmoConfigGroup`] used to configure the visualization of lights.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::view::ColorGradingGlobal": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "exposure",
            "type_path": "f32",
            "docs": " Exposure value (EV) offset, measured in stops."
          },
          {
            "name": "temperature",
            "type_path": "f32",
            "docs": " An adjustment made to the [CIE 1931] chromaticity *x* value.\n\n Positive values make the colors redder. Negative values make the colors\n bluer. This has no effect on luminance (brightness).\n\n [CIE 1931]: https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_xy_chromaticity_diagram_and_the_CIE_xyY_color_space"
          },
          {
            "name": "tint",
            "type_path": "f32",
            "docs": " An adjustment made to the [CIE 1931] chromaticity *y* value.\n\n Positive values make the colors more magenta. Negative values make the\n colors greener. This has no effect on luminance (brightness).\n\n [CIE 1931]: https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_xy_chromaticity_diagram_and_the_CIE_xyY_color_space"
          },
          {
            "name": "hue",
            "type_path": "f32",
            "docs": " An adjustment to the [hue], in radians.\n\n Adjusting this value changes the perceived colors in the image: red to\n yellow to green to blue, etc. It has no effect on the saturation or\n brightness of the colors.\n\n [hue]: https://en.wikipedia.org/wiki/HSL_and_HSV#Formal_derivation"
          },
          {
            "name": "post_saturation",
            "type_path": "f32",
            "docs": " Saturation adjustment applied after tonemapping.\n Values below 1.0 desaturate, with a value of 0.0 resulting in a grayscale image\n with luminance defined by ITU-R BT.709\n Values above 1.0 increase saturation."
          },
          {
            "name": "midtones_range",
            "type_path": "core::ops::Range<f32>",
            "docs": " The luminance (brightness) ranges that are considered part of the\n \"midtones\" of the image.\n\n This affects which [`ColorGradingSection`]s apply to which colors. Note\n that the sections smoothly blend into one another, to avoid abrupt\n transitions.\n\n The default value is 0.2 to 0.7."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::ColorGradingGlobal",
        "short_type_path": "ColorGradingGlobal",
        "ident": "ColorGradingGlobal",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view"
      },
      "default": null,
      "docs": " Filmic color grading values applied to the image as a whole (as opposed to\n individual sections, like shadows and highlights).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::TimedAnimationEvent": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "time",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "event",
            "type_path": "bevy_animation::AnimationEvent",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::TimedAnimationEvent",
        "short_type_path": "TimedAnimationEvent",
        "ident": "TimedAnimationEvent",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::focus::FocusPolicy": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Block",
            "docs": " Blocks interaction"
          },
          {
            "kind": "unit",
            "name": "Pass",
            "docs": " Lets interaction pass through"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::focus::FocusPolicy",
        "short_type_path": "FocusPolicy",
        "ident": "FocusPolicy",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::focus"
      },
      "default": "{\"bevy_ui::focus::FocusPolicy\":\"Pass\"}",
      "docs": " Describes whether the node should block interactions with lower nodes",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::light::ambient_light::AmbientLight": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": null
          },
          {
            "name": "brightness",
            "type_path": "f32",
            "docs": " A direct scale factor multiplied with `color` before being passed to the shader.\n\n After applying this multiplier, the resulting value should be in units of [cd/m^2].\n\n [cd/m^2]: https://en.wikipedia.org/wiki/Candela_per_square_metre"
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::ambient_light::AmbientLight",
        "short_type_path": "AmbientLight",
        "ident": "AmbientLight",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light::ambient_light"
      },
      "default": "{\"bevy_pbr::light::ambient_light::AmbientLight\":{\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"brightness\":80.0}}",
      "docs": " An ambient light, which lights the entire scene equally.\n\n This resource is inserted by the [`PbrPlugin`] and by default it is set to a low ambient light.\n\n # Examples\n\n Make ambient light slightly brighter:\n\n ```\n # use bevy_ecs::system::ResMut;\n # use bevy_pbr::AmbientLight;\n fn setup_ambient_light(mut ambient_light: ResMut<AmbientLight>) {\n    ambient_light.brightness = 100.0;\n }\n ```",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_time::virt::Virtual": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "max_delta",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "paused",
            "type_path": "bool",
            "docs": null
          },
          {
            "name": "relative_speed",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "effective_speed",
            "type_path": "f64",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::virt::Virtual",
        "short_type_path": "Virtual",
        "ident": "Virtual",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::virt"
      },
      "default": null,
      "docs": " The virtual game clock representing game time.\n\n A specialization of the [`Time`] structure. **For method documentation, see\n [`Time<Virtual>#impl-Time<Virtual>`].**\n\n Normally used as `Time<Virtual>`. It is automatically inserted as a resource\n by [`TimePlugin`](crate::TimePlugin) and updated based on\n [`Time<Real>`](Real). The virtual clock is automatically set as the default\n generic [`Time`] resource for the update.\n\n The virtual clock differs from real time clock in that it can be paused, sped up\n and slowed down. It also limits how much it can advance in a single update\n in order to prevent unexpected behavior in cases where updates do not happen\n at regular intervals (e.g. coming back after the program was suspended a long time).\n\n The virtual clock can be paused by calling [`pause()`](Time::pause) and\n unpaused by calling [`unpause()`](Time::unpause). When the game clock is\n paused [`delta()`](Time::delta) will be zero on each update, and\n [`elapsed()`](Time::elapsed) will not grow.\n [`effective_speed()`](Time::effective_speed) will return `0.0`. Calling\n [`pause()`](Time::pause) will not affect value the [`delta()`](Time::delta)\n value for the update currently being processed.\n\n The speed of the virtual clock can be changed by calling\n [`set_relative_speed()`](Time::set_relative_speed). A value of `2.0` means\n that virtual clock should advance twice as fast as real time, meaning that\n [`delta()`](Time::delta) values will be double of what\n [`Time<Real>::delta()`](Time::delta) reports and\n [`elapsed()`](Time::elapsed) will go twice as fast as\n [`Time<Real>::elapsed()`](Time::elapsed). Calling\n [`set_relative_speed()`](Time::set_relative_speed) will not affect the\n [`delta()`](Time::delta) value for the update currently being processed.\n\n The maximum amount of delta time that can be added by a single update can be\n set by [`set_max_delta()`](Time::set_max_delta). This value serves a dual\n purpose in the virtual clock.\n\n If the game temporarily freezes due to any reason, such as disk access, a\n blocking system call, or operating system level suspend, reporting the full\n elapsed delta time is likely to cause bugs in game logic. Usually if a\n laptop is suspended for an hour, it doesn't make sense to try to simulate\n the game logic for the elapsed hour when resuming. Instead it is better to\n lose the extra time and pretend a shorter duration of time passed. Setting\n [`max_delta()`](Time::max_delta) to a relatively short time means that the\n impact on game logic will be minimal.\n\n If the game lags for some reason, meaning that it will take a longer time to\n compute a frame than the real time that passes during the computation, then\n we would fall behind in processing virtual time. If this situation persists,\n and computing a frame takes longer depending on how much virtual time has\n passed, the game would enter a \"death spiral\" where computing each frame\n takes longer and longer and the game will appear to freeze. By limiting the\n maximum time that can be added at once, we also limit the amount of virtual\n time the game needs to compute for each frame. This means that the game will\n run slow, and it will run slower than real time, but it will not freeze and\n it will recover as soon as computation becomes fast again.\n\n You should set [`max_delta()`](Time::max_delta) to a value that is\n approximately the minimum FPS your game should have even if heavily lagged\n for a moment. The actual FPS when lagged will be somewhat lower than this,\n depending on how much more time it takes to compute a frame compared to real\n time. You should also consider how stable your FPS is, as the limit will\n also dictate how big of an FPS drop you can accept without losing time and\n falling behind real time.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::widget::text::Text": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::widget::text::Text",
        "short_type_path": "Text",
        "ident": "Text",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::widget::text"
      },
      "default": "{\"bevy_ui::widget::text::Text\":\"\"}",
      "docs": " The top-level UI text component.\n\n Adding [`Text`] to an entity will pull in required components for setting up a UI text node.\n\n The string in this component is the first 'text span' in a hierarchy of text spans that are collected into\n a [`ComputedTextBlock`]. See [`TextSpan`](bevy_text::TextSpan) for the component used by children of entities with [`Text`].\n\n Note that [`Transform`](bevy_transform::components::Transform) on this entity is managed automatically by the UI layout system.\n\n\n ```\n # use bevy_asset::Handle;\n # use bevy_color::Color;\n # use bevy_color::palettes::basic::BLUE;\n # use bevy_ecs::world::World;\n # use bevy_text::{Font, JustifyText, TextLayout, TextFont, TextColor};\n # use bevy_ui::prelude::Text;\n #\n # let font_handle: Handle<Font> = Default::default();\n # let mut world = World::default();\n #\n // Basic usage.\n world.spawn(Text::new(\"hello world!\"));\n\n // With non-default style.\n world.spawn((\n     Text::new(\"hello world!\"),\n     TextFont {\n         font: font_handle.clone().into(),\n         font_size: 60.0,\n         ..Default::default()\n     },\n     TextColor(BLUE.into()),\n ));\n\n // With text justification.\n world.spawn((\n     Text::new(\"hello world\\nand bevy!\"),\n     TextLayout::new_with_justify(JustifyText::Center)\n ));\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::AlignItems": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Default",
            "docs": " The items are packed in their default position as if no alignment was applied."
          },
          {
            "kind": "unit",
            "name": "Start",
            "docs": " The items are packed towards the start of the axis."
          },
          {
            "kind": "unit",
            "name": "End",
            "docs": " The items are packed towards the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexStart",
            "docs": " The items are packed towards the start of the axis, unless the flex direction is reversed;\n then they are packed towards the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexEnd",
            "docs": " The items are packed towards the end of the axis, unless the flex direction is reversed;\n then they are packed towards the start of the axis."
          },
          {
            "kind": "unit",
            "name": "Center",
            "docs": " The items are packed along the center of the axis."
          },
          {
            "kind": "unit",
            "name": "Baseline",
            "docs": " The items are packed such that their baselines align."
          },
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " The items are stretched to fill the space they're given."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::AlignItems",
        "short_type_path": "AlignItems",
        "ident": "AlignItems",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::AlignItems\":\"Default\"}",
      "docs": " Used to control how each individual item is aligned by default within the space they're given.\n - For Flexbox containers, sets default cross axis alignment of the child items.\n - For CSS Grid containers, controls block (vertical) axis alignment of children of this grid container within their grid areas.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/align-items>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::real::Real": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "startup",
            "type_path": "bevy_utils::Instant",
            "docs": null
          },
          {
            "name": "first_update",
            "type_path": "core::option::Option<bevy_utils::Instant>",
            "docs": null
          },
          {
            "name": "last_update",
            "type_path": "core::option::Option<bevy_utils::Instant>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::real::Real",
        "short_type_path": "Real",
        "ident": "Real",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::real"
      },
      "default": null,
      "docs": " Real time clock representing elapsed wall clock time.\n\n A specialization of the [`Time`] structure. **For method documentation, see\n [`Time<Real>#impl-Time<Real>`].**\n\n It is automatically inserted as a resource by\n [`TimePlugin`](crate::TimePlugin) and updated with time instants according\n to [`TimeUpdateStrategy`](crate::TimeUpdateStrategy).[^disclaimer]\n\n Note:\n Using [`TimeUpdateStrategy::ManualDuration`](crate::TimeUpdateStrategy::ManualDuration)\n allows for mocking the wall clock for testing purposes.\n Besides this use case, it is not recommended to do this, as it will no longer\n represent \"wall clock\" time as intended.\n\n The [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values of this\n clock should be used for anything which deals specifically with real time\n (wall clock time). It will not be affected by relative game speed\n adjustments, pausing or other adjustments.[^disclaimer]\n\n The clock does not count time from [`startup()`](Time::startup) to\n [`first_update()`](Time::first_update()) into elapsed, but instead will\n start counting time from the first update call. [`delta()`](Time::delta) and\n [`elapsed()`](Time::elapsed) will report zero on the first update as there\n is no previous update instant. This means that a [`delta()`](Time::delta) of\n zero must be handled without errors in application logic, as it may\n theoretically also happen at other times.\n\n [`Instant`]s for [`startup()`](Time::startup),\n [`first_update()`](Time::first_update) and\n [`last_update()`](Time::last_update) are recorded and accessible.\n\n [^disclaimer]: When using [`TimeUpdateStrategy::ManualDuration`](crate::TimeUpdateStrategy::ManualDuration),\n     [`Time<Real>#impl-Time<Real>`] is only a *mock* of wall clock time.\n",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::projection::PerspectiveProjection": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "fov",
            "type_path": "f32",
            "docs": " The vertical field of view (FOV) in radians.\n\n Defaults to a value of π/4 radians or 45 degrees."
          },
          {
            "name": "aspect_ratio",
            "type_path": "f32",
            "docs": " The aspect ratio (width divided by height) of the viewing frustum.\n\n Bevy's [`camera_system`](crate::camera::camera_system) automatically\n updates this value when the aspect ratio of the associated window changes.\n\n Defaults to a value of `1.0`."
          },
          {
            "name": "near",
            "type_path": "f32",
            "docs": " The distance from the camera in world units of the viewing frustum's near plane.\n\n Objects closer to the camera than this value will not be visible.\n\n Defaults to a value of `0.1`."
          },
          {
            "name": "far",
            "type_path": "f32",
            "docs": " The distance from the camera in world units of the viewing frustum's far plane.\n\n Objects farther from the camera than this value will not be visible.\n\n Defaults to a value of `1000.0`."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::projection::PerspectiveProjection",
        "short_type_path": "PerspectiveProjection",
        "ident": "PerspectiveProjection",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::projection"
      },
      "default": "{\"bevy_render::camera::projection::PerspectiveProjection\":{\"fov\":0.7853982,\"aspect_ratio\":1.0,\"near\":0.1,\"far\":1000.0}}",
      "docs": " A 3D camera projection in which distant objects appear smaller than close objects.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<()>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<()>",
        "short_type_path": "AssetId<()>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_asset::folder::LoadedFolder>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_asset::folder::LoadedFolder>",
        "short_type_path": "AssetId<LoadedFolder>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_utils::hashbrown::HashMap<bevy_asset::id::AssetId<bevy_animation::graph::AnimationGraph>, bevy_animation::graph::ThreadedAnimationGraph, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>": {
      "info": {
        "kind": "map",
        "key_type_path": "bevy_asset::id::AssetId<bevy_animation::graph::AnimationGraph>",
        "value_type_path": "bevy_animation::graph::ThreadedAnimationGraph"
      },
      "path_table": {
        "path": "bevy_utils::hashbrown::HashMap<bevy_asset::id::AssetId<bevy_animation::graph::AnimationGraph>, bevy_animation::graph::ThreadedAnimationGraph, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
        "short_type_path": "HashMap<AssetId<AnimationGraph>, ThreadedAnimationGraph, DefaultHashBuilder>",
        "ident": "HashMap",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils::hashbrown"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::manual_texture_view::ManualTextureViewHandle": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "u32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::manual_texture_view::ManualTextureViewHandle",
        "short_type_path": "ManualTextureViewHandle",
        "ident": "ManualTextureViewHandle",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::manual_texture_view"
      },
      "default": "{\"bevy_render::camera::manual_texture_view::ManualTextureViewHandle\":0}",
      "docs": " A unique id that corresponds to a specific [`ManualTextureView`] in the [`ManualTextureViews`] collection.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "core::option::Option<f32>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<f32>",
        "short_type_path": "Option<f32>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::color::Color": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Srgba",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::srgba::Srgba",
                "docs": null
              }
            ],
            "docs": " A color in the sRGB color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "LinearRgba",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::linear_rgba::LinearRgba",
                "docs": null
              }
            ],
            "docs": " A color in the linear sRGB color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Hsla",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::hsla::Hsla",
                "docs": null
              }
            ],
            "docs": " A color in the HSL color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Hsva",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::hsva::Hsva",
                "docs": null
              }
            ],
            "docs": " A color in the HSV color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Hwba",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::hwba::Hwba",
                "docs": null
              }
            ],
            "docs": " A color in the HWB color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Laba",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::laba::Laba",
                "docs": null
              }
            ],
            "docs": " A color in the LAB color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Lcha",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::lcha::Lcha",
                "docs": null
              }
            ],
            "docs": " A color in the LCH color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Oklaba",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::oklaba::Oklaba",
                "docs": null
              }
            ],
            "docs": " A color in the Oklab color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Oklcha",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::oklcha::Oklcha",
                "docs": null
              }
            ],
            "docs": " A color in the Oklch color space with alpha."
          },
          {
            "kind": "tuple",
            "name": "Xyza",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::xyza::Xyza",
                "docs": null
              }
            ],
            "docs": " A color in the XYZ color space with alpha."
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::color::Color",
        "short_type_path": "Color",
        "ident": "Color",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::color"
      },
      "default": "{\"bevy_color::color::Color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}}}",
      "docs": " An enumerated type that can represent any of the color types in this crate.\n\n This is useful when you need to store a color in a data structure that can't be generic over\n the color type.\n <div>\n </div>\n\n # Operations\n\n [`Color`] supports all the standard color operations, such as [mixing](Mix),\n [luminance](Luminance) and [hue](Hue) adjustment,\n and [diffing](EuclideanDistance). These operations delegate to the concrete color space contained\n by [`Color`], but will convert to [`Oklch`](Oklcha) for operations which aren't supported in the\n current space. After performing the operation, if a conversion was required, the result will be\n converted back into the original color space.\n\n ```rust\n # use bevy_color::{Hue, Color};\n let red_hsv = Color::hsv(0., 1., 1.);\n let red_srgb = Color::srgb(1., 0., 0.);\n\n // HSV has a definition of hue, so it will be returned.\n red_hsv.hue();\n\n // SRGB doesn't have a native definition for hue.\n // Converts to Oklch and returns that result.\n red_srgb.hue();\n ```\n\n [`Oklch`](Oklcha) has been chosen as the intermediary space in cases where conversion is required\n due to its perceptual uniformity and broad support for Bevy's color operations.\n To avoid the cost of repeated conversion, and ensure consistent results where that is desired,\n first convert this [`Color`] into your desired color space.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::FlexWrap": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "NoWrap",
            "docs": " Single line, will overflow if needed."
          },
          {
            "kind": "unit",
            "name": "Wrap",
            "docs": " Multiple lines, if needed."
          },
          {
            "kind": "unit",
            "name": "WrapReverse",
            "docs": " Same as [`FlexWrap::Wrap`] but new lines will appear before the previous one."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::FlexWrap",
        "short_type_path": "FlexWrap",
        "ident": "FlexWrap",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::FlexWrap\":\"NoWrap\"}",
      "docs": " Defines if flexbox items appear on a single line or on multiple lines",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_picking::PickingBehavior": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "should_block_lower",
            "type_path": "bool",
            "docs": " Should this entity block entities below it from being picked?\n\n This is useful if you want picking to continue hitting entities below this one. Normally,\n only the topmost entity under a pointer can be hovered, but this setting allows the pointer\n to hover multiple entities, from nearest to farthest, stopping as soon as it hits an entity\n that blocks lower entities.\n\n Note that the word \"lower\" here refers to entities that have been reported as hit by any\n picking backend, but are at a lower depth than the current one. This is different from the\n concept of event bubbling, as it works irrespective of the entity hierarchy.\n\n For example, if a pointer is over a UI element, as well as a 3d mesh, backends will report\n hits for both of these entities. Additionally, the hits will be sorted by the camera order,\n so if the UI is drawing on top of the 3d mesh, the UI will be \"above\" the mesh. When focus\n is computed, the UI element will be checked first to see if it this field is set to block\n lower entities. If it does (default), the focus system will stop there, and only the UI\n element will be marked as hovered. However, if this field is set to `false`, both the UI\n element *and* the mesh will be marked as hovered.\n\n Entities without the [`PickingBehavior`] component will block by default."
          },
          {
            "name": "is_hoverable",
            "type_path": "bool",
            "docs": " If this is set to `false` and `should_block_lower` is set to true, this entity will block\n lower entities from being interacted and at the same time will itself not emit any events.\n\n Note that the word \"lower\" here refers to entities that have been reported as hit by any\n picking backend, but are at a lower depth than the current one. This is different from the\n concept of event bubbling, as it works irrespective of the entity hierarchy.\n\n For example, if a pointer is over a UI element, and this field is set to `false`, it will\n not be marked as hovered, and consequently will not emit events nor will any picking\n components mark it as hovered. This can be combined with the other field\n [`Self::should_block_lower`], which is orthogonal to this one.\n\n Entities without the [`PickingBehavior`] component are hoverable by default."
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::PickingBehavior",
        "short_type_path": "PickingBehavior",
        "ident": "PickingBehavior",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking"
      },
      "default": "{\"bevy_picking::PickingBehavior\":{\"should_block_lower\":true,\"is_hoverable\":true}}",
      "docs": " An optional component that overrides default picking behavior for an entity, allowing you to\n make an entity non-hoverable, or allow items below it to be hovered. See the documentation on\n the fields for more details.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_sprite::mesh2d::color_material::ColorMaterial>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_sprite::mesh2d::color_material::ColorMaterial>",
        "short_type_path": "AssetId<ColorMaterial>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::light_probe::irradiance_volume::IrradianceVolume": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "voxels",
            "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
            "docs": " The 3D texture that represents the ambient cubes, encoded in the format\n described in [`crate::irradiance_volume`]."
          },
          {
            "name": "intensity",
            "type_path": "f32",
            "docs": " Scale factor applied to the diffuse and specular light generated by this component.\n\n After applying this multiplier, the resulting values should\n be in units of [cd/m^2](https://en.wikipedia.org/wiki/Candela_per_square_metre).\n\n See also <https://google.github.io/filament/Filament.html#lighting/imagebasedlights/iblunit>."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light_probe::irradiance_volume::IrradianceVolume",
        "short_type_path": "IrradianceVolume",
        "ident": "IrradianceVolume",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light_probe::irradiance_volume"
      },
      "default": "{\"bevy_pbr::light_probe::irradiance_volume::IrradianceVolume\":{\"voxels\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}},\"intensity\":0.0}}",
      "docs": " The component that defines an irradiance volume.\n\n See [`crate::irradiance_volume`] for detailed information.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::pbr_material::StandardMaterial": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "base_color",
            "type_path": "bevy_color::color::Color",
            "docs": " The color of the surface of the material before lighting.\n\n Doubles as diffuse albedo for non-metallic, specular for metallic and a mix for everything\n in between. If used together with a `base_color_texture`, this is factored into the final\n base color as `base_color * base_color_texture_value`\n\n Defaults to [`Color::WHITE`]."
          },
          {
            "name": "base_color_channel",
            "type_path": "bevy_pbr::pbr_material::UvChannel",
            "docs": " The UV channel to use for the [`StandardMaterial::base_color_texture`].\n\n Defaults to [`UvChannel::Uv0`]."
          },
          {
            "name": "base_color_texture",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": " The texture component of the material's color before lighting.\n The actual pre-lighting color is `base_color * this_texture`.\n\n See [`base_color`] for details.\n\n You should set `base_color` to [`Color::WHITE`] (the default)\n if you want the texture to show as-is.\n\n Setting `base_color` to something else than white will tint\n the texture. For example, setting `base_color` to pure red will\n tint the texture red.\n\n [`base_color`]: StandardMaterial::base_color"
          },
          {
            "name": "emissive",
            "type_path": "bevy_color::linear_rgba::LinearRgba",
            "docs": " Color the material \"emits\" to the camera.\n\n This is typically used for monitor screens or LED lights.\n Anything that can be visible even in darkness.\n\n The emissive color is added to what would otherwise be the material's visible color.\n This means that for a light emissive value, in darkness,\n you will mostly see the emissive component.\n\n The default emissive color is [`LinearRgba::BLACK`], which doesn't add anything to the material color.\n\n To increase emissive strength, channel values for `emissive`\n colors can exceed `1.0`. For instance, a `base_color` of\n `LinearRgba::rgb(1.0, 0.0, 0.0)` represents the brightest\n red for objects that reflect light, but an emissive color\n like `LinearRgba::rgb(1000.0, 0.0, 0.0)` can be used to create\n intensely bright red emissive effects.\n\n Increasing the emissive strength of the color will impact visual effects\n like bloom, but it's important to note that **an emissive material won't\n light up surrounding areas like a light source**,\n it just adds a value to the color seen on screen."
          },
          {
            "name": "emissive_exposure_weight",
            "type_path": "f32",
            "docs": " The weight in which the camera exposure influences the emissive color.\n A value of `0.0` means the emissive color is not affected by the camera exposure.\n In opposition, a value of `1.0` means the emissive color is multiplied by the camera exposure.\n\n Defaults to `0.0`"
          },
          {
            "name": "emissive_channel",
            "type_path": "bevy_pbr::pbr_material::UvChannel",
            "docs": " The UV channel to use for the [`StandardMaterial::emissive_texture`].\n\n Defaults to [`UvChannel::Uv0`]."
          },
          {
            "name": "emissive_texture",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": " The emissive map, multiplies pixels with [`emissive`]\n to get the final \"emitting\" color of a surface.\n\n This color is multiplied by [`emissive`] to get the final emitted color.\n Meaning that you should set [`emissive`] to [`Color::WHITE`]\n if you want to use the full range of color of the emissive texture.\n\n [`emissive`]: StandardMaterial::emissive"
          },
          {
            "name": "perceptual_roughness",
            "type_path": "f32",
            "docs": " Linear perceptual roughness, clamped to `[0.089, 1.0]` in the shader.\n\n Defaults to `0.5`.\n\n Low values result in a \"glossy\" material with specular highlights,\n while values close to `1` result in rough materials.\n\n If used together with a roughness/metallic texture, this is factored into the final base\n color as `roughness * roughness_texture_value`.\n\n 0.089 is the minimum floating point value that won't be rounded down to 0 in the\n calculations used."
          },
          {
            "name": "metallic",
            "type_path": "f32",
            "docs": " How \"metallic\" the material appears, within `[0.0, 1.0]`.\n\n This should be set to 0.0 for dielectric materials or 1.0 for metallic materials.\n For a hybrid surface such as corroded metal, you may need to use in-between values.\n\n Defaults to `0.00`, for dielectric.\n\n If used together with a roughness/metallic texture, this is factored into the final base\n color as `metallic * metallic_texture_value`."
          },
          {
            "name": "metallic_roughness_channel",
            "type_path": "bevy_pbr::pbr_material::UvChannel",
            "docs": " The UV channel to use for the [`StandardMaterial::metallic_roughness_texture`].\n\n Defaults to [`UvChannel::Uv0`]."
          },
          {
            "name": "metallic_roughness_texture",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": " Metallic and roughness maps, stored as a single texture.\n\n The blue channel contains metallic values,\n and the green channel contains the roughness values.\n Other channels are unused.\n\n Those values are multiplied by the scalar ones of the material,\n see [`metallic`] and [`perceptual_roughness`] for details.\n\n Note that with the default values of [`metallic`] and [`perceptual_roughness`],\n setting this texture has no effect. If you want to exclusively use the\n `metallic_roughness_texture` values for your material, make sure to set [`metallic`]\n and [`perceptual_roughness`] to `1.0`.\n\n [`metallic`]: StandardMaterial::metallic\n [`perceptual_roughness`]: StandardMaterial::perceptual_roughness"
          },
          {
            "name": "reflectance",
            "type_path": "f32",
            "docs": " Specular intensity for non-metals on a linear scale of `[0.0, 1.0]`.\n\n Use the value as a way to control the intensity of the\n specular highlight of the material, i.e. how reflective is the material,\n rather than the physical property \"reflectance.\"\n\n Set to `0.0`, no specular highlight is visible, the highlight is strongest\n when `reflectance` is set to `1.0`.\n\n Defaults to `0.5` which is mapped to 4% reflectance in the shader."
          },
          {
            "name": "diffuse_transmission",
            "type_path": "f32",
            "docs": " The amount of light transmitted _diffusely_ through the material (i.e. “translucency”)\n\n Implemented as a second, flipped [Lambertian diffuse](https://en.wikipedia.org/wiki/Lambertian_reflectance) lobe,\n which provides an inexpensive but plausible approximation of translucency for thin dieletric objects (e.g. paper,\n leaves, some fabrics) or thicker volumetric materials with short scattering distances (e.g. porcelain, wax).\n\n For specular transmission usecases with refraction (e.g. glass) use the [`StandardMaterial::specular_transmission`] and\n [`StandardMaterial::ior`] properties instead.\n\n - When set to `0.0` (the default) no diffuse light is transmitted;\n - When set to `1.0` all diffuse light is transmitted through the material;\n - Values higher than `0.5` will cause more diffuse light to be transmitted than reflected, resulting in a “darker”\n   appearance on the side facing the light than the opposite side. (e.g. plant leaves)\n\n ## Notes\n\n - The material's [`StandardMaterial::base_color`] also modulates the transmitted light;\n - To receive transmitted shadows on the diffuse transmission lobe (i.e. the “backside”) of the material,\n   use the [`TransmittedShadowReceiver`] component."
          },
          {
            "name": "specular_transmission",
            "type_path": "f32",
            "docs": " The amount of light transmitted _specularly_ through the material (i.e. via refraction)\n\n - When set to `0.0` (the default) no light is transmitted.\n - When set to `1.0` all light is transmitted through the material.\n\n The material's [`StandardMaterial::base_color`] also modulates the transmitted light.\n\n **Note:** Typically used in conjunction with [`StandardMaterial::thickness`], [`StandardMaterial::ior`] and [`StandardMaterial::perceptual_roughness`].\n\n ## Performance\n\n Specular transmission is implemented as a relatively expensive screen-space effect that allows ocluded objects to be seen through the material,\n with distortion and blur effects.\n\n - [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) can be used to enable transmissive objects\n     to be seen through other transmissive objects, at the cost of additional draw calls and texture copies; (Use with caution!)\n     - If a simplified approximation of specular transmission using only environment map lighting is sufficient, consider setting\n         [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) to `0`.\n - If purely diffuse light transmission is needed, (i.e. “translucency”) consider using [`StandardMaterial::diffuse_transmission`] instead,\n     for a much less expensive effect.\n - Specular transmission is rendered before alpha blending, so any material with [`AlphaMode::Blend`], [`AlphaMode::Premultiplied`], [`AlphaMode::Add`] or [`AlphaMode::Multiply`]\n     won't be visible through specular transmissive materials."
          },
          {
            "name": "thickness",
            "type_path": "f32",
            "docs": " Thickness of the volume beneath the material surface.\n\n When set to `0.0` (the default) the material appears as an infinitely-thin film,\n transmitting light without distorting it.\n\n When set to any other value, the material distorts light like a thick lens.\n\n **Note:** Typically used in conjunction with [`StandardMaterial::specular_transmission`] and [`StandardMaterial::ior`], or with\n [`StandardMaterial::diffuse_transmission`]."
          },
          {
            "name": "ior",
            "type_path": "f32",
            "docs": " The [index of refraction](https://en.wikipedia.org/wiki/Refractive_index) of the material.\n\n Defaults to 1.5.\n\n | Material        | Index of Refraction  |\n |:----------------|:---------------------|\n | Vacuum          | 1                    |\n | Air             | 1.00                 |\n | Ice             | 1.31                 |\n | Water           | 1.33                 |\n | Eyes            | 1.38                 |\n | Quartz          | 1.46                 |\n | Olive Oil       | 1.47                 |\n | Honey           | 1.49                 |\n | Acrylic         | 1.49                 |\n | Window Glass    | 1.52                 |\n | Polycarbonate   | 1.58                 |\n | Flint Glass     | 1.69                 |\n | Ruby            | 1.71                 |\n | Glycerine       | 1.74                 |\n | Sapphire        | 1.77                 |\n | Cubic Zirconia  | 2.15                 |\n | Diamond         | 2.42                 |\n | Moissanite      | 2.65                 |\n\n **Note:** Typically used in conjunction with [`StandardMaterial::specular_transmission`] and [`StandardMaterial::thickness`]."
          },
          {
            "name": "attenuation_distance",
            "type_path": "f32",
            "docs": " How far, on average, light travels through the volume beneath the material's\n surface before being absorbed.\n\n Defaults to [`f32::INFINITY`], i.e. light is never absorbed.\n\n **Note:** To have any effect, must be used in conjunction with:\n - [`StandardMaterial::attenuation_color`];\n - [`StandardMaterial::thickness`];\n - [`StandardMaterial::diffuse_transmission`] or [`StandardMaterial::specular_transmission`]."
          },
          {
            "name": "attenuation_color",
            "type_path": "bevy_color::color::Color",
            "docs": " The resulting (non-absorbed) color after white light travels through the attenuation distance.\n\n Defaults to [`Color::WHITE`], i.e. no change.\n\n **Note:** To have any effect, must be used in conjunction with:\n - [`StandardMaterial::attenuation_distance`];\n - [`StandardMaterial::thickness`];\n - [`StandardMaterial::diffuse_transmission`] or [`StandardMaterial::specular_transmission`]."
          },
          {
            "name": "normal_map_channel",
            "type_path": "bevy_pbr::pbr_material::UvChannel",
            "docs": " The UV channel to use for the [`StandardMaterial::normal_map_texture`].\n\n Defaults to [`UvChannel::Uv0`]."
          },
          {
            "name": "normal_map_texture",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": " Used to fake the lighting of bumps and dents on a material.\n\n A typical usage would be faking cobblestones on a flat plane mesh in 3D.\n\n # Notes\n\n Normal mapping with `StandardMaterial` and the core bevy PBR shaders requires:\n - A normal map texture\n - Vertex UVs\n - Vertex tangents\n - Vertex normals\n\n Tangents do not have to be stored in your model,\n they can be generated using the [`Mesh::generate_tangents`] or\n [`Mesh::with_generated_tangents`] methods.\n If your material has a normal map, but still renders as a flat surface,\n make sure your meshes have their tangents set.\n\n [`Mesh::generate_tangents`]: bevy_render::mesh::Mesh::generate_tangents\n [`Mesh::with_generated_tangents`]: bevy_render::mesh::Mesh::with_generated_tangents"
          },
          {
            "name": "flip_normal_map_y",
            "type_path": "bool",
            "docs": " Normal map textures authored for DirectX have their y-component flipped. Set this to flip\n it to right-handed conventions."
          },
          {
            "name": "occlusion_channel",
            "type_path": "bevy_pbr::pbr_material::UvChannel",
            "docs": " The UV channel to use for the [`StandardMaterial::occlusion_texture`].\n\n Defaults to [`UvChannel::Uv0`]."
          },
          {
            "name": "occlusion_texture",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": " Specifies the level of exposure to ambient light.\n\n This is usually generated and stored automatically (\"baked\") by 3D-modeling software.\n\n Typically, steep concave parts of a model (such as the armpit of a shirt) are darker,\n because they have little exposure to light.\n An occlusion map specifies those parts of the model that light doesn't reach well.\n\n The material will be less lit in places where this texture is dark.\n This is similar to ambient occlusion, but built into the model."
          },
          {
            "name": "clearcoat",
            "type_path": "f32",
            "docs": " An extra thin translucent layer on top of the main PBR layer. This is\n typically used for painted surfaces.\n\n This value specifies the strength of the layer, which affects how\n visible the clearcoat layer will be.\n\n Defaults to zero, specifying no clearcoat layer."
          },
          {
            "name": "clearcoat_perceptual_roughness",
            "type_path": "f32",
            "docs": " The roughness of the clearcoat material. This is specified in exactly\n the same way as the [`StandardMaterial::perceptual_roughness`].\n\n If the [`StandardMaterial::clearcoat`] value if zero, this has no\n effect.\n\n Defaults to 0.5."
          },
          {
            "name": "anisotropy_strength",
            "type_path": "f32",
            "docs": " Increases the roughness along a specific direction, so that the specular\n highlight will be stretched instead of being a circular lobe.\n\n This value ranges from 0 (perfectly circular) to 1 (maximally\n stretched). The default direction (corresponding to a\n [`StandardMaterial::anisotropy_rotation`] of 0) aligns with the\n *tangent* of the mesh; thus mesh tangents must be specified in order for\n this parameter to have any meaning. The direction can be changed using\n the [`StandardMaterial::anisotropy_rotation`] parameter.\n\n This is typically used for modeling surfaces such as brushed metal and\n hair, in which one direction of the surface but not the other is smooth.\n\n See the [`KHR_materials_anisotropy` specification] for more details.\n\n [`KHR_materials_anisotropy` specification]:\n https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_anisotropy/README.md"
          },
          {
            "name": "anisotropy_rotation",
            "type_path": "f32",
            "docs": " The direction of increased roughness, in radians relative to the mesh\n tangent.\n\n This parameter causes the roughness to vary according to the\n [`StandardMaterial::anisotropy_strength`]. The rotation is applied in\n tangent-bitangent space; thus, mesh tangents must be present for this\n parameter to have any meaning.\n\n This parameter has no effect if\n [`StandardMaterial::anisotropy_strength`] is zero. Its value can\n optionally be adjusted across the mesh with the\n [`StandardMaterial::anisotropy_texture`].\n\n See the [`KHR_materials_anisotropy` specification] for more details.\n\n [`KHR_materials_anisotropy` specification]:\n https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_anisotropy/README.md"
          },
          {
            "name": "double_sided",
            "type_path": "bool",
            "docs": " Support two-sided lighting by automatically flipping the normals for \"back\" faces\n within the PBR lighting shader.\n\n Defaults to `false`.\n This does not automatically configure backface culling,\n which can be done via `cull_mode`."
          },
          {
            "name": "unlit",
            "type_path": "bool",
            "docs": " Whether to apply only the base color to this material.\n\n Normals, occlusion textures, roughness, metallic, reflectance, emissive,\n shadows, alpha mode and ambient light are ignored if this is set to `true`."
          },
          {
            "name": "fog_enabled",
            "type_path": "bool",
            "docs": " Whether to enable fog for this material."
          },
          {
            "name": "alpha_mode",
            "type_path": "bevy_render::alpha::AlphaMode",
            "docs": " How to apply the alpha channel of the `base_color_texture`.\n\n See [`AlphaMode`] for details. Defaults to [`AlphaMode::Opaque`]."
          },
          {
            "name": "depth_bias",
            "type_path": "f32",
            "docs": " Adjust rendered depth.\n\n A material with a positive depth bias will render closer to the\n camera while negative values cause the material to render behind\n other objects. This is independent of the viewport.\n\n `depth_bias` affects render ordering and depth write operations\n using the `wgpu::DepthBiasState::Constant` field.\n\n [z-fighting]: https://en.wikipedia.org/wiki/Z-fighting"
          },
          {
            "name": "depth_map",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": " The depth map used for [parallax mapping].\n\n It is a grayscale image where white represents bottom and black the top.\n If this field is set, bevy will apply [parallax mapping].\n Parallax mapping, unlike simple normal maps, will move the texture\n coordinate according to the current perspective,\n giving actual depth to the texture.\n\n The visual result is similar to a displacement map,\n but does not require additional geometry.\n\n Use the [`parallax_depth_scale`] field to control the depth of the parallax.\n\n ## Limitations\n\n - It will look weird on bent/non-planar surfaces.\n - The depth of the pixel does not reflect its visual position, resulting\n   in artifacts for depth-dependent features such as fog or SSAO.\n - For the same reason, the geometry silhouette will always be\n   the one of the actual geometry, not the parallaxed version, resulting\n   in awkward looks on intersecting parallaxed surfaces.\n\n ## Performance\n\n Parallax mapping requires multiple texture lookups, proportional to\n [`max_parallax_layer_count`], which might be costly.\n\n Use the [`parallax_mapping_method`] and [`max_parallax_layer_count`] fields\n to tweak the shader, trading graphical quality for performance.\n\n To improve performance, set your `depth_map`'s [`Image::sampler`]\n filter mode to `FilterMode::Nearest`, as [this paper] indicates, it improves\n performance a bit.\n\n To reduce artifacts, avoid steep changes in depth, blurring the depth\n map helps with this.\n\n Larger depth maps haves a disproportionate performance impact.\n\n [this paper]: https://www.diva-portal.org/smash/get/diva2:831762/FULLTEXT01.pdf\n [parallax mapping]: https://en.wikipedia.org/wiki/Parallax_mapping\n [`parallax_depth_scale`]: StandardMaterial::parallax_depth_scale\n [`parallax_mapping_method`]: StandardMaterial::parallax_mapping_method\n [`max_parallax_layer_count`]: StandardMaterial::max_parallax_layer_count"
          },
          {
            "name": "parallax_depth_scale",
            "type_path": "f32",
            "docs": " How deep the offset introduced by the depth map should be.\n\n Default is `0.1`, anything over that value may look distorted.\n Lower values lessen the effect.\n\n The depth is relative to texture size. This means that if your texture\n occupies a surface of `1` world unit, and `parallax_depth_scale` is `0.1`, then\n the in-world depth will be of `0.1` world units.\n If the texture stretches for `10` world units, then the final depth\n will be of `1` world unit."
          },
          {
            "name": "parallax_mapping_method",
            "type_path": "bevy_pbr::parallax::ParallaxMappingMethod",
            "docs": " Which parallax mapping method to use.\n\n We recommend that all objects use the same [`ParallaxMappingMethod`], to avoid\n duplicating and running two shaders."
          },
          {
            "name": "max_parallax_layer_count",
            "type_path": "f32",
            "docs": " In how many layers to split the depth maps for parallax mapping.\n\n If you are seeing jaggy edges, increase this value.\n However, this incurs a performance cost.\n\n Dependent on the situation, switching to [`ParallaxMappingMethod::Relief`]\n and keeping this value low might have better performance than increasing the\n layer count while using [`ParallaxMappingMethod::Occlusion`].\n\n Default is `16.0`."
          },
          {
            "name": "lightmap_exposure",
            "type_path": "f32",
            "docs": " The exposure (brightness) level of the lightmap, if present."
          },
          {
            "name": "opaque_render_method",
            "type_path": "bevy_pbr::material::OpaqueRendererMethod",
            "docs": " Render method used for opaque materials. (Where `alpha_mode` is [`AlphaMode::Opaque`] or [`AlphaMode::Mask`])"
          },
          {
            "name": "deferred_lighting_pass_id",
            "type_path": "u8",
            "docs": " Used for selecting the deferred lighting pass for deferred materials.\n Default is [`DEFAULT_PBR_DEFERRED_LIGHTING_PASS_ID`] for default\n PBR deferred lighting pass. Ignored in the case of forward materials."
          },
          {
            "name": "uv_transform",
            "type_path": "glam::Affine2",
            "docs": " The transform applied to the UVs corresponding to `ATTRIBUTE_UV_0` on the mesh before sampling. Default is identity."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::pbr_material::StandardMaterial",
        "short_type_path": "StandardMaterial",
        "ident": "StandardMaterial",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::pbr_material"
      },
      "default": "{\"bevy_pbr::pbr_material::StandardMaterial\":{\"base_color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"base_color_channel\":\"Uv0\",\"base_color_texture\":null,\"emissive\":{\"red\":0.0,\"green\":0.0,\"blue\":0.0,\"alpha\":1.0},\"emissive_exposure_weight\":0.0,\"emissive_channel\":\"Uv0\",\"emissive_texture\":null,\"perceptual_roughness\":0.5,\"metallic\":0.0,\"metallic_roughness_channel\":\"Uv0\",\"metallic_roughness_texture\":null,\"reflectance\":0.5,\"diffuse_transmission\":0.0,\"specular_transmission\":0.0,\"thickness\":0.0,\"ior\":1.5,\"attenuation_distance\":null,\"attenuation_color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"normal_map_channel\":\"Uv0\",\"normal_map_texture\":null,\"flip_normal_map_y\":false,\"occlusion_channel\":\"Uv0\",\"occlusion_texture\":null,\"clearcoat\":0.0,\"clearcoat_perceptual_roughness\":0.5,\"anisotropy_strength\":0.0,\"anisotropy_rotation\":0.0,\"double_sided\":false,\"unlit\":false,\"fog_enabled\":true,\"alpha_mode\":\"Opaque\",\"depth_bias\":0.0,\"depth_map\":null,\"parallax_depth_scale\":0.1,\"parallax_mapping_method\":\"Occlusion\",\"max_parallax_layer_count\":16.0,\"lightmap_exposure\":1.0,\"opaque_render_method\":\"Auto\",\"deferred_lighting_pass_id\":1,\"uv_transform\":[1.0,0.0,0.0,1.0,0.0,0.0]}}",
      "docs": " A material with \"standard\" properties used in PBR lighting\n Standard property values with pictures here\n <https://google.github.io/filament/Material%20Properties.pdf>.\n\n May be created directly from a [`Color`] or an [`Image`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::primitives::CascadesFrusta": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_render::primitives::CascadesFrusta",
        "short_type_path": "CascadesFrusta",
        "ident": "CascadesFrusta",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::primitives"
      },
      "default": "{\"bevy_render::primitives::CascadesFrusta\":{}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_picking::backend::ray::RayId": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "camera",
            "type_path": "bevy_ecs::entity::Entity",
            "docs": " The camera whose projection was used to calculate the ray."
          },
          {
            "name": "pointer",
            "type_path": "bevy_picking::pointer::PointerId",
            "docs": " The pointer whose pixel coordinates were used to calculate the ray."
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::backend::ray::RayId",
        "short_type_path": "RayId",
        "ident": "RayId",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking::backend::ray"
      },
      "default": null,
      "docs": " Identifies a ray constructed from some (pointer, camera) combination. A pointer can be over\n multiple cameras, which is why a single pointer may have multiple rays.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::time::Time<bevy_time::virt::Virtual>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "context",
            "type_path": "bevy_time::virt::Virtual",
            "docs": null
          },
          {
            "name": "wrap_period",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "delta_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed_wrapped",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped_f64",
            "type_path": "f64",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::time::Time<bevy_time::virt::Virtual>",
        "short_type_path": "Time<Virtual>",
        "ident": "Time",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::time"
      },
      "default": "{\"bevy_time::time::Time<bevy_time::virt::Virtual>\":{\"context\":{\"max_delta\":{\"secs\":0,\"nanos\":250000000},\"paused\":false,\"relative_speed\":1.0,\"effective_speed\":1.0},\"wrap_period\":{\"secs\":3600,\"nanos\":0},\"delta\":{\"secs\":0,\"nanos\":0},\"delta_secs\":0.0,\"delta_secs_f64\":0.0,\"elapsed\":{\"secs\":0,\"nanos\":0},\"elapsed_secs\":0.0,\"elapsed_secs_f64\":0.0,\"elapsed_wrapped\":{\"secs\":0,\"nanos\":0},\"elapsed_secs_wrapped\":0.0,\"elapsed_secs_wrapped_f64\":0.0}}",
      "docs": " A generic clock resource that tracks how much it has advanced since its\n previous update and since its creation.\n\n Multiple instances of this resource are inserted automatically by\n [`TimePlugin`](crate::TimePlugin):\n\n - [`Time<Real>`](crate::real::Real) tracks real wall-clock time elapsed.\n - [`Time<Virtual>`](crate::virt::Virtual) tracks virtual game time that may\n   be paused or scaled.\n - [`Time<Fixed>`](crate::fixed::Fixed) tracks fixed timesteps based on\n   virtual time.\n - [`Time`] is a generic clock that corresponds to \"current\" or \"default\"\n   time for systems. It contains [`Time<Virtual>`](crate::virt::Virtual)\n   except inside the [`FixedMain`](bevy_app::FixedMain) schedule when it\n   contains [`Time<Fixed>`](crate::fixed::Fixed).\n\n The time elapsed since the previous time this clock was advanced is saved as\n [`delta()`](Time::delta) and the total amount of time the clock has advanced\n is saved as [`elapsed()`](Time::elapsed). Both are represented as exact\n [`Duration`] values with fixed nanosecond precision. The clock does not\n support time moving backwards, but it can be updated with [`Duration::ZERO`]\n which will set [`delta()`](Time::delta) to zero.\n\n These values are also available in seconds as `f32` via\n [`delta_secs()`](Time::delta_secs) and\n [`elapsed_secs()`](Time::elapsed_secs), and also in seconds as `f64`\n via [`delta_secs_f64()`](Time::delta_secs_f64) and\n [`elapsed_secs_f64()`](Time::elapsed_secs_f64).\n\n Since [`elapsed_secs()`](Time::elapsed_secs) will grow constantly and\n is `f32`, it will exhibit gradual precision loss. For applications that\n require an `f32` value but suffer from gradual precision loss there is\n [`elapsed_secs_wrapped()`](Time::elapsed_secs_wrapped) available. The\n same wrapped value is also available as [`Duration`] and `f64` for\n consistency. The wrap period is by default 1 hour, and can be set by\n [`set_wrap_period()`](Time::set_wrap_period).\n\n # Accessing clocks\n\n By default, any systems requiring current [`delta()`](Time::delta) or\n [`elapsed()`](Time::elapsed) should use `Res<Time>` to access the default\n time configured for the program. By default, this refers to\n [`Time<Virtual>`](crate::virt::Virtual) except during the\n [`FixedMain`](bevy_app::FixedMain) schedule when it refers to\n [`Time<Fixed>`](crate::fixed::Fixed). This ensures your system can be used\n either in [`Update`](bevy_app::Update) or\n [`FixedUpdate`](bevy_app::FixedUpdate) schedule depending on what is needed.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn ambivalent_system(time: Res<Time>) {\n     println!(\"this how I see time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system needs to react based on real time (wall clock time), like for\n user interfaces, it should use `Res<Time<Real>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will always\n correspond to real time and will not be affected by pause, time scaling or\n other tweaks.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn real_time_system(time: Res<Time<Real>>) {\n     println!(\"this will always be real time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system specifically needs to access fixed timestep clock, even when\n placed in `Update` schedule, you should use `Res<Time<Fixed>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will\n correspond to the latest fixed timestep that has been run.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Fixed>>) {\n     println!(\"this will always be the last executed fixed timestep: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n Finally, if your system specifically needs to know the current virtual game\n time, even if placed inside [`FixedUpdate`](bevy_app::FixedUpdate), for\n example to know if the game is [`was_paused()`](Time::was_paused) or to use\n [`effective_speed()`](Time::effective_speed), you can use\n `Res<Time<Virtual>>`. However, if the system is placed in\n [`FixedUpdate`](bevy_app::FixedUpdate), extra care must be used because your\n system might be run multiple times with the same [`delta()`](Time::delta)\n and [`elapsed()`](Time::elapsed) values as the virtual game time has not\n changed between the iterations.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Virtual>>) {\n     println!(\"this will be virtual time for this update: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n     println!(\"also the relative speed of the game is now {}\", time.effective_speed());\n }\n ```\n\n If you need to change the settings for any of the clocks, for example to\n [`pause()`](Time::pause) the game, you should use `ResMut<Time<Virtual>>`.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n #[derive(Event)]\n struct PauseEvent(bool);\n\n fn pause_system(mut time: ResMut<Time<Virtual>>, mut events: EventReader<PauseEvent>) {\n     for ev in events.read() {\n         if ev.0 {\n             time.pause();\n         } else {\n             time.unpause();\n         }\n     }\n }\n ```\n\n # Adding custom clocks\n\n New custom clocks can be created by creating your own struct as a context\n and passing it to [`new_with()`](Time::new_with). These clocks can be\n inserted as resources as normal and then accessed by systems. You can use\n the [`advance_by()`](Time::advance_by) or [`advance_to()`](Time::advance_to)\n methods to move the clock forwards based on your own logic.\n\n If you want to add methods for your time instance and they require access to\n both your context and the generic time part, it's probably simplest to add a\n custom trait for them and implement it for `Time<Custom>`.\n\n Your context struct will need to implement the [`Default`] trait because\n [`Time`] structures support reflection. It also makes initialization trivial\n by being able to call `app.init_resource::<Time<Custom>>()`.\n\n You can also replace the \"generic\" `Time` clock resource if the \"default\"\n time for your game should not be the default virtual time provided. You can\n get a \"generic\" snapshot of your clock by calling `as_generic()` and then\n overwrite the [`Time`] resource with it. The default systems added by\n [`TimePlugin`](crate::TimePlugin) will overwrite the [`Time`] clock during\n [`First`](bevy_app::First) and [`FixedUpdate`](bevy_app::FixedUpdate)\n schedules.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n # use bevy_utils::Instant;\n #\n #[derive(Debug)]\n struct Custom {\n     last_external_time: Instant,\n }\n\n impl Default for Custom {\n     fn default() -> Self {\n         Self {\n             last_external_time: Instant::now(),\n         }\n     }\n }\n\n trait CustomTime {\n     fn update_from_external(&mut self, instant: Instant);\n }\n\n impl CustomTime for Time<Custom> {\n     fn update_from_external(&mut self, instant: Instant) {\n          let delta = instant - self.context().last_external_time;\n          self.advance_by(delta);\n          self.context_mut().last_external_time = instant;\n     }\n }\n ```",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "alloc::vec::Vec<bevy_ui::ui_node::RepeatedGridTrack>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_ui::ui_node::RepeatedGridTrack"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_ui::ui_node::RepeatedGridTrack>",
        "short_type_path": "Vec<RepeatedGridTrack>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::ComputedNode": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "stack_index",
            "type_path": "u32",
            "docs": " The order of the node in the UI layout.\n Nodes with a higher stack index are drawn on top of and receive interactions before nodes with lower stack indices."
          },
          {
            "name": "size",
            "type_path": "glam::Vec2",
            "docs": " The size of the node as width and height in physical pixels\n\n automatically calculated by [`super::layout::ui_layout_system`]"
          },
          {
            "name": "outline_width",
            "type_path": "f32",
            "docs": " The width of this node's outline.\n If this value is `Auto`, negative or `0.` then no outline will be rendered.\n Outline updates bypass change detection.\n\n Automatically calculated by [`super::layout::ui_layout_system`]."
          },
          {
            "name": "outline_offset",
            "type_path": "f32",
            "docs": " The amount of space between the outline and the edge of the node.\n Outline updates bypass change detection.\n\n Automatically calculated by [`super::layout::ui_layout_system`]."
          },
          {
            "name": "unrounded_size",
            "type_path": "glam::Vec2",
            "docs": " The unrounded size of the node as width and height in physical pixels.\n\n Automatically calculated by [`super::layout::ui_layout_system`]."
          },
          {
            "name": "border",
            "type_path": "bevy_sprite::texture_slice::border_rect::BorderRect",
            "docs": " Resolved border values in physical pixels\n Border updates bypass change detection.\n\n Automatically calculated by [`super::layout::ui_layout_system`]."
          },
          {
            "name": "border_radius",
            "type_path": "bevy_ui::ui_node::ResolvedBorderRadius",
            "docs": " Resolved border radius values in physical pixels.\n Border radius updates bypass change detection.\n\n Automatically calculated by [`super::layout::ui_layout_system`]."
          },
          {
            "name": "padding",
            "type_path": "bevy_sprite::texture_slice::border_rect::BorderRect",
            "docs": " Resolved padding values in physical pixels\n Padding updates bypass change detection.\n\n Automatically calculated by [`super::layout::ui_layout_system`]."
          },
          {
            "name": "inverse_scale_factor",
            "type_path": "f32",
            "docs": " Inverse scale factor for this Node.\n Multiply physical coordinates by the inverse scale factor to give logical coordinates.\n\n Automatically calculated by [`super::layout::ui_layout_system`]."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::ComputedNode",
        "short_type_path": "ComputedNode",
        "ident": "ComputedNode",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::ComputedNode\":{\"stack_index\":0,\"size\":[0.0,0.0],\"outline_width\":0.0,\"outline_offset\":0.0,\"unrounded_size\":[0.0,0.0],\"border\":{\"left\":0.0,\"right\":0.0,\"top\":0.0,\"bottom\":0.0},\"border_radius\":{\"top_left\":0.0,\"top_right\":0.0,\"bottom_left\":0.0,\"bottom_right\":0.0},\"padding\":{\"left\":0.0,\"right\":0.0,\"top\":0.0,\"bottom\":0.0},\"inverse_scale_factor\":1.0}}",
      "docs": " Provides the computed size and layout properties of the node.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "u32": {
      "info": {
        "kind": "opaque",
        "item_type_path": "u32"
      },
      "path_table": {
        "path": "u32",
        "short_type_path": "u32",
        "ident": "u32",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"u32\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::text::LineBreak": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "WordBoundary",
            "docs": " Uses the [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/).\n Lines will be broken up at the nearest suitable word boundary, usually a space.\n This behavior suits most cases, as it keeps words intact across linebreaks."
          },
          {
            "kind": "unit",
            "name": "AnyCharacter",
            "docs": " Lines will be broken without discrimination on any character that would leave bounds.\n This is closer to the behavior one might expect from text in a terminal.\n However it may lead to words being broken up across linebreaks."
          },
          {
            "kind": "unit",
            "name": "WordOrCharacter",
            "docs": " Wraps at the word level, or fallback to character level if a word can’t fit on a line by itself"
          },
          {
            "kind": "unit",
            "name": "NoWrap",
            "docs": " No soft wrapping, where text is automatically broken up into separate lines when it overflows a boundary, will ever occur.\n Hard wrapping, where text contains an explicit linebreak such as the escape sequence `\\n`, is still enabled."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::LineBreak",
        "short_type_path": "LineBreak",
        "ident": "LineBreak",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": null,
      "docs": " Determines how lines will be broken when preventing text from running out of bounds.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<()>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<()>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<()>",
        "short_type_path": "Handle<()>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<()>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::light::ShadowFilteringMethod": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Hardware2x2",
            "docs": " Hardware 2x2.\n\n Fast but poor quality."
          },
          {
            "kind": "unit",
            "name": "Gaussian",
            "docs": " Approximates a fixed Gaussian blur, good when TAA isn't in use.\n\n Good quality, good performance.\n\n For directional and spot lights, this uses a [method by Ignacio Castaño\n for *The Witness*] using 9 samples and smart filtering to achieve the same\n as a regular 5x5 filter kernel.\n\n [method by Ignacio Castaño for *The Witness*]: https://web.archive.org/web/20230210095515/http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/"
          },
          {
            "kind": "unit",
            "name": "Temporal",
            "docs": " A randomized filter that varies over time, good when TAA is in use.\n\n Good quality when used with\n [`TemporalAntiAliasing`](bevy_core_pipeline::experimental::taa::TemporalAntiAliasing)\n and good performance.\n\n For directional and spot lights, this uses a [method by Jorge Jimenez for\n *Call of Duty: Advanced Warfare*] using 8 samples in spiral pattern,\n randomly-rotated by interleaved gradient noise with spatial variation.\n\n [method by Jorge Jimenez for *Call of Duty: Advanced Warfare*]: https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/"
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::ShadowFilteringMethod",
        "short_type_path": "ShadowFilteringMethod",
        "ident": "ShadowFilteringMethod",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": "{\"bevy_pbr::light::ShadowFilteringMethod\":\"Gaussian\"}",
      "docs": " Add this component to a [`Camera3d`](bevy_core_pipeline::core_3d::Camera3d)\n to control how to anti-alias shadow edges.\n\n The different modes use different approaches to\n [Percentage Closer Filtering](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_audio::pitch::Pitch>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_audio::pitch::Pitch>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_audio::pitch::Pitch>",
        "short_type_path": "Handle<Pitch>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_audio::pitch::Pitch>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<bevy_color::color::Color>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::color::Color",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_color::color::Color>",
        "short_type_path": "Option<Color>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_mesh::mesh::Mesh>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_mesh::mesh::Mesh>",
        "short_type_path": "AssetId<Mesh>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<core::ops::Range<u32>>": {
      "info": {
        "kind": "list",
        "item_type_path": "core::ops::Range<u32>"
      },
      "path_table": {
        "path": "alloc::vec::Vec<core::ops::Range<u32>>",
        "short_type_path": "Vec<Range<u32>>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::dof::DepthOfFieldMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Bokeh",
            "docs": " A more accurate simulation, in which circles of confusion generate\n \"spots\" of light.\n\n For more information, see [Wikipedia's article on *bokeh*].\n\n This doesn't work on WebGPU.\n\n [Wikipedia's article on *bokeh*]: https://en.wikipedia.org/wiki/Bokeh"
          },
          {
            "kind": "unit",
            "name": "Gaussian",
            "docs": " A faster simulation, in which out-of-focus areas are simply blurred.\n\n This is less accurate to actual lens behavior and is generally less\n aesthetically pleasing but requires less video memory bandwidth.\n\n This is the default.\n\n This works on native and WebGPU.\n If targeting native platforms, consider using [`DepthOfFieldMode::Bokeh`] instead."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::dof::DepthOfFieldMode",
        "short_type_path": "DepthOfFieldMode",
        "ident": "DepthOfFieldMode",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::dof"
      },
      "default": "{\"bevy_core_pipeline::dof::DepthOfFieldMode\":\"Gaussian\"}",
      "docs": " Controls the appearance of the effect.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::storage::ShaderStorageBuffer": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_render::storage::ShaderStorageBuffer"
      },
      "path_table": {
        "path": "bevy_render::storage::ShaderStorageBuffer",
        "short_type_path": "ShaderStorageBuffer",
        "ident": "ShaderStorageBuffer",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::storage"
      },
      "default": null,
      "docs": " A storage buffer that is prepared as a [`RenderAsset`] and uploaded to the GPU.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::bloom::settings::Bloom": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "intensity",
            "type_path": "f32",
            "docs": " Controls the baseline of how much the image is scattered (default: 0.15).\n\n This parameter should be used only to control the strength of the bloom\n for the scene as a whole. Increasing it too much will make the scene appear\n blurry and over-exposed.\n\n To make a mesh glow brighter, rather than increase the bloom intensity,\n you should increase the mesh's `emissive` value.\n\n # In energy-conserving mode\n The value represents how likely the light is to scatter.\n\n The value should be between 0.0 and 1.0 where:\n * 0.0 means no bloom\n * 1.0 means the light is scattered as much as possible\n\n # In additive mode\n The value represents how much scattered light is added to\n the image to create the glow effect.\n\n In this configuration:\n * 0.0 means no bloom\n * Greater than 0.0 means a proportionate amount of scattered light is added"
          },
          {
            "name": "low_frequency_boost",
            "type_path": "f32",
            "docs": " Low frequency contribution boost.\n Controls how much more likely the light\n is to scatter completely sideways (low frequency image).\n\n Comparable to a low shelf boost on an equalizer.\n\n # In energy-conserving mode\n The value should be between 0.0 and 1.0 where:\n * 0.0 means low frequency light uses base intensity for blend factor calculation\n * 1.0 means low frequency light contributes at full power\n\n # In additive mode\n The value represents how much scattered light is added to\n the image to create the glow effect.\n\n In this configuration:\n * 0.0 means no bloom\n * Greater than 0.0 means a proportionate amount of scattered light is added"
          },
          {
            "name": "low_frequency_boost_curvature",
            "type_path": "f32",
            "docs": " Low frequency contribution boost curve.\n Controls the curvature of the blend factor function\n making frequencies next to the lowest ones contribute more.\n\n Somewhat comparable to the Q factor of an equalizer node.\n\n Valid range:\n * 0.0 - base intensity and boosted intensity are linearly interpolated\n * 1.0 - all frequencies below maximum are at boosted intensity level"
          },
          {
            "name": "high_pass_frequency",
            "type_path": "f32",
            "docs": " Tightens how much the light scatters (default: 1.0).\n\n Valid range:\n * 0.0 - maximum scattering angle is 0 degrees (no scattering)\n * 1.0 - maximum scattering angle is 90 degrees"
          },
          {
            "name": "prefilter",
            "type_path": "bevy_core_pipeline::bloom::settings::BloomPrefilter",
            "docs": " Controls the threshold filter used for extracting the brightest regions from the input image\n before blurring them and compositing back onto the original image.\n\n Changing these settings creates a physically inaccurate image and makes it easy to make\n the final result look worse. However, they can be useful when emulating the 1990s-2000s game look.\n See [`BloomPrefilter`] for more information."
          },
          {
            "name": "composite_mode",
            "type_path": "bevy_core_pipeline::bloom::settings::BloomCompositeMode",
            "docs": " Controls whether bloom textures\n are blended between or added to each other. Useful\n if image brightening is desired and a must-change\n if `prefilter` is used.\n\n # Recommendation\n Set to [`BloomCompositeMode::Additive`] if `prefilter` is\n configured in a non-energy-conserving way,\n otherwise set to [`BloomCompositeMode::EnergyConserving`]."
          },
          {
            "name": "max_mip_dimension",
            "type_path": "u32",
            "docs": " Maximum size of each dimension for the largest mipchain texture used in downscaling/upscaling.\n Only tweak if you are seeing visual artifacts."
          },
          {
            "name": "uv_offset",
            "type_path": "f32",
            "docs": " UV offset for bloom shader. Ideally close to 2.0 / `max_mip_dimension`.\n Only tweak if you are seeing visual artifacts."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::bloom::settings::Bloom",
        "short_type_path": "Bloom",
        "ident": "Bloom",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::bloom::settings"
      },
      "default": "{\"bevy_core_pipeline::bloom::settings::Bloom\":{\"intensity\":0.15,\"low_frequency_boost\":0.7,\"low_frequency_boost_curvature\":0.95,\"high_pass_frequency\":1.0,\"prefilter\":{\"threshold\":0.0,\"threshold_softness\":0.0},\"composite_mode\":\"EnergyConserving\",\"max_mip_dimension\":512,\"uv_offset\":0.004}}",
      "docs": " Applies a bloom effect to an HDR-enabled 2d or 3d camera.\n\n Bloom emulates an effect found in real cameras and the human eye,\n causing halos to appear around very bright parts of the scene.\n\n See also <https://en.wikipedia.org/wiki/Bloom_(shader_effect)>.\n\n # Usage Notes\n\n **Bloom is currently not compatible with WebGL2.**\n\n Often used in conjunction with `bevy_pbr::StandardMaterial::emissive` for 3d meshes.\n\n Bloom is best used alongside a tonemapping function that desaturates bright colors,\n such as [`crate::tonemapping::Tonemapping::TonyMcMapface`].\n\n Bevy's implementation uses a parametric curve to blend between a set of\n blurred (lower frequency) images generated from the camera's view.\n See <https://starlederer.github.io/bloom/> for a visualization of the parametric curve\n used in Bevy as well as a visualization of the curve's respective scattering profile.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::widget::button::Button": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_ui::widget::button::Button",
        "short_type_path": "Button",
        "ident": "Button",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::widget::button"
      },
      "default": "{\"bevy_ui::widget::button::Button\":{}}",
      "docs": " Marker struct for buttons",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_core_pipeline::prepass::NormalPrepass": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_core_pipeline::prepass::NormalPrepass",
        "short_type_path": "NormalPrepass",
        "ident": "NormalPrepass",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::prepass"
      },
      "default": "{\"bevy_core_pipeline::prepass::NormalPrepass\":{}}",
      "docs": " If added to a [`crate::prelude::Camera3d`] then vertex world normals will be copied to a separate texture available to the main pass.\n Normals will have normal map textures already applied.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_core_pipeline::prepass::DepthPrepass": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_core_pipeline::prepass::DepthPrepass",
        "short_type_path": "DepthPrepass",
        "ident": "DepthPrepass",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::prepass"
      },
      "default": "{\"bevy_core_pipeline::prepass::DepthPrepass\":{}}",
      "docs": " If added to a [`crate::prelude::Camera3d`] then depth values will be copied to a separate texture available to the main pass.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevy_math::rects::urect::URect>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_math::rects::urect::URect"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_math::rects::urect::URect>",
        "short_type_path": "Vec<URect>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::camera::MipBias": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::camera::MipBias",
        "short_type_path": "MipBias",
        "ident": "MipBias",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": "{\"bevy_render::camera::camera::MipBias\":0.0}",
      "docs": " Camera component specifying a mip bias to apply when sampling from material textures.\n\n Often used in conjunction with antialiasing post-process effects to reduce textures blurriness.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "glam::Mat3A": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x_axis",
            "type_path": "glam::Vec3A",
            "docs": null
          },
          {
            "name": "y_axis",
            "type_path": "glam::Vec3A",
            "docs": null
          },
          {
            "name": "z_axis",
            "type_path": "glam::Vec3A",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Mat3A",
        "short_type_path": "Mat3A",
        "ident": "Mat3A",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Mat3A\":[1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::UVec3": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "u32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "u32",
            "docs": null
          },
          {
            "name": "z",
            "type_path": "u32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::UVec3",
        "short_type_path": "UVec3",
        "ident": "UVec3",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::UVec3\":[0,0,0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::BackgroundColor": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_color::color::Color",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::BackgroundColor",
        "short_type_path": "BackgroundColor",
        "ident": "BackgroundColor",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::BackgroundColor\":{\"LinearRgba\":{\"red\":0.0,\"green\":0.0,\"blue\":0.0,\"alpha\":0.0}}}",
      "docs": " The background color of the node\n\n This serves as the \"fill\" color.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_mesh::index::Indices": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "U16",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::vec::Vec<u16>",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "U32",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::vec::Vec<u32>",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_mesh::index::Indices",
        "short_type_path": "Indices",
        "ident": "Indices",
        "crate_name": "bevy_mesh",
        "module_path": "bevy_mesh::index"
      },
      "default": null,
      "docs": " An array of indices into the [`VertexAttributeValues`](super::VertexAttributeValues) for a mesh.\n\n It describes the order in which the vertex attributes should be joined into faces.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::camera::RenderTarget": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Window",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_window::window::WindowRef",
                "docs": null
              }
            ],
            "docs": " Window to which the camera's view is rendered."
          },
          {
            "kind": "tuple",
            "name": "Image",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
                "docs": null
              }
            ],
            "docs": " Image to which the camera's view is rendered."
          },
          {
            "kind": "tuple",
            "name": "TextureView",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_render::camera::manual_texture_view::ManualTextureViewHandle",
                "docs": null
              }
            ],
            "docs": " Texture View to which the camera's view is rendered.\n Useful when the texture view needs to be created outside of Bevy, for example OpenXR."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::camera::RenderTarget",
        "short_type_path": "RenderTarget",
        "ident": "RenderTarget",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": null,
      "docs": " The \"target\" that a [`Camera`] will render to. For example, this could be a [`Window`]\n swapchain or an [`Image`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::geometry::UiRect": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "left",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The value corresponding to the left side of the UI rect."
          },
          {
            "name": "right",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The value corresponding to the right side of the UI rect."
          },
          {
            "name": "top",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The value corresponding to the top side of the UI rect."
          },
          {
            "name": "bottom",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The value corresponding to the bottom side of the UI rect."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::geometry::UiRect",
        "short_type_path": "UiRect",
        "ident": "UiRect",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::geometry"
      },
      "default": "{\"bevy_ui::geometry::UiRect\":{\"left\":{\"Px\":0.0},\"right\":{\"Px\":0.0},\"top\":{\"Px\":0.0},\"bottom\":{\"Px\":0.0}}}",
      "docs": " A type which is commonly used to define margins, paddings and borders.\n\n # Examples\n\n ## Margin\n\n A margin is used to create space around UI elements, outside of any defined borders.\n\n ```\n # use bevy_ui::{UiRect, Val};\n #\n let margin = UiRect::all(Val::Auto); // Centers the UI element\n ```\n\n ## Padding\n\n A padding is used to create space around UI elements, inside of any defined borders.\n\n ```\n # use bevy_ui::{UiRect, Val};\n #\n let padding = UiRect {\n     left: Val::Px(10.0),\n     right: Val::Px(20.0),\n     top: Val::Px(30.0),\n     bottom: Val::Px(40.0),\n };\n ```\n\n ## Borders\n\n A border is used to define the width of the border of a UI element.\n\n ```\n # use bevy_ui::{UiRect, Val};\n #\n let border = UiRect {\n     left: Val::Px(10.0),\n     right: Val::Px(20.0),\n     top: Val::Px(30.0),\n     bottom: Val::Px(40.0),\n };\n ```",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::camera::Camera": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "viewport",
            "type_path": "core::option::Option<bevy_render::camera::camera::Viewport>",
            "docs": " If set, this camera will render to the given [`Viewport`] rectangle within the configured [`RenderTarget`]."
          },
          {
            "name": "order",
            "type_path": "isize",
            "docs": " Cameras with a higher order are rendered later, and thus on top of lower order cameras."
          },
          {
            "name": "is_active",
            "type_path": "bool",
            "docs": " If this is set to `true`, this camera will be rendered to its specified [`RenderTarget`]. If `false`, this\n camera will not be rendered."
          },
          {
            "name": "target",
            "type_path": "bevy_render::camera::camera::RenderTarget",
            "docs": " The \"target\" that this camera will render to."
          },
          {
            "name": "hdr",
            "type_path": "bool",
            "docs": " If this is set to `true`, the camera will use an intermediate \"high dynamic range\" render texture.\n This allows rendering with a wider range of lighting values."
          },
          {
            "name": "msaa_writeback",
            "type_path": "bool",
            "docs": " If this is enabled, a previous camera exists that shares this camera's render target, and this camera has MSAA enabled, then the previous camera's\n outputs will be written to the intermediate multi-sampled render target textures for this camera. This enables cameras with MSAA enabled to\n \"write their results on top\" of previous camera results, and include them as a part of their render results. This is enabled by default to ensure\n cameras with MSAA enabled layer their results in the same way as cameras without MSAA enabled by default."
          },
          {
            "name": "clear_color",
            "type_path": "bevy_render::camera::clear_color::ClearColorConfig",
            "docs": " The clear color operation to perform on the render target."
          },
          {
            "name": "sub_camera_view",
            "type_path": "core::option::Option<bevy_render::camera::camera::SubCameraView>",
            "docs": " If set, this camera will be a sub camera of a large view, defined by a [`SubCameraView`]."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::camera::Camera",
        "short_type_path": "Camera",
        "ident": "Camera",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": "{\"bevy_render::camera::camera::Camera\":{\"viewport\":null,\"order\":0,\"is_active\":true,\"target\":{\"Window\":\"Primary\"},\"hdr\":false,\"msaa_writeback\":true,\"clear_color\":\"Default\",\"sub_camera_view\":null}}",
      "docs": " The defining [`Component`] for camera entities,\n storing information about how and what to render through this camera.\n\n The [`Camera`] component is added to an entity to define the properties of the viewpoint from\n which rendering occurs. It defines the position of the view to render, the projection method\n to transform the 3D objects into a 2D image, as well as the render target into which that image\n is produced.\n\n Note that a [`Camera`] needs a [`CameraRenderGraph`] to render anything.\n This is typically provided by adding a [`Camera2d`] or [`Camera3d`] component,\n but custom render graphs can also be defined. Inserting a [`Camera`] with no render\n graph will emit an error at runtime.\n\n [`Camera2d`]: https://docs.rs/crate/bevy_core_pipeline/latest/core_2d/struct.Camera2d.html\n [`Camera3d`]: https://docs.rs/crate/bevy_core_pipeline/latest/core_3d/struct.Camera3d.html",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_audio::audio::Volume": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_audio::audio::Volume",
        "short_type_path": "Volume",
        "ident": "Volume",
        "crate_name": "bevy_audio",
        "module_path": "bevy_audio::audio"
      },
      "default": null,
      "docs": " A volume level equivalent to a non-negative float.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::Mat4": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x_axis",
            "type_path": "glam::Vec4",
            "docs": null
          },
          {
            "name": "y_axis",
            "type_path": "glam::Vec4",
            "docs": null
          },
          {
            "name": "z_axis",
            "type_path": "glam::Vec4",
            "docs": null
          },
          {
            "name": "w_axis",
            "type_path": "glam::Vec4",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Mat4",
        "short_type_path": "Mat4",
        "ident": "Mat4",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Mat4\":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_render::render_resource::shader::Shader>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_render::render_resource::shader::Shader>",
        "short_type_path": "AssetId<Shader>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::oklcha::Oklcha": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "lightness",
            "type_path": "f32",
            "docs": " The 'lightness' channel. [0.0, 1.0]"
          },
          {
            "name": "chroma",
            "type_path": "f32",
            "docs": " The 'chroma' channel. [0.0, 1.0]"
          },
          {
            "name": "hue",
            "type_path": "f32",
            "docs": " The 'hue' channel. [0.0, 360.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::oklcha::Oklcha",
        "short_type_path": "Oklcha",
        "ident": "Oklcha",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::oklcha"
      },
      "default": "{\"bevy_color::oklcha::Oklcha\":{\"lightness\":1.0,\"chroma\":0.0,\"hue\":0.0,\"alpha\":1.0}}",
      "docs": " Color in Oklch color space, with alpha\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::linear_rgba::LinearRgba": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "red",
            "type_path": "f32",
            "docs": " The red channel. [0.0, 1.0]"
          },
          {
            "name": "green",
            "type_path": "f32",
            "docs": " The green channel. [0.0, 1.0]"
          },
          {
            "name": "blue",
            "type_path": "f32",
            "docs": " The blue channel. [0.0, 1.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::linear_rgba::LinearRgba",
        "short_type_path": "LinearRgba",
        "ident": "LinearRgba",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::linear_rgba"
      },
      "default": "{\"bevy_color::linear_rgba::LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}}",
      "docs": " Linear RGB color with alpha.\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_audio::audio::PlaybackSettings": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "mode",
            "type_path": "bevy_audio::audio::PlaybackMode",
            "docs": " The desired playback behavior."
          },
          {
            "name": "volume",
            "type_path": "bevy_audio::audio::Volume",
            "docs": " Volume to play at."
          },
          {
            "name": "speed",
            "type_path": "f32",
            "docs": " Speed to play at."
          },
          {
            "name": "paused",
            "type_path": "bool",
            "docs": " Create the sink in paused state.\n Useful for \"deferred playback\", if you want to prepare\n the entity, but hear the sound later."
          },
          {
            "name": "spatial",
            "type_path": "bool",
            "docs": " Enables spatial audio for this source.\n\n See also: [`SpatialListener`].\n\n Note: Bevy does not currently support HRTF or any other high-quality 3D sound rendering\n features. Spatial audio is implemented via simple left-right stereo panning."
          },
          {
            "name": "spatial_scale",
            "type_path": "core::option::Option<bevy_audio::audio::SpatialScale>",
            "docs": " Optional scale factor applied to the positions of this audio source and the listener,\n overriding the default value configured on [`AudioPlugin::default_spatial_scale`](crate::AudioPlugin::default_spatial_scale)."
          }
        ]
      },
      "path_table": {
        "path": "bevy_audio::audio::PlaybackSettings",
        "short_type_path": "PlaybackSettings",
        "ident": "PlaybackSettings",
        "crate_name": "bevy_audio",
        "module_path": "bevy_audio::audio"
      },
      "default": "{\"bevy_audio::audio::PlaybackSettings\":{\"mode\":\"Once\",\"volume\":1.0,\"speed\":1.0,\"paused\":false,\"spatial\":false,\"spatial_scale\":null}}",
      "docs": " Initial settings to be used when audio starts playing.\n\n If you would like to control the audio while it is playing, query for the\n [`AudioSink`][crate::AudioSink] or [`SpatialAudioSink`][crate::SpatialAudioSink]\n components. Changes to this component will *not* be applied to already-playing audio.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_core_pipeline::core_3d::camera_3d::Camera3dDepthTextureUsage": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "u32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::core_3d::camera_3d::Camera3dDepthTextureUsage",
        "short_type_path": "Camera3dDepthTextureUsage",
        "ident": "Camera3dDepthTextureUsage",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::core_3d::camera_3d"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::Quat": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "z",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "w",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Quat",
        "short_type_path": "Quat",
        "ident": "Quat",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Quat\":[0.0,0.0,0.0,1.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::oit::OrderIndependentTransparencySettings": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "layer_count",
            "type_path": "i32",
            "docs": " Controls how many layers will be used to compute the blending.\n The more layers you use the more memory it will use but it will also give better results.\n 8 is generally recommended, going above 32 is probably not worth it in the vast majority of cases"
          },
          {
            "name": "alpha_threshold",
            "type_path": "f32",
            "docs": " Threshold for which fragments will be added to the blending layers.\n This can be tweaked to optimize quality / layers count. Higher values will\n allow lower number of layers and a better performance, compromising quality."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::oit::OrderIndependentTransparencySettings",
        "short_type_path": "OrderIndependentTransparencySettings",
        "ident": "OrderIndependentTransparencySettings",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::oit"
      },
      "default": null,
      "docs": " Used to identify which camera will use OIT to render transparent meshes\n and to configure OIT.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::cluster::ClusterZConfig": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "first_slice_depth",
            "type_path": "f32",
            "docs": " Far `Z` plane of the first depth slice"
          },
          {
            "name": "far_z_mode",
            "type_path": "bevy_pbr::cluster::ClusterFarZMode",
            "docs": " Strategy for how to evaluate the far `Z` plane of the furthest depth slice"
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::cluster::ClusterZConfig",
        "short_type_path": "ClusterZConfig",
        "ident": "ClusterZConfig",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::cluster"
      },
      "default": "{\"bevy_pbr::cluster::ClusterZConfig\":{\"first_slice_depth\":5.0,\"far_z_mode\":\"MaxClusterableObjectRange\"}}",
      "docs": " Configure the depth-slicing strategy for clustered forward rendering",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_mesh::skinning::SkinnedMesh": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "inverse_bindposes",
            "type_path": "bevy_asset::handle::Handle<bevy_mesh::skinning::SkinnedMeshInverseBindposes>",
            "docs": null
          },
          {
            "name": "joints",
            "type_path": "alloc::vec::Vec<bevy_ecs::entity::Entity>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_mesh::skinning::SkinnedMesh",
        "short_type_path": "SkinnedMesh",
        "ident": "SkinnedMesh",
        "crate_name": "bevy_mesh",
        "module_path": "bevy_mesh::skinning"
      },
      "default": "{\"bevy_mesh::skinning::SkinnedMesh\":{\"inverse_bindposes\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}},\"joints\":[]}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::camera::projection::Projection": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Perspective",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_render::camera::projection::PerspectiveProjection",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Orthographic",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_render::camera::projection::OrthographicProjection",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::projection::Projection",
        "short_type_path": "Projection",
        "ident": "Projection",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::projection"
      },
      "default": "{\"bevy_render::camera::projection::Projection\":{\"Perspective\":{\"fov\":0.7853982,\"aspect_ratio\":1.0,\"near\":0.1,\"far\":1000.0}}}",
      "docs": " A configurable [`CameraProjection`] that can select its projection type at runtime.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::JustifyItems": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Default",
            "docs": " The items are packed in their default position as if no alignment was applied."
          },
          {
            "kind": "unit",
            "name": "Start",
            "docs": " The items are packed towards the start of the axis."
          },
          {
            "kind": "unit",
            "name": "End",
            "docs": " The items are packed towards the end of the axis."
          },
          {
            "kind": "unit",
            "name": "Center",
            "docs": " The items are packed along the center of the axis"
          },
          {
            "kind": "unit",
            "name": "Baseline",
            "docs": " The items are packed such that their baselines align."
          },
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " The items are stretched to fill the space they're given."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::JustifyItems",
        "short_type_path": "JustifyItems",
        "ident": "JustifyItems",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::JustifyItems\":\"Default\"}",
      "docs": " Used to control how each individual item is aligned by default within the space they're given.\n - For Flexbox containers, this property has no effect. See `justify_content` for main axis alignment of flex items.\n - For CSS Grid containers, sets default inline (horizontal) axis alignment of child items within their grid areas.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevy_ecs::entity::Entity>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_ecs::entity::Entity"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_ecs::entity::Entity>",
        "short_type_path": "Vec<Entity>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_audio::audio::SpatialScale": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "glam::Vec3",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_audio::audio::SpatialScale",
        "short_type_path": "SpatialScale",
        "ident": "SpatialScale",
        "crate_name": "bevy_audio",
        "module_path": "bevy_audio::audio"
      },
      "default": null,
      "docs": " A scale factor applied to the positions of audio sources and listeners for\n spatial audio.\n\n Default is `Vec3::ONE`.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gltf::GltfSceneExtras": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "value",
            "type_path": "alloc::string::String",
            "docs": " Content of the extra data."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gltf::GltfSceneExtras",
        "short_type_path": "GltfSceneExtras",
        "ident": "GltfSceneExtras",
        "crate_name": "bevy_gltf",
        "module_path": "bevy_gltf"
      },
      "default": "{\"bevy_gltf::GltfSceneExtras\":{\"value\":\"\"}}",
      "docs": " Additional untyped data that can be present on most glTF types at the scene level.\n\n See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::measurement::ContentSize": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_ui::measurement::ContentSize",
        "short_type_path": "ContentSize",
        "ident": "ContentSize",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::measurement"
      },
      "default": "{\"bevy_ui::measurement::ContentSize\":{}}",
      "docs": " A node with a `ContentSize` component is a node where its size\n is based on its content.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_math::rects::rect::Rect": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "min",
            "type_path": "glam::Vec2",
            "docs": " The minimum corner point of the rect."
          },
          {
            "name": "max",
            "type_path": "glam::Vec2",
            "docs": " The maximum corner point of the rect."
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::rects::rect::Rect",
        "short_type_path": "Rect",
        "ident": "Rect",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::rects::rect"
      },
      "default": "{\"bevy_math::rects::rect::Rect\":{\"min\":[0.0,0.0],\"max\":[0.0,0.0]}}",
      "docs": " A rectangle defined by two opposite corners.\n\n The rectangle is axis aligned, and defined by its minimum and maximum coordinates,\n stored in `Rect::min` and `Rect::max`, respectively. The minimum/maximum invariant\n must be upheld by the user when directly assigning the fields, otherwise some methods\n produce invalid results. It is generally recommended to use one of the constructor\n methods instead, which will ensure this invariant is met, unless you already have\n the minimum and maximum corners.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "(bevy_ecs::entity::Entity, bevy_picking::backend::HitData)": {
      "info": {
        "kind": "tuple",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_ecs::entity::Entity",
            "docs": null
          },
          {
            "index": 1,
            "type_path": "bevy_picking::backend::HitData",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "(bevy_ecs::entity::Entity, bevy_picking::backend::HitData)",
        "short_type_path": "(Entity, HitData)",
        "ident": null,
        "crate_name": null,
        "module_path": null
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::srgba::Srgba": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "red",
            "type_path": "f32",
            "docs": " The red channel. [0.0, 1.0]"
          },
          {
            "name": "green",
            "type_path": "f32",
            "docs": " The green channel. [0.0, 1.0]"
          },
          {
            "name": "blue",
            "type_path": "f32",
            "docs": " The blue channel. [0.0, 1.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::srgba::Srgba",
        "short_type_path": "Srgba",
        "ident": "Srgba",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::srgba"
      },
      "default": "{\"bevy_color::srgba::Srgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}}",
      "docs": " Non-linear standard RGB with alpha.\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_window::window::WindowRef": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Primary",
            "docs": " This will be linked to the primary window that is created by default\n in the [`WindowPlugin`](crate::WindowPlugin::primary_window)."
          },
          {
            "kind": "tuple",
            "name": "Entity",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_ecs::entity::Entity",
                "docs": null
              }
            ],
            "docs": " A more direct link to a window entity.\n\n Use this if you want to reference a secondary/tertiary/... window.\n\n To create a new window you can spawn an entity with a [`Window`],\n then you can use that entity here for usage in cameras."
          }
        ]
      },
      "path_table": {
        "path": "bevy_window::window::WindowRef",
        "short_type_path": "WindowRef",
        "ident": "WindowRef",
        "crate_name": "bevy_window",
        "module_path": "bevy_window::window"
      },
      "default": null,
      "docs": " Reference to a [`Window`], whether it be a direct link to a specific entity or\n a more vague defaulting choice.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_math::primitives::dim3::Sphere": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "radius",
            "type_path": "f32",
            "docs": " The radius of the sphere"
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::primitives::dim3::Sphere",
        "short_type_path": "Sphere",
        "ident": "Sphere",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::primitives::dim3"
      },
      "default": "{\"bevy_math::primitives::dim3::Sphere\":{\"radius\":0.5}}",
      "docs": " A sphere primitive, representing the set of all points some distance from the origin",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::view::visibility::Visibility": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Inherited",
            "docs": " An entity with `Visibility::Inherited` will inherit the Visibility of its [`Parent`].\n\n A root-level entity that is set to `Inherited` will be visible."
          },
          {
            "kind": "unit",
            "name": "Hidden",
            "docs": " An entity with `Visibility::Hidden` will be unconditionally hidden."
          },
          {
            "kind": "unit",
            "name": "Visible",
            "docs": " An entity with `Visibility::Visible` will be unconditionally visible.\n\n Note that an entity with `Visibility::Visible` will be visible regardless of whether the\n [`Parent`] entity is hidden."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::visibility::Visibility",
        "short_type_path": "Visibility",
        "ident": "Visibility",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::visibility"
      },
      "default": "{\"bevy_render::view::visibility::Visibility\":\"Inherited\"}",
      "docs": " User indication of whether an entity is visible. Propagates down the entity hierarchy.\n\n If an entity is hidden in this way, all [`Children`] (and all of their children and so on) who\n are set to [`Inherited`](Self::Inherited) will also be hidden.\n\n This is done by the `visibility_propagate_system` which uses the entity hierarchy and\n `Visibility` to set the values of each entity's [`InheritedVisibility`] component.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::primitives::Frustum": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_render::primitives::Frustum",
        "short_type_path": "Frustum",
        "ident": "Frustum",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::primitives"
      },
      "default": "{\"bevy_render::primitives::Frustum\":{}}",
      "docs": " A region of 3D space defined by the intersection of 6 [`HalfSpace`]s.\n\n Frustums are typically an apex-truncated square pyramid (a pyramid without the top) or a cuboid.\n\n Half spaces are ordered left, right, top, bottom, near, far. The normal vectors\n of the half-spaces point towards the interior of the frustum.\n\n A frustum component is used on an entity with a [`Camera`] component to\n determine which entities will be considered for rendering by this camera.\n All entities with an [`Aabb`] component that are not contained by (or crossing\n the boundary of) the frustum will not be rendered, and not be used in rendering computations.\n\n This process is called frustum culling, and entities can opt out of it using\n the [`NoFrustumCulling`] component.\n\n The frustum component is typically added automatically for cameras, either `Camera2d` or `Camera3d`.\n It is usually updated automatically by [`update_frusta`] from the\n [`CameraProjection`] component and [`GlobalTransform`] of the camera entity.\n\n [`Camera`]: crate::camera::Camera\n [`NoFrustumCulling`]: crate::view::visibility::NoFrustumCulling\n [`update_frusta`]: crate::view::visibility::update_frusta\n [`CameraProjection`]: crate::camera::CameraProjection\n [`GlobalTransform`]: bevy_transform::components::GlobalTransform",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "glam::Vec4": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "z",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "w",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Vec4",
        "short_type_path": "Vec4",
        "ident": "Vec4",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Vec4\":[0.0,0.0,0.0,0.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::bloom::settings::BloomCompositeMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "EnergyConserving",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Additive",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::bloom::settings::BloomCompositeMode",
        "short_type_path": "BloomCompositeMode",
        "ident": "BloomCompositeMode",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::bloom::settings"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_audio::audio::SpatialListener": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "left_ear_offset",
            "type_path": "glam::Vec3",
            "docs": " Left ear position relative to the `GlobalTransform`."
          },
          {
            "name": "right_ear_offset",
            "type_path": "glam::Vec3",
            "docs": " Right ear position relative to the `GlobalTransform`."
          }
        ]
      },
      "path_table": {
        "path": "bevy_audio::audio::SpatialListener",
        "short_type_path": "SpatialListener",
        "ident": "SpatialListener",
        "crate_name": "bevy_audio",
        "module_path": "bevy_audio::audio"
      },
      "default": "{\"bevy_audio::audio::SpatialListener\":{\"left_ear_offset\":[-2.0,-0.0,-0.0],\"right_ear_offset\":[2.0,0.0,0.0]}}",
      "docs": " Settings for the listener for spatial audio sources.\n\n This must be accompanied by `Transform` and `GlobalTransform`.\n Only one entity with a `SpatialListener` should be present at any given time.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_asset::folder::LoadedFolder>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_asset::folder::LoadedFolder>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_asset::folder::LoadedFolder>",
        "short_type_path": "Handle<LoadedFolder>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_asset::folder::LoadedFolder>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<bevy_render::camera::camera::SubCameraView>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_render::camera::camera::SubCameraView",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_render::camera::camera::SubCameraView>",
        "short_type_path": "Option<SubCameraView>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::widget::image::ImageNodeSize": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "size",
            "type_path": "glam::UVec2",
            "docs": " The size of the image's texture\n\n This field is updated automatically by [`update_image_content_size_system`]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::widget::image::ImageNodeSize",
        "short_type_path": "ImageNodeSize",
        "ident": "ImageNodeSize",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::widget::image"
      },
      "default": "{\"bevy_ui::widget::image::ImageNodeSize\":{\"size\":[0,0]}}",
      "docs": " The size of the image's texture\n\n This component is updated automatically by [`update_image_content_size_system`]",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_animation::graph::AnimationGraph": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "graph",
            "type_path": "petgraph::graph::DiGraph<bevy_animation::graph::AnimationGraphNode, (), u32>",
            "docs": " The `petgraph` data structure that defines the animation graph."
          },
          {
            "name": "root",
            "type_path": "petgraph::graph::NodeIndex",
            "docs": " The index of the root node in the animation graph."
          },
          {
            "name": "mask_groups",
            "type_path": "bevy_utils::hashbrown::HashMap<bevy_animation::AnimationTargetId, u64, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
            "docs": " The mask groups that each animation target (bone) belongs to.\n\n Each value in this map is a bitfield, in which 0 in bit position N\n indicates that the animation target doesn't belong to mask group N, and\n a 1 in position N indicates that the animation target does belong to\n mask group N.\n\n Animation targets not in this collection are treated as though they\n don't belong to any mask groups."
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::graph::AnimationGraph",
        "short_type_path": "AnimationGraph",
        "ident": "AnimationGraph",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation::graph"
      },
      "default": null,
      "docs": " A graph structure that describes how animation clips are to be blended\n together.\n\n Applications frequently want to be able to play multiple animations at once\n and to fine-tune the influence that animations have on a skinned mesh. Bevy\n uses an *animation graph* to store this information. Animation graphs are a\n directed acyclic graph (DAG) that describes how animations are to be\n weighted and combined together. Every frame, Bevy evaluates the graph from\n the root and blends the animations together in a bottom-up fashion to\n produce the final pose.\n\n There are three types of nodes: *blend nodes*, *add nodes*, and *clip\n nodes*, all of which can have an associated weight. Blend nodes and add\n nodes have no associated animation clip and combine the animations of their\n children according to those children's weights. Clip nodes specify an\n animation clip to play. When a graph is created, it starts with only a\n single blend node, the root node.\n\n For example, consider the following graph:\n\n ```text\n ┌────────────┐                                      \n │            │                                      \n │    Idle    ├─────────────────────┐                \n │            │                     │                \n └────────────┘                     │                \n                                    │                \n ┌────────────┐                     │  ┌────────────┐\n │            │                     │  │            │\n │    Run     ├──┐                  ├──┤    Root    │\n │            │  │  ┌────────────┐  │  │            │\n └────────────┘  │  │   Blend    │  │  └────────────┘\n                 ├──┤            ├──┘                \n ┌────────────┐  │  │    0.5     │                   \n │            │  │  └────────────┘                   \n │    Walk    ├──┘                                   \n │            │                                      \n └────────────┘                                      \n ```\n\n In this case, assuming that Idle, Run, and Walk are all playing with weight\n 1.0, the Run and Walk animations will be equally blended together, then\n their weights will be halved and finally blended with the Idle animation.\n Thus the weight of Run and Walk are effectively half of the weight of Idle.\n\n Nodes can optionally have a *mask*, a bitfield that restricts the set of\n animation targets that the node and its descendants affect. Each bit in the\n mask corresponds to a *mask group*, which is a set of animation targets\n (bones). An animation target can belong to any number of mask groups within\n the context of an animation graph.\n\n When the appropriate bit is set in a node's mask, neither the node nor its\n descendants will animate any animation targets belonging to that mask group.\n That is, setting a mask bit to 1 *disables* the animation targets in that\n group. If an animation target belongs to multiple mask groups, masking any\n one of the mask groups that it belongs to will mask that animation target.\n (Thus an animation target will only be animated if *all* of its mask groups\n are unmasked.)\n\n A common use of masks is to allow characters to hold objects. For this, the\n typical workflow is to assign each character's hand to a mask group. Then,\n when the character picks up an object, the application masks out the hand\n that the object is held in for the character's animation set, then positions\n the hand's digits as necessary to grasp the object. The character's\n animations will continue to play but will not affect the hand, which will\n continue to be depicted as holding the object.\n\n Animation graphs are assets and can be serialized to and loaded from [RON]\n files. Canonically, such files have an `.animgraph.ron` extension.\n\n The animation graph implements [RFC 51]. See that document for more\n information.\n\n [RON]: https://github.com/ron-rs/ron\n\n [RFC 51]: https://github.com/bevyengine/rfcs/blob/main/rfcs/51-animation-composition.md",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::mesh::components::Mesh3d": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::mesh::components::Mesh3d",
        "short_type_path": "Mesh3d",
        "ident": "Mesh3d",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::mesh::components"
      },
      "default": "{\"bevy_render::mesh::components::Mesh3d\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A component for 3D meshes. Requires a [`MeshMaterial3d`] to be rendered, commonly using a [`StandardMaterial`].\n\n [`MeshMaterial3d`]: <https://docs.rs/bevy/latest/bevy/pbr/struct.MeshMaterial3d.html>\n [`StandardMaterial`]: <https://docs.rs/bevy/latest/bevy/pbr/struct.StandardMaterial.html>\n\n # Example\n\n ```ignore\n # use bevy_pbr::{Material, MeshMaterial3d, StandardMaterial};\n # use bevy_ecs::prelude::*;\n # use bevy_render::mesh::{Mesh, Mesh3d};\n # use bevy_color::palettes::basic::RED;\n # use bevy_asset::Assets;\n # use bevy_math::primitives::Capsule3d;\n #\n // Spawn an entity with a mesh using `StandardMaterial`.\n fn setup(\n     mut commands: Commands,\n     mut meshes: ResMut<Assets<Mesh>>,\n     mut materials: ResMut<Assets<StandardMaterial>>,\n ) {\n     commands.spawn((\n         Mesh3d(meshes.add(Capsule3d::default())),\n         MeshMaterial3d(materials.add(StandardMaterial {\n             base_color: RED.into(),\n             ..Default::default()\n         })),\n     ));\n }\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "core::option::Option<bevy_render::camera::camera::Viewport>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_render::camera::camera::Viewport",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_render::camera::camera::Viewport>",
        "short_type_path": "Option<Viewport>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::GridAutoFlow": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Row",
            "docs": " Items are placed by filling each row in turn, adding new rows as necessary."
          },
          {
            "kind": "unit",
            "name": "Column",
            "docs": " Items are placed by filling each column in turn, adding new columns as necessary."
          },
          {
            "kind": "unit",
            "name": "RowDense",
            "docs": " Combines `Row` with the dense packing algorithm."
          },
          {
            "kind": "unit",
            "name": "ColumnDense",
            "docs": " Combines `Column` with the dense packing algorithm."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::GridAutoFlow",
        "short_type_path": "GridAutoFlow",
        "ident": "GridAutoFlow",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::GridAutoFlow\":\"Row\"}",
      "docs": " Controls whether grid items are placed row-wise or column-wise as well as whether the sparse or dense packing algorithm is used.\n\n The \"dense\" packing algorithm attempts to fill in holes earlier in the grid, if smaller items come up later.\n This may cause items to appear out-of-order when doing so would fill in holes left by larger items.\n\n Defaults to [`GridAutoFlow::Row`].\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::FlexDirection": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Row",
            "docs": " Same way as text direction along the main axis."
          },
          {
            "kind": "unit",
            "name": "Column",
            "docs": " Flex from top to bottom."
          },
          {
            "kind": "unit",
            "name": "RowReverse",
            "docs": " Opposite way as text direction along the main axis."
          },
          {
            "kind": "unit",
            "name": "ColumnReverse",
            "docs": " Flex from bottom to top."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::FlexDirection",
        "short_type_path": "FlexDirection",
        "ident": "FlexDirection",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::FlexDirection\":\"Row\"}",
      "docs": " Defines how flexbox items are ordered within a flexbox",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "uuid::Uuid": {
      "info": {
        "kind": "opaque",
        "item_type_path": "uuid::Uuid"
      },
      "path_table": {
        "path": "uuid::Uuid",
        "short_type_path": "Uuid",
        "ident": "Uuid",
        "crate_name": "uuid",
        "module_path": "uuid"
      },
      "default": "{\"uuid::Uuid\":\"00000000-0000-0000-0000-000000000000\"}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::glyph::GlyphAtlasLocation": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "glyph_index",
            "type_path": "usize",
            "docs": " The index of the glyph in the atlas"
          },
          {
            "name": "offset",
            "type_path": "glam::IVec2",
            "docs": " The required offset (relative positioning) when placed"
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::glyph::GlyphAtlasLocation",
        "short_type_path": "GlyphAtlasLocation",
        "ident": "GlyphAtlasLocation",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::glyph"
      },
      "default": null,
      "docs": " The location of a glyph in an atlas,\n and how it should be positioned when placed.\n\n Used in [`GlyphAtlasInfo`] and [`FontAtlas`](crate::FontAtlas).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_mesh::mesh::Mesh": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "indices",
            "type_path": "core::option::Option<bevy_mesh::index::Indices>",
            "docs": null
          },
          {
            "name": "morph_targets",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
            "docs": null
          },
          {
            "name": "morph_target_names",
            "type_path": "core::option::Option<alloc::vec::Vec<alloc::string::String>>",
            "docs": null
          },
          {
            "name": "asset_usage",
            "type_path": "bevy_asset::render_asset::RenderAssetUsages",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_mesh::mesh::Mesh",
        "short_type_path": "Mesh",
        "ident": "Mesh",
        "crate_name": "bevy_mesh",
        "module_path": "bevy_mesh::mesh"
      },
      "default": null,
      "docs": " A 3D object made out of vertices representing triangles, lines, or points,\n with \"attribute\" values for each vertex.\n\n Meshes can be automatically generated by a bevy `AssetLoader` (generally by loading a `Gltf` file),\n or by converting a [primitive](bevy_math::primitives) using [`into`](Into).\n It is also possible to create one manually. They can be edited after creation.\n\n Meshes can be rendered with a `Mesh2d` and `MeshMaterial2d`\n or `Mesh3d` and `MeshMaterial3d` for 2D and 3D respectively.\n\n A [`Mesh`] in Bevy is equivalent to a \"primitive\" in the glTF format, for a\n glTF Mesh representation, see `GltfMesh`.\n\n ## Manual creation\n\n The following function will construct a flat mesh, to be rendered with a\n `StandardMaterial` or `ColorMaterial`:\n\n ```\n # use bevy_mesh::{Mesh, Indices, PrimitiveTopology};\n # use bevy_asset::RenderAssetUsages;\n fn create_simple_parallelogram() -> Mesh {\n     // Create a new mesh using a triangle list topology, where each set of 3 vertices composes a triangle.\n     Mesh::new(PrimitiveTopology::TriangleList, RenderAssetUsages::default())\n         // Add 4 vertices, each with its own position attribute (coordinate in\n         // 3D space), for each of the corners of the parallelogram.\n         .with_inserted_attribute(\n             Mesh::ATTRIBUTE_POSITION,\n             vec![[0.0, 0.0, 0.0], [1.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 0.0, 0.0]]\n         )\n         // Assign a UV coordinate to each vertex.\n         .with_inserted_attribute(\n             Mesh::ATTRIBUTE_UV_0,\n             vec![[0.0, 1.0], [0.5, 0.0], [1.0, 0.0], [0.5, 1.0]]\n         )\n         // Assign normals (everything points outwards)\n         .with_inserted_attribute(\n             Mesh::ATTRIBUTE_NORMAL,\n             vec![[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0]]\n         )\n         // After defining all the vertices and their attributes, build each triangle using the\n         // indices of the vertices that make it up in a counter-clockwise order.\n         .with_inserted_indices(Indices::U32(vec![\n             // First triangle\n             0, 3, 1,\n             // Second triangle\n             1, 3, 2\n         ]))\n }\n ```\n\n You can see how it looks like [here](https://github.com/bevyengine/bevy/blob/main/assets/docs/Mesh.png),\n used in a `Mesh3d` with a square bevy logo texture, with added axis, points,\n lines and text for clarity.\n\n ## Other examples\n\n For further visualization, explanation, and examples, see the built-in Bevy examples,\n and the [implementation of the built-in shapes](https://github.com/bevyengine/bevy/tree/main/crates/bevy_mesh/src/primitives).\n In particular, [generate_custom_mesh](https://github.com/bevyengine/bevy/blob/main/examples/3d/generate_custom_mesh.rs)\n teaches you to access and modify the attributes of a [`Mesh`] after creating it.\n\n ## Common points of confusion\n\n - UV maps in Bevy start at the top-left, see [`ATTRIBUTE_UV_0`](Mesh::ATTRIBUTE_UV_0),\n     other APIs can have other conventions, `OpenGL` starts at bottom-left.\n - It is possible and sometimes useful for multiple vertices to have the same\n     [position attribute](Mesh::ATTRIBUTE_POSITION) value,\n     it's a common technique in 3D modeling for complex UV mapping or other calculations.\n - Bevy performs frustum culling based on the `Aabb` of meshes, which is calculated\n     and added automatically for new meshes only. If a mesh is modified, the entity's `Aabb`\n     needs to be updated manually or deleted so that it is re-calculated.\n\n ## Use with `StandardMaterial`\n\n To render correctly with `StandardMaterial`, a mesh needs to have properly defined:\n - [`UVs`](Mesh::ATTRIBUTE_UV_0): Bevy needs to know how to map a texture onto the mesh\n     (also true for `ColorMaterial`).\n - [`Normals`](Mesh::ATTRIBUTE_NORMAL): Bevy needs to know how light interacts with your mesh.\n     [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,\n     because simple meshes are smooth and they don't require complex light calculations.\n - Vertex winding order: by default, `StandardMaterial.cull_mode` is `Some(Face::Back)`,\n     which means that Bevy would *only* render the \"front\" of each triangle, which\n     is the side of the triangle from where the vertices appear in a *counter-clockwise* order.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<u32>": {
      "info": {
        "kind": "list",
        "item_type_path": "u32"
      },
      "path_table": {
        "path": "alloc::vec::Vec<u32>",
        "short_type_path": "Vec<u32>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_scene::utils::bundle_placeholder::MeshPlaceholder": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Circle",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_math::primitives::dim2::Circle",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Cuboid",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_math::primitives::dim3::Cuboid",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Sphere",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_math::primitives::dim3::Sphere",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Cylinder",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_math::primitives::dim3::Cylinder",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Plane3d",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_math::primitives::dim3::Plane3d",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::bundle_placeholder::MeshPlaceholder",
        "short_type_path": "MeshPlaceholder",
        "ident": "MeshPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::bundle_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_a11y::Focus": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "core::option::Option<bevy_ecs::entity::Entity>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_a11y::Focus",
        "short_type_path": "Focus",
        "ident": "Focus",
        "crate_name": "bevy_a11y",
        "module_path": "bevy_a11y"
      },
      "default": "{\"bevy_a11y::Focus\":null}",
      "docs": " Resource representing which entity has keyboard focus, if any.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_asset::id::AssetId<bevy_gltf::GltfSkin>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_gltf::GltfSkin>",
        "short_type_path": "AssetId<GltfSkin>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::widget::image::NodeImageMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Auto",
            "docs": " The image will be sized automatically by taking the size of the source image and applying any layout constraints."
          },
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " The image will be resized to match the size of the node. The image's original size and aspect ratio will be ignored."
          },
          {
            "kind": "tuple",
            "name": "Sliced",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_sprite::texture_slice::slicer::TextureSlicer",
                "docs": null
              }
            ],
            "docs": " The texture will be cut in 9 slices, keeping the texture in proportions on resize"
          },
          {
            "kind": "struct",
            "name": "Tiled",
            "fields": [
              {
                "name": "tile_x",
                "type_path": "bool",
                "docs": " Should the image repeat horizontally"
              },
              {
                "name": "tile_y",
                "type_path": "bool",
                "docs": " Should the image repeat vertically"
              },
              {
                "name": "stretch_value",
                "type_path": "f32",
                "docs": " The texture will repeat when the ratio between the *drawing dimensions* of texture and the\n *original texture size* are above this value."
              }
            ],
            "docs": " The texture will be repeated if stretched beyond `stretched_value`"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::widget::image::NodeImageMode",
        "short_type_path": "NodeImageMode",
        "ident": "NodeImageMode",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::widget::image"
      },
      "default": null,
      "docs": " Controls how the image is altered to fit within the layout and how the layout algorithm determines the space in the layout for the image",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_scene::utils::bundle_placeholder::MaterialPlaceholder": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Color",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_color::color::Color",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "struct",
            "name": "StandardMaterial",
            "fields": [
              {
                "name": "base_color",
                "type_path": "bevy_color::color::Color",
                "docs": null
              },
              {
                "name": "unlit",
                "type_path": "bool",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "struct",
            "name": "Texture",
            "fields": [
              {
                "name": "path",
                "type_path": "alloc::string::String",
                "docs": null
              },
              {
                "name": "unlit",
                "type_path": "bool",
                "docs": null
              },
              {
                "name": "alpha_mode",
                "type_path": "bevy_render::alpha::AlphaMode",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::bundle_placeholder::MaterialPlaceholder",
        "short_type_path": "MaterialPlaceholder",
        "ident": "MaterialPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::bundle_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::UiAntiAlias": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "On",
            "docs": " UI will render with anti-aliasing"
          },
          {
            "kind": "unit",
            "name": "Off",
            "docs": " UI will render without anti-aliasing"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::UiAntiAlias",
        "short_type_path": "UiAntiAlias",
        "ident": "UiAntiAlias",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": null,
      "docs": " Marker for controlling whether Ui is rendered with or without anti-aliasing\n in a camera. By default, Ui is always anti-aliased.\n\n **Note:** This does not affect text anti-aliasing. For that, use the `font_smoothing` property of the [`TextFont`](bevy_text::TextFont) component.\n\n ```\n use bevy_core_pipeline::prelude::*;\n use bevy_ecs::prelude::*;\n use bevy_ui::prelude::*;\n\n fn spawn_camera(mut commands: Commands) {\n     commands.spawn((\n         Camera2d,\n         // This will cause all Ui in this camera to be rendered without\n         // anti-aliasing\n         UiAntiAlias::Off,\n     ));\n }\n ```",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevy_animation::TimedAnimationEvent>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_animation::TimedAnimationEvent"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_animation::TimedAnimationEvent>",
        "short_type_path": "Vec<TimedAnimationEvent>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gltf::GltfExtras": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "value",
            "type_path": "alloc::string::String",
            "docs": " Content of the extra data."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gltf::GltfExtras",
        "short_type_path": "GltfExtras",
        "ident": "GltfExtras",
        "crate_name": "bevy_gltf",
        "module_path": "bevy_gltf"
      },
      "default": "{\"bevy_gltf::GltfExtras\":{\"value\":\"\"}}",
      "docs": " Additional untyped data that can be present on most glTF types at the primitive level.\n\n See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::OverflowClipBox": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "ContentBox",
            "docs": " Clip any content that overflows outside the content box"
          },
          {
            "kind": "unit",
            "name": "PaddingBox",
            "docs": " Clip any content that overflows outside the padding box"
          },
          {
            "kind": "unit",
            "name": "BorderBox",
            "docs": " Clip any content that overflows outside the border box"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::OverflowClipBox",
        "short_type_path": "OverflowClipBox",
        "ident": "OverflowClipBox",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::OverflowClipBox\":\"ContentBox\"}",
      "docs": " Used to determine the bounds of the visible area when a UI node is clipped.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::graph::ThreadedAnimationGraphs": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_utils::hashbrown::HashMap<bevy_asset::id::AssetId<bevy_animation::graph::AnimationGraph>, bevy_animation::graph::ThreadedAnimationGraph, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::graph::ThreadedAnimationGraphs",
        "short_type_path": "ThreadedAnimationGraphs",
        "ident": "ThreadedAnimationGraphs",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation::graph"
      },
      "default": null,
      "docs": " Acceleration structures for animation graphs that allows Bevy to evaluate\n them quickly.\n\n These are kept up to date as [`AnimationGraph`] instances are added,\n modified, and removed.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::ActiveAnimation": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "weight",
            "type_path": "f32",
            "docs": " The factor by which the weight from the [`AnimationGraph`] is multiplied."
          },
          {
            "name": "repeat",
            "type_path": "bevy_animation::RepeatAnimation",
            "docs": null
          },
          {
            "name": "speed",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed",
            "type_path": "f32",
            "docs": " Total time the animation has been played.\n\n Note: Time does not increase when the animation is paused or after it has completed."
          },
          {
            "name": "seek_time",
            "type_path": "f32",
            "docs": " The timestamp inside of the animation clip.\n\n Note: This will always be in the range [0.0, animation clip duration]"
          },
          {
            "name": "last_seek_time",
            "type_path": "core::option::Option<f32>",
            "docs": " The `seek_time` of the previous tick, if any."
          },
          {
            "name": "completions",
            "type_path": "u32",
            "docs": " Number of times the animation has completed.\n If the animation is playing in reverse, this increments when the animation passes the start."
          },
          {
            "name": "just_completed",
            "type_path": "bool",
            "docs": " `true` if the animation was completed at least once this tick."
          },
          {
            "name": "paused",
            "type_path": "bool",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::ActiveAnimation",
        "short_type_path": "ActiveAnimation",
        "ident": "ActiveAnimation",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": " An animation that an [`AnimationPlayer`] is currently either playing or was\n playing, but is presently paused.\n\n An stopped animation is considered no longer active.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_transform::components::transform::Transform": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "translation",
            "type_path": "glam::Vec3",
            "docs": " Position of the entity. In 2d, the last value of the `Vec3` is used for z-ordering.\n\n See the [`translations`] example for usage.\n\n [`translations`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/translation.rs"
          },
          {
            "name": "rotation",
            "type_path": "glam::Quat",
            "docs": " Rotation of the entity.\n\n See the [`3d_rotation`] example for usage.\n\n [`3d_rotation`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/3d_rotation.rs"
          },
          {
            "name": "scale",
            "type_path": "glam::Vec3",
            "docs": " Scale of the entity.\n\n See the [`scale`] example for usage.\n\n [`scale`]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/scale.rs"
          }
        ]
      },
      "path_table": {
        "path": "bevy_transform::components::transform::Transform",
        "short_type_path": "Transform",
        "ident": "Transform",
        "crate_name": "bevy_transform",
        "module_path": "bevy_transform::components::transform"
      },
      "default": "{\"bevy_transform::components::transform::Transform\":{\"translation\":[0.0,0.0,0.0],\"rotation\":[0.0,0.0,0.0,1.0],\"scale\":[1.0,1.0,1.0]}}",
      "docs": " Describe the position of an entity. If the entity has a parent, the position is relative\n to its parent position.\n\n * To place or move an entity, you should set its [`Transform`].\n * To get the global transform of an entity, you should get its [`GlobalTransform`].\n * To be displayed, an entity must have both a [`Transform`] and a [`GlobalTransform`].\n   * ~You may use the [`TransformBundle`](crate::bundles::TransformBundle) to guarantee this.~\n     [`TransformBundle`](crate::bundles::TransformBundle) is now deprecated.\n     [`GlobalTransform`] is automatically inserted whenever [`Transform`] is inserted.\n\n ## [`Transform`] and [`GlobalTransform`]\n\n [`Transform`] is the position of an entity relative to its parent position, or the reference\n frame if it doesn't have a [`Parent`](bevy_hierarchy::Parent).\n\n [`GlobalTransform`] is the position of an entity relative to the reference frame.\n\n [`GlobalTransform`] is updated from [`Transform`] by systems in the system set\n [`TransformPropagate`](crate::TransformSystem::TransformPropagate).\n\n This system runs during [`PostUpdate`](bevy_app::PostUpdate). If you\n update the [`Transform`] of an entity during this set or after, you will notice a 1 frame lag\n before the [`GlobalTransform`] is updated.\n\n # Examples\n\n - [`transform`][transform_example]\n\n [transform_example]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/transform.rs",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_core_pipeline::smaa::Smaa": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "preset",
            "type_path": "bevy_core_pipeline::smaa::SmaaPreset",
            "docs": " A predefined set of SMAA parameters: i.e. a quality level.\n\n Generally, you can leave this at its default level."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::smaa::Smaa",
        "short_type_path": "Smaa",
        "ident": "Smaa",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::smaa"
      },
      "default": "{\"bevy_core_pipeline::smaa::Smaa\":{\"preset\":\"High\"}}",
      "docs": " A component for enabling Subpixel Morphological Anti-Aliasing (SMAA)\n for a [`bevy_render::camera::Camera`].",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_render::render_resource::shader::Shader>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_render::render_resource::shader::Shader>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_render::render_resource::shader::Shader>",
        "short_type_path": "Handle<Shader>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_render::render_resource::shader::Shader>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_core::components::ui_terminal::InputContainer": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevyhub_core::components::ui_terminal::InputContainer",
        "short_type_path": "InputContainer",
        "ident": "InputContainer",
        "crate_name": "bevyhub_core",
        "module_path": "bevyhub_core::components::ui_terminal"
      },
      "default": "{\"bevyhub_core::components::ui_terminal::InputContainer\":{}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_math::rects::urect::URect": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "min",
            "type_path": "glam::UVec2",
            "docs": " The minimum corner point of the rect."
          },
          {
            "name": "max",
            "type_path": "glam::UVec2",
            "docs": " The maximum corner point of the rect."
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::rects::urect::URect",
        "short_type_path": "URect",
        "ident": "URect",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::rects::urect"
      },
      "default": "{\"bevy_math::rects::urect::URect\":{\"min\":[0,0],\"max\":[0,0]}}",
      "docs": " A rectangle defined by two opposite corners.\n\n The rectangle is axis aligned, and defined by its minimum and maximum coordinates,\n stored in `URect::min` and `URect::max`, respectively. The minimum/maximum invariant\n must be upheld by the user when directly assigning the fields, otherwise some methods\n produce invalid results. It is generally recommended to use one of the constructor\n methods instead, which will ensure this invariant is met, unless you already have\n the minimum and maximum corners.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bool": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bool"
      },
      "path_table": {
        "path": "bool",
        "short_type_path": "bool",
        "ident": "bool",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"bool\":false}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::sync::Arc<bevy_asset::handle::StrongHandle>": {
      "info": {
        "kind": "opaque",
        "item_type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>"
      },
      "path_table": {
        "path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
        "short_type_path": "Arc<StrongHandle>",
        "ident": "Arc",
        "crate_name": "alloc",
        "module_path": "alloc::sync"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::transition::AnimationTransition": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "current_weight",
            "type_path": "f32",
            "docs": " The current weight. Starts at 1.0 and goes to 0.0 during the fade-out."
          },
          {
            "name": "weight_decline_per_sec",
            "type_path": "f32",
            "docs": " How much to decrease `current_weight` per second"
          },
          {
            "name": "animation",
            "type_path": "petgraph::graph::NodeIndex",
            "docs": " The animation that is being faded out"
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::transition::AnimationTransition",
        "short_type_path": "AnimationTransition",
        "ident": "AnimationTransition",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation::transition"
      },
      "default": null,
      "docs": " An animation that is being faded out as part of a transition",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_audio::audio_source::AudioSource>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_audio::audio_source::AudioSource>",
        "short_type_path": "AssetId<AudioSource>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_mesh::skinning::SkinnedMeshInverseBindposes>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_mesh::skinning::SkinnedMeshInverseBindposes>",
        "short_type_path": "AssetId<SkinnedMeshInverseBindposes>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::assets::AssetIndex": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "generation",
            "type_path": "u32",
            "docs": null
          },
          {
            "name": "index",
            "type_path": "u32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::assets::AssetIndex",
        "short_type_path": "AssetIndex",
        "ident": "AssetIndex",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::assets"
      },
      "default": null,
      "docs": " A generational runtime-only identifier for a specific [`Asset`] stored in [`Assets`]. This is optimized for efficient runtime\n usage and is not suitable for identifying assets across app runs.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::text2d::Text2d": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text2d::Text2d",
        "short_type_path": "Text2d",
        "ident": "Text2d",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text2d"
      },
      "default": "{\"bevy_text::text2d::Text2d\":\"\"}",
      "docs": " The top-level 2D text component.\n\n Adding `Text2d` to an entity will pull in required components for setting up 2d text.\n [Example usage.](https://github.com/bevyengine/bevy/blob/latest/examples/2d/text2d.rs)\n\n The string in this component is the first 'text span' in a hierarchy of text spans that are collected into\n a [`ComputedTextBlock`]. See [`TextSpan`](crate::TextSpan) for the component used by children of entities with [`Text2d`].\n\n With `Text2d` the `justify` field of [`TextLayout`] only affects the internal alignment of a block of text and not its\n relative position, which is controlled by the [`Anchor`] component.\n This means that for a block of text consisting of only one line that doesn't wrap, the `justify` field will have no effect.\n\n\n ```\n # use bevy_asset::Handle;\n # use bevy_color::Color;\n # use bevy_color::palettes::basic::BLUE;\n # use bevy_ecs::world::World;\n # use bevy_text::{Font, JustifyText, Text2d, TextLayout, TextFont, TextColor};\n #\n # let font_handle: Handle<Font> = Default::default();\n # let mut world = World::default();\n #\n // Basic usage.\n world.spawn(Text2d::new(\"hello world!\"));\n\n // With non-default style.\n world.spawn((\n     Text2d::new(\"hello world!\"),\n     TextFont {\n         font: font_handle.clone().into(),\n         font_size: 60.0,\n         ..Default::default()\n     },\n     TextColor(BLUE.into()),\n ));\n\n // With text justification.\n world.spawn((\n     Text2d::new(\"hello world\\nand bevy!\"),\n     TextLayout::new_with_justify(JustifyText::Center)\n ));\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_picking::pointer::PointerId": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Mouse",
            "docs": " The mouse pointer."
          },
          {
            "kind": "tuple",
            "name": "Touch",
            "fields": [
              {
                "index": 0,
                "type_path": "u64",
                "docs": null
              }
            ],
            "docs": " A touch input, usually numbered by window touch events from `winit`."
          },
          {
            "kind": "tuple",
            "name": "Custom",
            "fields": [
              {
                "index": 0,
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A custom, uniquely identified pointer. Useful for mocking inputs or implementing a software\n controlled cursor."
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::pointer::PointerId",
        "short_type_path": "PointerId",
        "ident": "PointerId",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking::pointer"
      },
      "default": "{\"bevy_picking::pointer::PointerId\":\"Mouse\"}",
      "docs": " Identifies a unique pointer entity. `Mouse` and `Touch` pointers are automatically spawned.\n\n This component is needed because pointers can be spawned and despawned, but they need to have a\n stable ID that persists regardless of the Entity they are associated with.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_animation::AnimationClip>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_animation::AnimationClip>",
        "short_type_path": "AssetId<AnimationClip>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::light::NotShadowReceiver": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_pbr::light::NotShadowReceiver",
        "short_type_path": "NotShadowReceiver",
        "ident": "NotShadowReceiver",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": "{\"bevy_pbr::light::NotShadowReceiver\":{}}",
      "docs": " Add this component to make a [`Mesh3d`] not receive shadows.\n\n **Note:** If you're using diffuse transmission, setting [`NotShadowReceiver`] will\n cause both “regular” shadows as well as diffusely transmitted shadows to be disabled,\n even when [`TransmittedShadowReceiver`] is being used.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_gltf::GltfMesh>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_gltf::GltfMesh>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_gltf::GltfMesh>",
        "short_type_path": "Handle<GltfMesh>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_gltf::GltfMesh>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gltf::GltfMaterialName": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_gltf::GltfMaterialName",
        "short_type_path": "GltfMaterialName",
        "ident": "GltfMaterialName",
        "crate_name": "bevy_gltf",
        "module_path": "bevy_gltf"
      },
      "default": null,
      "docs": " The material name of a glTF primitive.\n\n See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-material).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "glam::Affine3A": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "matrix3",
            "type_path": "glam::Mat3A",
            "docs": null
          },
          {
            "name": "translation",
            "type_path": "glam::Vec3A",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Affine3A",
        "short_type_path": "Affine3A",
        "ident": "Affine3A",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Affine3A\":[1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_gizmos::LineGizmo>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_gizmos::LineGizmo>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_gizmos::LineGizmo>",
        "short_type_path": "Handle<LineGizmo>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_gizmos::LineGizmo>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::glyph::GlyphAtlasInfo": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "texture",
            "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
            "docs": " A handle to the [`Image`] data for the texture atlas this glyph was placed in.\n\n A (weak) clone of the handle held by the [`FontAtlas`](crate::FontAtlas)."
          },
          {
            "name": "texture_atlas",
            "type_path": "bevy_asset::handle::Handle<bevy_sprite::texture_atlas::TextureAtlasLayout>",
            "docs": " A handle to the [`TextureAtlasLayout`] map for the texture atlas this glyph was placed in.\n\n A (weak) clone of the handle held by the [`FontAtlas`](crate::FontAtlas)."
          },
          {
            "name": "location",
            "type_path": "bevy_text::glyph::GlyphAtlasLocation",
            "docs": " Location and offset of a glyph within the texture atlas."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::glyph::GlyphAtlasInfo",
        "short_type_path": "GlyphAtlasInfo",
        "ident": "GlyphAtlasInfo",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::glyph"
      },
      "default": null,
      "docs": " Information about a glyph in an atlas.\n\n Rasterized glyphs are stored as rectangles\n in one or more [`FontAtlas`](crate::FontAtlas)es.\n\n Used in [`PositionedGlyph`] and [`FontAtlasSet`](crate::FontAtlasSet).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::tonemapping::DebandDither": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Disabled",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Enabled",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::tonemapping::DebandDither",
        "short_type_path": "DebandDither",
        "ident": "DebandDither",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::tonemapping"
      },
      "default": "{\"bevy_core_pipeline::tonemapping::DebandDither\":\"Disabled\"}",
      "docs": " Enables a debanding shader that applies dithering to mitigate color banding in the final image for a given [`Camera`] entity.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::pbr_material::UvChannel": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Uv0",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Uv1",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::pbr_material::UvChannel",
        "short_type_path": "UvChannel",
        "ident": "UvChannel",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::pbr_material"
      },
      "default": "{\"bevy_pbr::pbr_material::UvChannel\":\"Uv0\"}",
      "docs": " An enum to define which UV attribute to use for a texture.\n\n It is used for every texture in the [`StandardMaterial`].\n It only supports two UV attributes, [`bevy_render::mesh::Mesh::ATTRIBUTE_UV_0`] and\n [`bevy_render::mesh::Mesh::ATTRIBUTE_UV_1`].\n The default is [`UvChannel::Uv0`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::mesh2d::material::MeshMaterial2d<bevy_sprite::mesh2d::color_material::ColorMaterial>": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_asset::handle::Handle<bevy_sprite::mesh2d::color_material::ColorMaterial>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::mesh2d::material::MeshMaterial2d<bevy_sprite::mesh2d::color_material::ColorMaterial>",
        "short_type_path": "MeshMaterial2d<ColorMaterial>",
        "ident": "MeshMaterial2d",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::mesh2d::material"
      },
      "default": "{\"bevy_sprite::mesh2d::material::MeshMaterial2d<bevy_sprite::mesh2d::color_material::ColorMaterial>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A [material](Material2d) used for rendering a [`Mesh2d`].\n\n See [`Material2d`] for general information about 2D materials and how to implement your own materials.\n\n # Example\n\n ```\n # use bevy_sprite::{ColorMaterial, MeshMaterial2d};\n # use bevy_ecs::prelude::*;\n # use bevy_render::mesh::{Mesh, Mesh2d};\n # use bevy_color::palettes::basic::RED;\n # use bevy_asset::Assets;\n # use bevy_math::primitives::Circle;\n #\n // Spawn an entity with a mesh using `ColorMaterial`.\n fn setup(\n     mut commands: Commands,\n     mut meshes: ResMut<Assets<Mesh>>,\n     mut materials: ResMut<Assets<ColorMaterial>>,\n ) {\n     commands.spawn((\n         Mesh2d(meshes.add(Circle::new(50.0))),\n         MeshMaterial2d(materials.add(ColorMaterial::from_color(RED))),\n     ));\n }\n ```\n\n [`MeshMaterial2d`]: crate::MeshMaterial2d",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::globals::GlobalsUniform": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "time",
            "type_path": "f32",
            "docs": " The time since startup in seconds.\n Wraps to 0 after 1 hour."
          },
          {
            "name": "delta_time",
            "type_path": "f32",
            "docs": " The delta time since the previous frame in seconds"
          },
          {
            "name": "frame_count",
            "type_path": "u32",
            "docs": " Frame count since the start of the app.\n It wraps to zero when it reaches the maximum value of a u32."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::globals::GlobalsUniform",
        "short_type_path": "GlobalsUniform",
        "ident": "GlobalsUniform",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::globals"
      },
      "default": "{\"bevy_render::globals::GlobalsUniform\":{\"time\":0.0,\"delta_time\":0.0,\"frame_count\":0}}",
      "docs": " Contains global values useful when writing shaders.\n Currently only contains values related to time.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_pbr::ssr::ScreenSpaceReflections": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "perceptual_roughness_threshold",
            "type_path": "f32",
            "docs": " The maximum PBR roughness level that will enable screen space\n reflections."
          },
          {
            "name": "thickness",
            "type_path": "f32",
            "docs": " When marching the depth buffer, we only have 2.5D information and don't\n know how thick surfaces are. We shall assume that the depth buffer\n fragments are cuboids with a constant thickness defined by this\n parameter."
          },
          {
            "name": "linear_steps",
            "type_path": "u32",
            "docs": " The number of steps to be taken at regular intervals to find an initial\n intersection. Must not be zero.\n\n Higher values result in higher-quality reflections, because the\n raymarching shader is less likely to miss objects. However, they take\n more GPU time."
          },
          {
            "name": "linear_march_exponent",
            "type_path": "f32",
            "docs": " Exponent to be applied in the linear part of the march.\n\n A value of 1.0 will result in equidistant steps, and higher values will\n compress the earlier steps, and expand the later ones. This might be\n desirable in order to get more detail close to objects.\n\n For optimal performance, this should be a small unsigned integer, such\n as 1 or 2."
          },
          {
            "name": "bisection_steps",
            "type_path": "u32",
            "docs": " Number of steps in a bisection (binary search) to perform once the\n linear search has found an intersection. Helps narrow down the hit,\n increasing the chance of the secant method finding an accurate hit\n point."
          },
          {
            "name": "use_secant",
            "type_path": "bool",
            "docs": " Approximate the root position using the secant method—by solving for\n line-line intersection between the ray approach rate and the surface\n gradient."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::ssr::ScreenSpaceReflections",
        "short_type_path": "ScreenSpaceReflections",
        "ident": "ScreenSpaceReflections",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::ssr"
      },
      "default": "{\"bevy_pbr::ssr::ScreenSpaceReflections\":{\"perceptual_roughness_threshold\":0.1,\"thickness\":0.25,\"linear_steps\":16,\"linear_march_exponent\":1.0,\"bisection_steps\":4,\"use_secant\":true}}",
      "docs": " Add this component to a camera to enable *screen-space reflections* (SSR).\n\n Screen-space reflections currently require deferred rendering in order to\n appear. Therefore, they also need the [`DepthPrepass`] and [`DeferredPrepass`]\n components, which are inserted automatically.\n\n SSR currently performs no roughness filtering for glossy reflections, so\n only very smooth surfaces will reflect objects in screen space. You can\n adjust the `perceptual_roughness_threshold` in order to tune the threshold\n below which screen-space reflections will be traced.\n\n As with all screen-space techniques, SSR can only reflect objects on screen.\n When objects leave the camera, they will disappear from reflections.\n An alternative that doesn't suffer from this problem is the combination of\n a [`LightProbe`](crate::LightProbe) and [`EnvironmentMapLight`]. The advantage of SSR is\n that it can reflect all objects, not just static ones.\n\n SSR is an approximation technique and produces artifacts in some situations.\n Hand-tuning the settings in this component will likely be useful.\n\n Screen-space reflections are presently unsupported on WebGL 2 because of a\n bug whereby Naga doesn't generate correct GLSL when sampling depth buffers,\n which is required for screen-space raymarching.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::camera::camera::TemporalJitter": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "offset",
            "type_path": "glam::Vec2",
            "docs": " Offset is in range [-0.5, 0.5]."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::camera::TemporalJitter",
        "short_type_path": "TemporalJitter",
        "ident": "TemporalJitter",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": "{\"bevy_render::camera::camera::TemporalJitter\":{\"offset\":[0.0,0.0]}}",
      "docs": " A subpixel offset to jitter a perspective camera's frustum by.\n\n Useful for temporal rendering techniques.\n\n Do not use with [`OrthographicProjection`].\n\n [`OrthographicProjection`]: crate::camera::OrthographicProjection",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_time::fixed::Fixed": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "timestep",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "overstep",
            "type_path": "bevy_utils::Duration",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::fixed::Fixed",
        "short_type_path": "Fixed",
        "ident": "Fixed",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::fixed"
      },
      "default": null,
      "docs": " The fixed timestep game clock following virtual time.\n\n A specialization of the [`Time`] structure. **For method documentation, see\n [`Time<Fixed>#impl-Time<Fixed>`].**\n     \n It is automatically inserted as a resource by\n [`TimePlugin`](crate::TimePlugin) and updated based on\n [`Time<Virtual>`](Virtual). The fixed clock is automatically set as the\n generic [`Time`] resource during [`FixedUpdate`](bevy_app::FixedUpdate)\n schedule processing.\n\n The fixed timestep clock advances in fixed-size increments, which is\n extremely useful for writing logic (like physics) that should have\n consistent behavior, regardless of framerate.\n\n The default [`timestep()`](Time::timestep) is 64 hertz, or 15625\n microseconds. This value was chosen because using 60 hertz has the potential\n for a pathological interaction with the monitor refresh rate where the game\n alternates between running two fixed timesteps and zero fixed timesteps per\n frame (for example when running two fixed timesteps takes longer than a\n frame). Additionally, the value is a power of two which losslessly converts\n into [`f32`] and [`f64`].\n\n To run a system on a fixed timestep, add it to one of the [`FixedMain`]\n schedules, most commonly [`FixedUpdate`](bevy_app::FixedUpdate).\n\n This schedule is run a number of times between\n [`PreUpdate`](bevy_app::PreUpdate) and [`Update`](bevy_app::Update)\n according to the accumulated [`overstep()`](Time::overstep) time divided by\n the [`timestep()`](Time::timestep). This means the schedule may run 0, 1 or\n more times during a single update (which typically corresponds to a rendered\n frame).\n\n `Time<Fixed>` and the generic [`Time`] resource will report a\n [`delta()`](Time::delta) equal to [`timestep()`](Time::timestep) and always\n grow [`elapsed()`](Time::elapsed) by one [`timestep()`](Time::timestep) per\n iteration.\n\n The fixed timestep clock follows the [`Time<Virtual>`](Virtual) clock, which\n means it is affected by [`pause()`](Time::pause),\n [`set_relative_speed()`](Time::set_relative_speed) and\n [`set_max_delta()`](Time::set_max_delta) from virtual time. If the virtual\n clock is paused, the [`FixedUpdate`](bevy_app::FixedUpdate) schedule will\n not run. It is guaranteed that the [`elapsed()`](Time::elapsed) time in\n `Time<Fixed>` is always between the previous `elapsed()` and the current\n `elapsed()` value in `Time<Virtual>`, so the values are compatible.\n\n Changing the timestep size while the game is running should not normally be\n done, as having a regular interval is the point of this schedule, but it may\n be necessary for effects like \"bullet-time\" if the normal granularity of the\n fixed timestep is too big for the slowed down time. In this case,\n [`set_timestep()`](Time::set_timestep) and be called to set a new value. The\n new value will be used immediately for the next run of the\n [`FixedUpdate`](bevy_app::FixedUpdate) schedule, meaning that it will affect\n the [`delta()`](Time::delta) value for the very next\n [`FixedUpdate`](bevy_app::FixedUpdate), even if it is still during the same\n frame. Any [`overstep()`](Time::overstep) present in the accumulator will be\n processed according to the new [`timestep()`](Time::timestep) value.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_gltf::GltfNode>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_gltf::GltfNode>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_gltf::GltfNode>",
        "short_type_path": "Handle<GltfNode>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_gltf::GltfNode>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::texture_slice::slicer::TextureSlicer": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "border",
            "type_path": "bevy_sprite::texture_slice::border_rect::BorderRect",
            "docs": " The sprite borders, defining the 9 sections of the image"
          },
          {
            "name": "center_scale_mode",
            "type_path": "bevy_sprite::texture_slice::slicer::SliceScaleMode",
            "docs": " Defines how the center part of the 9 slices will scale"
          },
          {
            "name": "sides_scale_mode",
            "type_path": "bevy_sprite::texture_slice::slicer::SliceScaleMode",
            "docs": " Defines how the 4 side parts of the 9 slices will scale"
          },
          {
            "name": "max_corner_scale",
            "type_path": "f32",
            "docs": " Defines the maximum scale of the 4 corner slices (default to `1.0`)"
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::texture_slice::slicer::TextureSlicer",
        "short_type_path": "TextureSlicer",
        "ident": "TextureSlicer",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::texture_slice::slicer"
      },
      "default": null,
      "docs": " Slices a texture using the **9-slicing** technique. This allows to reuse an image at various sizes\n without needing to prepare multiple assets. The associated texture will be split into nine portions,\n so that on resize the different portions scale or tile in different ways to keep the texture in proportion.\n\n For example, when resizing a 9-sliced texture the corners will remain unscaled while the other\n sections will be scaled or tiled.\n\n See [9-sliced](https://en.wikipedia.org/wiki/9-slice_scaling) textures.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "enabled",
            "type_path": "bool",
            "docs": " Enable or disable sharpening."
          },
          {
            "name": "sharpening_strength",
            "type_path": "f32",
            "docs": " Adjusts sharpening strength. Higher values increase the amount of sharpening.\n\n Clamped between 0.0 and 1.0.\n\n The default value is 0.6."
          },
          {
            "name": "denoise",
            "type_path": "bool",
            "docs": " Whether to try and avoid sharpening areas that are already noisy.\n\n You probably shouldn't use this, and just leave it set to false.\n You should generally apply any sort of film grain or similar effects after CAS\n and upscaling to avoid artifacts."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening",
        "short_type_path": "ContrastAdaptiveSharpening",
        "ident": "ContrastAdaptiveSharpening",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::contrast_adaptive_sharpening"
      },
      "default": "{\"bevy_core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpening\":{\"enabled\":true,\"sharpening_strength\":0.6,\"denoise\":false}}",
      "docs": " Applies a contrast adaptive sharpening (CAS) filter to the camera.\n\n CAS is usually used in combination with shader based anti-aliasing methods\n such as FXAA or TAA to regain some of the lost detail from the blurring that they introduce.\n\n CAS is designed to adjust the amount of sharpening applied to different areas of an image\n based on the local contrast. This can help avoid over-sharpening areas with high contrast\n and under-sharpening areas with low contrast.\n\n To use this, add the [`ContrastAdaptiveSharpening`] component to a 2D or 3D camera.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_mesh::morph::MeshMorphWeights": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "weights",
            "type_path": "alloc::vec::Vec<f32>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_mesh::morph::MeshMorphWeights",
        "short_type_path": "MeshMorphWeights",
        "ident": "MeshMorphWeights",
        "crate_name": "bevy_mesh",
        "module_path": "bevy_mesh::morph"
      },
      "default": "{\"bevy_mesh::morph::MeshMorphWeights\":{\"weights\":[]}}",
      "docs": " Control a specific [`Mesh`] instance's [morph targets]. These control the weights of\n specific \"mesh primitives\" in scene formats like GLTF. They can be set manually, but\n in most cases they should \"automatically\" synced by setting the [`MorphWeights`] component\n on a parent entity.\n\n See [`MorphWeights`] for more details on Bevy's morph target implementation.\n\n Add this to an [`Entity`] with a `Mesh3d` with a [`MorphAttributes`] set\n to control individual weights of each morph target.\n\n [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "core::option::Option<glam::Vec3>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "glam::Vec3",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<glam::Vec3>",
        "short_type_path": "Option<Vec3>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_gizmos::LineGizmo>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_gizmos::LineGizmo>",
        "short_type_path": "AssetId<LineGizmo>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_image::image::Image>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_image::image::Image>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
        "short_type_path": "Handle<Image>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_image::image::Image>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "f32": {
      "info": {
        "kind": "opaque",
        "item_type_path": "f32"
      },
      "path_table": {
        "path": "f32",
        "short_type_path": "f32",
        "ident": "f32",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"f32\":0.0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::fxaa::Fxaa": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "enabled",
            "type_path": "bool",
            "docs": " Enable render passes for FXAA."
          },
          {
            "name": "edge_threshold",
            "type_path": "bevy_core_pipeline::fxaa::Sensitivity",
            "docs": " Use lower sensitivity for a sharper, faster, result.\n Use higher sensitivity for a slower, smoother, result.\n [`Ultra`](`Sensitivity::Ultra`) and [`Extreme`](`Sensitivity::Extreme`)\n settings can result in significant smearing and loss of detail.\n\n The minimum amount of local contrast required to apply algorithm."
          },
          {
            "name": "edge_threshold_min",
            "type_path": "bevy_core_pipeline::fxaa::Sensitivity",
            "docs": " Trims the algorithm from processing darks."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::fxaa::Fxaa",
        "short_type_path": "Fxaa",
        "ident": "Fxaa",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::fxaa"
      },
      "default": "{\"bevy_core_pipeline::fxaa::Fxaa\":{\"enabled\":true,\"edge_threshold\":\"High\",\"edge_threshold_min\":\"High\"}}",
      "docs": " A component for enabling Fast Approximate Anti-Aliasing (FXAA)\n for a [`bevy_render::camera::Camera`].",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_core_pipeline::dof::DepthOfField": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "mode",
            "type_path": "bevy_core_pipeline::dof::DepthOfFieldMode",
            "docs": " The appearance of the effect."
          },
          {
            "name": "focal_distance",
            "type_path": "f32",
            "docs": " The distance in meters to the location in focus."
          },
          {
            "name": "sensor_height",
            "type_path": "f32",
            "docs": " The height of the [image sensor format] in meters.\n\n Focal length is derived from the FOV and this value. The default is\n 18.66mm, matching the [Super 35] format, which is popular in cinema.\n\n [image sensor format]: https://en.wikipedia.org/wiki/Image_sensor_format\n\n [Super 35]: https://en.wikipedia.org/wiki/Super_35"
          },
          {
            "name": "aperture_f_stops",
            "type_path": "f32",
            "docs": " Along with the focal length, controls how much objects not in focus are\n blurred."
          },
          {
            "name": "max_circle_of_confusion_diameter",
            "type_path": "f32",
            "docs": " The maximum diameter, in pixels, that we allow a circle of confusion to be.\n\n A circle of confusion essentially describes the size of a blur.\n\n This value is nonphysical but is useful for avoiding pathologically-slow\n behavior."
          },
          {
            "name": "max_depth",
            "type_path": "f32",
            "docs": " Objects are never considered to be farther away than this distance as\n far as depth of field is concerned, even if they actually are.\n\n This is primarily useful for skyboxes and background colors. The Bevy\n renderer considers them to be infinitely far away. Without this value,\n that would cause the circle of confusion to be infinitely large, capped\n only by the `max_circle_of_confusion_diameter`. As that's unsightly,\n this value can be used to essentially adjust how \"far away\" the skybox\n or background are."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::dof::DepthOfField",
        "short_type_path": "DepthOfField",
        "ident": "DepthOfField",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::dof"
      },
      "default": "{\"bevy_core_pipeline::dof::DepthOfField\":{\"mode\":\"Bokeh\",\"focal_distance\":10.0,\"sensor_height\":0.01866,\"aperture_f_stops\":1.0,\"max_circle_of_confusion_diameter\":64.0,\"max_depth\":null}}",
      "docs": " A component that enables a [depth of field] postprocessing effect when attached to a [`Camera3d`],\n simulating the focus of a camera lens.\n\n [depth of field]: https://en.wikipedia.org/wiki/Depth_of_field",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::Outline": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "width",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The width of the outline.\n\n Percentage `Val` values are resolved based on the width of the outlined [`Node`]."
          },
          {
            "name": "offset",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The amount of space between a node's outline the edge of the node.\n\n Percentage `Val` values are resolved based on the width of the outlined [`Node`]."
          },
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": " The color of the outline.\n\n If you are frequently toggling outlines for a UI node on and off it is recommended to set [`Color::NONE`] to hide the outline.\n This avoids the table moves that would occur from the repeated insertion and removal of the `Outline` component."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::Outline",
        "short_type_path": "Outline",
        "ident": "Outline",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::Outline\":{\"width\":\"Auto\",\"offset\":\"Auto\",\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}}}}",
      "docs": " The [`Outline`] component adds an outline outside the edge of a UI node.\n Outlines do not take up space in the layout.\n\n To add an [`Outline`] to a ui node you can spawn a `(Node, Outline)` tuple bundle:\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_ui::prelude::*;\n # use bevy_color::palettes::basic::{RED, BLUE};\n fn setup_ui(mut commands: Commands) {\n     commands.spawn((\n         Node {\n             width: Val::Px(100.),\n             height: Val::Px(100.),\n             ..Default::default()\n         },\n         BackgroundColor(BLUE.into()),\n         Outline::new(Val::Px(10.), Val::ZERO, RED.into())\n     ));\n }\n ```\n\n [`Outline`] components can also be added later to existing UI nodes:\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_ui::prelude::*;\n # use bevy_color::Color;\n fn outline_hovered_button_system(\n     mut commands: Commands,\n     mut node_query: Query<(Entity, &Interaction, Option<&mut Outline>), Changed<Interaction>>,\n ) {\n     for (entity, interaction, mut maybe_outline) in node_query.iter_mut() {\n         let outline_color =\n             if matches!(*interaction, Interaction::Hovered) {\n                 Color::WHITE\n             } else {\n                 Color::NONE\n             };\n         if let Some(mut outline) = maybe_outline {\n             outline.color = outline_color;\n         } else {\n             commands.entity(entity).insert(Outline::new(Val::Px(10.), Val::ZERO, outline_color));\n         }\n     }\n }\n ```\n Inserting and removing an [`Outline`] component repeatedly will result in table moves, so it is generally preferable to\n set `Outline::color` to [`Color::NONE`] to hide an outline.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_scene::scene::Scene>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_scene::scene::Scene>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_scene::scene::Scene>",
        "short_type_path": "Handle<Scene>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_scene::scene::Scene>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::texture_atlas::TextureAtlasLayout": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "size",
            "type_path": "glam::UVec2",
            "docs": " Total size of texture atlas."
          },
          {
            "name": "textures",
            "type_path": "alloc::vec::Vec<bevy_math::rects::urect::URect>",
            "docs": " The specific areas of the atlas where each texture can be found"
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::texture_atlas::TextureAtlasLayout",
        "short_type_path": "TextureAtlasLayout",
        "ident": "TextureAtlasLayout",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::texture_atlas"
      },
      "default": null,
      "docs": " Stores a map used to lookup the position of a texture in a [`TextureAtlas`].\n This can be used to either use and look up a specific section of a texture, or animate frame-by-frame as a sprite sheet.\n\n Optionally it can store a mapping from sub texture handles to the related area index (see\n [`TextureAtlasBuilder`]).\n\n [Example usage animating sprite.](https://github.com/bevyengine/bevy/blob/latest/examples/2d/sprite_sheet.rs)\n [Example usage animating sprite in response to an event.](https://github.com/bevyengine/bevy/blob/latest/examples/2d/sprite_animation.rs)\n [Example usage loading sprite sheet.](https://github.com/bevyengine/bevy/blob/latest/examples/2d/texture_atlas.rs)\n\n [`TextureAtlasBuilder`]: crate::TextureAtlasBuilder",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::AnimationPlayer": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "active_animations",
            "type_path": "bevy_utils::hashbrown::HashMap<petgraph::graph::NodeIndex, bevy_animation::ActiveAnimation, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
            "docs": null
          },
          {
            "name": "blend_weights",
            "type_path": "bevy_utils::hashbrown::HashMap<petgraph::graph::NodeIndex, f32, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::AnimationPlayer",
        "short_type_path": "AnimationPlayer",
        "ident": "AnimationPlayer",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": "{\"bevy_animation::AnimationPlayer\":{\"active_animations\":{},\"blend_weights\":{}}}",
      "docs": " Animation controls.\n\n Automatically added to any root animations of a scene when it is\n spawned.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::ResolvedBorderRadius": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "top_left",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "top_right",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "bottom_left",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "bottom_right",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::ResolvedBorderRadius",
        "short_type_path": "ResolvedBorderRadius",
        "ident": "ResolvedBorderRadius",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": null,
      "docs": " Represents the resolved border radius values for a UI node.\n\n The values are in physical pixels.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::mesh_material::MeshMaterial3d<bevy_pbr::pbr_material::StandardMaterial>": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_asset::handle::Handle<bevy_pbr::pbr_material::StandardMaterial>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::mesh_material::MeshMaterial3d<bevy_pbr::pbr_material::StandardMaterial>",
        "short_type_path": "MeshMaterial3d<StandardMaterial>",
        "ident": "MeshMaterial3d",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::mesh_material"
      },
      "default": "{\"bevy_pbr::mesh_material::MeshMaterial3d<bevy_pbr::pbr_material::StandardMaterial>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A [material](Material) used for rendering a [`Mesh3d`].\n\n See [`Material`] for general information about 3D materials and how to implement your own materials.\n\n [`Mesh3d`]: bevy_render::mesh::Mesh3d\n\n # Example\n\n ```\n # use bevy_pbr::{Material, MeshMaterial3d, StandardMaterial};\n # use bevy_ecs::prelude::*;\n # use bevy_render::mesh::{Mesh, Mesh3d};\n # use bevy_color::palettes::basic::RED;\n # use bevy_asset::Assets;\n # use bevy_math::primitives::Capsule3d;\n #\n // Spawn an entity with a mesh using `StandardMaterial`.\n fn setup(\n     mut commands: Commands,\n     mut meshes: ResMut<Assets<Mesh>>,\n     mut materials: ResMut<Assets<StandardMaterial>>,\n ) {\n     commands.spawn((\n         Mesh3d(meshes.add(Capsule3d::default())),\n         MeshMaterial3d(materials.add(StandardMaterial {\n             base_color: RED.into(),\n             ..Default::default()\n         })),\n     ));\n }\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::GridPlacement": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "start",
            "type_path": "core::option::Option<core::num::NonZeroI16>",
            "docs": " The grid line at which the item should start.\n Lines are 1-indexed.\n Negative indexes count backwards from the end of the grid.\n Zero is not a valid index."
          },
          {
            "name": "span",
            "type_path": "core::option::Option<core::num::NonZeroU16>",
            "docs": " How many grid tracks the item should span.\n Defaults to 1."
          },
          {
            "name": "end",
            "type_path": "core::option::Option<core::num::NonZeroI16>",
            "docs": " The grid line at which the item should end.\n Lines are 1-indexed.\n Negative indexes count backwards from the end of the grid.\n Zero is not a valid index."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::GridPlacement",
        "short_type_path": "GridPlacement",
        "ident": "GridPlacement",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::GridPlacement\":{\"start\":null,\"span\":1,\"end\":null}}",
      "docs": " Represents the position of a grid item in a single axis.\n\n There are 3 fields which may be set:\n   - `start`: which grid line the item should start at\n   - `end`: which grid line the item should end at\n   - `span`: how many tracks the item should span\n\n The default `span` is 1. If neither `start` or `end` is set then the item will be placed automatically.\n\n Generally, at most two fields should be set. If all three fields are specified then `span` will be ignored. If `end` specifies an earlier\n grid line than `start` then `end` will be ignored and the item will have a span of 1.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_core::render::block_app_ready::AssetLoadBlockAppReady": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevyhub_core::render::block_app_ready::AssetLoadBlockAppReady",
        "short_type_path": "AssetLoadBlockAppReady",
        "ident": "AssetLoadBlockAppReady",
        "crate_name": "bevyhub_core",
        "module_path": "bevyhub_core::render::block_app_ready"
      },
      "default": null,
      "docs": " Add this component alongside an asset handle to block the [`AppReady`] event from being triggered.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "i8": {
      "info": {
        "kind": "opaque",
        "item_type_path": "i8"
      },
      "path_table": {
        "path": "i8",
        "short_type_path": "i8",
        "ident": "i8",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"i8\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_asset::assets::LoadedUntypedAsset>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_asset::assets::LoadedUntypedAsset>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_asset::assets::LoadedUntypedAsset>",
        "short_type_path": "Handle<LoadedUntypedAsset>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_asset::assets::LoadedUntypedAsset>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<u64>": {
      "info": {
        "kind": "list",
        "item_type_path": "u64"
      },
      "path_table": {
        "path": "alloc::vec::Vec<u64>",
        "short_type_path": "Vec<u64>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core::name::Name": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "hash",
            "type_path": "u64",
            "docs": null
          },
          {
            "name": "name",
            "type_path": "alloc::borrow::Cow<str>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_core::name::Name",
        "short_type_path": "Name",
        "ident": "Name",
        "crate_name": "bevy_core",
        "module_path": "bevy_core::name"
      },
      "default": "{\"bevy_core::name::Name\":\"\"}",
      "docs": " Component used to identify an entity. Stores a hash for faster comparisons.\n\n The hash is eagerly re-computed upon each update to the name.\n\n [`Name`] should not be treated as a globally unique identifier for entities,\n as multiple entities can have the same name.  [`Entity`] should be\n used instead as the default unique identifier.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_utils::hashbrown::HashMap<petgraph::graph::NodeIndex, bevy_animation::ActiveAnimation, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>": {
      "info": {
        "kind": "map",
        "key_type_path": "petgraph::graph::NodeIndex",
        "value_type_path": "bevy_animation::ActiveAnimation"
      },
      "path_table": {
        "path": "bevy_utils::hashbrown::HashMap<petgraph::graph::NodeIndex, bevy_animation::ActiveAnimation, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
        "short_type_path": "HashMap<NodeIndex, ActiveAnimation, DefaultHashBuilder>",
        "ident": "HashMap",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils::hashbrown"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::camera::CameraMainTextureUsages": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_render::camera::camera::CameraMainTextureUsages"
      },
      "path_table": {
        "path": "bevy_render::camera::camera::CameraMainTextureUsages",
        "short_type_path": "CameraMainTextureUsages",
        "ident": "CameraMainTextureUsages",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": null,
      "docs": " This component lets you control the [`TextureUsages`] field of the main texture generated for the camera",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "i32": {
      "info": {
        "kind": "opaque",
        "item_type_path": "i32"
      },
      "path_table": {
        "path": "i32",
        "short_type_path": "i32",
        "ident": "i32",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"i32\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::text::TextSpan": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::TextSpan",
        "short_type_path": "TextSpan",
        "ident": "TextSpan",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": "{\"bevy_text::text::TextSpan\":\"\"}",
      "docs": " A span of UI text in a tree of spans under an entity with [`TextLayout`] and `Text` or `Text2d`.\n\n Spans are collected in hierarchy traversal order into a [`ComputedTextBlock`] for layout.\n\n ```\n # use bevy_asset::Handle;\n # use bevy_color::Color;\n # use bevy_color::palettes::basic::{RED, BLUE};\n # use bevy_ecs::world::World;\n # use bevy_text::{Font, TextLayout, TextFont, TextSpan, TextColor};\n # use bevy_hierarchy::BuildChildren;\n\n # let font_handle: Handle<Font> = Default::default();\n # let mut world = World::default();\n #\n world.spawn((\n     TextLayout::default(),\n     TextFont {\n         font: font_handle.clone().into(),\n         font_size: 60.0,\n         ..Default::default()\n     },\n     TextColor(BLUE.into()),\n ))\n .with_child((\n     TextSpan::new(\"Hello!\"),\n     TextFont {\n         font: font_handle.into(),\n         font_size: 60.0,\n         ..Default::default()\n     },\n     TextColor(RED.into()),\n ));\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_gltf::Gltf>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_gltf::Gltf>",
        "short_type_path": "AssetId<Gltf>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<core::num::NonZeroU16>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "core::num::NonZeroU16",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<core::num::NonZeroU16>",
        "short_type_path": "Option<NonZeroU16>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevyhub_scene::utils::animation_graph_placeholder::AnimationClipPlaceholder>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevyhub_scene::utils::animation_graph_placeholder::AnimationClipPlaceholder"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevyhub_scene::utils::animation_graph_placeholder::AnimationClipPlaceholder>",
        "short_type_path": "Vec<AnimationClipPlaceholder>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gltf::GltfMaterialExtras": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "value",
            "type_path": "alloc::string::String",
            "docs": " Content of the extra data."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gltf::GltfMaterialExtras",
        "short_type_path": "GltfMaterialExtras",
        "ident": "GltfMaterialExtras",
        "crate_name": "bevy_gltf",
        "module_path": "bevy_gltf"
      },
      "default": "{\"bevy_gltf::GltfMaterialExtras\":{\"value\":\"\"}}",
      "docs": " Additional untyped data that can be present on most glTF types at the material level.\n\n See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "u128": {
      "info": {
        "kind": "opaque",
        "item_type_path": "u128"
      },
      "path_table": {
        "path": "u128",
        "short_type_path": "u128",
        "ident": "u128",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"u128\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::OverflowClipMargin": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "visual_box",
            "type_path": "bevy_ui::ui_node::OverflowClipBox",
            "docs": " Visible unclipped area"
          },
          {
            "name": "margin",
            "type_path": "f32",
            "docs": " Width of the margin on each edge of the visual box in logical pixels.\n The width of the margin will be zero if a negative value is set."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::OverflowClipMargin",
        "short_type_path": "OverflowClipMargin",
        "ident": "OverflowClipMargin",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::OverflowClipMargin\":{\"visual_box\":\"ContentBox\",\"margin\":0.0}}",
      "docs": " The bounds of the visible area when a UI node is clipped.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevy_ui::ui_node::GridTrack>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_ui::ui_node::GridTrack"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_ui::ui_node::GridTrack>",
        "short_type_path": "Vec<GridTrack>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_mesh::mesh::Mesh>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "path",
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_mesh::mesh::Mesh>",
        "short_type_path": "AssetPlaceholder<Mesh>",
        "ident": "AssetPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::asset_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "core::option::Option<bevy_sprite::texture_atlas::TextureAtlas>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_sprite::texture_atlas::TextureAtlas",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_sprite::texture_atlas::TextureAtlas>",
        "short_type_path": "Option<TextureAtlas>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::string::String": {
      "info": {
        "kind": "opaque",
        "item_type_path": "alloc::string::String"
      },
      "path_table": {
        "path": "alloc::string::String",
        "short_type_path": "String",
        "ident": "String",
        "crate_name": "alloc",
        "module_path": "alloc::string"
      },
      "default": "{\"alloc::string::String\":\"\"}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::RepeatedGridTrack": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "repetition",
            "type_path": "bevy_ui::ui_node::GridTrackRepetition",
            "docs": null
          },
          {
            "name": "tracks",
            "type_path": "smallvec::SmallVec<[bevy_ui::ui_node::GridTrack; 1]>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::RepeatedGridTrack",
        "short_type_path": "RepeatedGridTrack",
        "ident": "RepeatedGridTrack",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::RepeatedGridTrack\":{\"repetition\":{\"Count\":1},\"tracks\":[{\"min_sizing_function\":\"Auto\",\"max_sizing_function\":\"Auto\"}]}}",
      "docs": " Represents a *possibly* repeated [`GridTrack`].\n\n The repetition parameter can either be:\n   - The integer `1`, in which case the track is non-repeated.\n   - a `u16` count to repeat the track N times.\n   - A `GridTrackRepetition::AutoFit` or `GridTrackRepetition::AutoFill`.\n\n Note: that in the common case you want a non-repeating track (repetition count 1), you may use the constructor methods on [`GridTrack`]\n to create a `RepeatedGridTrack`. i.e. `GridTrack::px(10.0)` is equivalent to `RepeatedGridTrack::px(1, 10.0)`.\n\n You may only use one auto-repetition per track list. And if your track list contains an auto repetition\n then all tracks (in and outside of the repetition) must be fixed size (px or percent). Integer repetitions are just shorthand for writing out\n N tracks longhand and are not subject to the same limitations.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::core_2d::camera_2d::Camera2d": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_core_pipeline::core_2d::camera_2d::Camera2d",
        "short_type_path": "Camera2d",
        "ident": "Camera2d",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::core_2d::camera_2d"
      },
      "default": "{\"bevy_core_pipeline::core_2d::camera_2d::Camera2d\":{}}",
      "docs": " A 2D camera component. Enables the 2D render graph for a [`Camera`].",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_scene::dynamic_scene::DynamicScene>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_scene::dynamic_scene::DynamicScene>",
        "short_type_path": "AssetId<DynamicScene>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_audio::audio::DefaultSpatialScale": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_audio::audio::SpatialScale",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_audio::audio::DefaultSpatialScale",
        "short_type_path": "DefaultSpatialScale",
        "ident": "DefaultSpatialScale",
        "crate_name": "bevy_audio",
        "module_path": "bevy_audio::audio"
      },
      "default": "{\"bevy_audio::audio::DefaultSpatialScale\":[1.0,1.0,1.0]}",
      "docs": " The default scale factor applied to the positions of audio sources and listeners for\n spatial audio. Can be overridden for individual sounds in [`PlaybackSettings`].\n\n You may need to adjust this scale to fit your world's units.\n\n Default is `Vec3::ONE`.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "core::option::Option<bevy_audio::audio::SpatialScale>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_audio::audio::SpatialScale",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_audio::audio::SpatialScale>",
        "short_type_path": "Option<SpatialScale>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::post_process::ChromaticAberration": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color_lut",
            "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
            "docs": " The lookup texture that determines the color gradient.\n\n By default, this is a 3×1 texel texture consisting of one red pixel, one\n green pixel, and one blue texel, in that order. This recreates the most\n typical chromatic aberration pattern. However, you can change it to\n achieve different artistic effects.\n\n The texture is always sampled in its vertical center, so it should\n ordinarily have a height of 1 texel."
          },
          {
            "name": "intensity",
            "type_path": "f32",
            "docs": " The size of the streaks around the edges of objects, as a fraction of\n the window size.\n\n The default value is 0.2."
          },
          {
            "name": "max_samples",
            "type_path": "u32",
            "docs": " A cap on the number of texture samples that will be performed.\n\n Higher values result in smoother-looking streaks but are slower.\n\n The default value is 8."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::post_process::ChromaticAberration",
        "short_type_path": "ChromaticAberration",
        "ident": "ChromaticAberration",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::post_process"
      },
      "default": "{\"bevy_core_pipeline::post_process::ChromaticAberration\":{\"color_lut\":{\"Weak\":{\"Uuid\":{\"uuid\":\"00000000-0000-0000-1e87-dfbf2a61d66c\"}}},\"intensity\":0.02,\"max_samples\":8}}",
      "docs": " Adds colored fringes to the edges of objects in the scene.\n\n [Chromatic aberration] simulates the effect when lenses fail to focus all\n colors of light toward a single point. It causes rainbow-colored streaks to\n appear, which are especially apparent on the edges of objects. Chromatic\n aberration is commonly used for collision effects, especially in horror\n games.\n\n Bevy's implementation is based on that of *Inside* ([Gjøl & Svendsen 2016]).\n It's based on a customizable lookup texture, which allows for changing the\n color pattern. By default, the color pattern is simply a 3×1 pixel texture\n consisting of red, green, and blue, in that order, but you can change it to\n any image in order to achieve different effects.\n\n [Chromatic aberration]: https://en.wikipedia.org/wiki/Chromatic_aberration\n\n [Gjøl & Svendsen 2016]: https://github.com/playdeadgames/publications/blob/master/INSIDE/rendering_inside_gdc2016.pdf",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_audio::audio::GlobalVolume": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "volume",
            "type_path": "bevy_audio::audio::Volume",
            "docs": " The global volume of all audio."
          }
        ]
      },
      "path_table": {
        "path": "bevy_audio::audio::GlobalVolume",
        "short_type_path": "GlobalVolume",
        "ident": "GlobalVolume",
        "crate_name": "bevy_audio",
        "module_path": "bevy_audio::audio"
      },
      "default": "{\"bevy_audio::audio::GlobalVolume\":{\"volume\":1.0}}",
      "docs": " Use this [`Resource`] to control the global volume of all audio.\n\n Note: changing this value will not affect already playing audio.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevyhub_scene::utils::animation_graph_placeholder::AnimationClipPlaceholder": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "clip",
            "type_path": "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_animation::AnimationClip>",
            "docs": null
          },
          {
            "name": "parent",
            "type_path": "petgraph::graph::NodeIndex",
            "docs": null
          },
          {
            "name": "weight",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::animation_graph_placeholder::AnimationClipPlaceholder",
        "short_type_path": "AnimationClipPlaceholder",
        "ident": "AnimationClipPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::animation_graph_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "f64": {
      "info": {
        "kind": "opaque",
        "item_type_path": "f64"
      },
      "path_table": {
        "path": "f64",
        "short_type_path": "f64",
        "ident": "f64",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"f64\":0.0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::JustifyContent": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Default",
            "docs": " The items are packed in their default position as if no alignment was applied."
          },
          {
            "kind": "unit",
            "name": "Start",
            "docs": " The items are packed towards the start of the axis."
          },
          {
            "kind": "unit",
            "name": "End",
            "docs": " The items are packed towards the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexStart",
            "docs": " The items are packed towards the start of the axis, unless the flex direction is reversed;\n then the items are packed towards the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexEnd",
            "docs": " The items are packed towards the end of the axis, unless the flex direction is reversed;\n then the items are packed towards the start of the axis."
          },
          {
            "kind": "unit",
            "name": "Center",
            "docs": " The items are packed along the center of the axis."
          },
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " The items are stretched to fill the container along the axis."
          },
          {
            "kind": "unit",
            "name": "SpaceBetween",
            "docs": " The items are distributed such that the gap between any two items is equal."
          },
          {
            "kind": "unit",
            "name": "SpaceEvenly",
            "docs": " The items are distributed such that the gap between and around any two items is equal."
          },
          {
            "kind": "unit",
            "name": "SpaceAround",
            "docs": " The items are distributed such that the gap between and around any two items is equal, with half-size gaps on either end."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::JustifyContent",
        "short_type_path": "JustifyContent",
        "ident": "JustifyContent",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::JustifyContent\":\"Default\"}",
      "docs": " Used to control how items are distributed.\n - For Flexbox containers, controls alignment of items in the main axis.\n - For CSS Grid containers, controls alignment of grid columns.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "isize": {
      "info": {
        "kind": "opaque",
        "item_type_path": "isize"
      },
      "path_table": {
        "path": "isize",
        "short_type_path": "isize",
        "ident": "isize",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"isize\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gizmos::config::GizmoConfigStore": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_gizmos::config::GizmoConfigStore",
        "short_type_path": "GizmoConfigStore",
        "ident": "GizmoConfigStore",
        "crate_name": "bevy_gizmos",
        "module_path": "bevy_gizmos::config"
      },
      "default": "{\"bevy_gizmos::config::GizmoConfigStore\":{}}",
      "docs": " A [`Resource`] storing [`GizmoConfig`] and [`GizmoConfigGroup`] structs\n\n Use `app.init_gizmo_group::<T>()` to register a custom config group.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_pbr::light::directional_light::DirectionalLight": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": " The color of the light.\n\n By default, this is white."
          },
          {
            "name": "illuminance",
            "type_path": "f32",
            "docs": " Illuminance in lux (lumens per square meter), representing the amount of\n light projected onto surfaces by this light source. Lux is used here\n instead of lumens because a directional light illuminates all surfaces\n more-or-less the same way (depending on the angle of incidence). Lumens\n can only be specified for light sources which emit light from a specific\n area."
          },
          {
            "name": "shadows_enabled",
            "type_path": "bool",
            "docs": " Whether this light casts shadows.\n\n Note that shadows are rather expensive and become more so with every\n light that casts them. In general, it's best to aggressively limit the\n number of lights with shadows enabled to one or two at most."
          },
          {
            "name": "shadow_depth_bias",
            "type_path": "f32",
            "docs": " A value that adjusts the tradeoff between self-shadowing artifacts and\n proximity of shadows to their casters.\n\n This value frequently must be tuned to the specific scene; this is\n normal and a well-known part of the shadow mapping workflow. If set too\n low, unsightly shadow patterns appear on objects not in shadow as\n objects incorrectly cast shadows on themselves, known as *shadow acne*.\n If set too high, shadows detach from the objects casting them and seem\n to \"fly\" off the objects, known as *Peter Panning*."
          },
          {
            "name": "shadow_normal_bias",
            "type_path": "f32",
            "docs": " A bias applied along the direction of the fragment's surface normal. It\n is scaled to the shadow map's texel size so that it is automatically\n adjusted to the orthographic projection."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::directional_light::DirectionalLight",
        "short_type_path": "DirectionalLight",
        "ident": "DirectionalLight",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light::directional_light"
      },
      "default": "{\"bevy_pbr::light::directional_light::DirectionalLight\":{\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"illuminance\":10000.0,\"shadows_enabled\":false,\"shadow_depth_bias\":0.02,\"shadow_normal_bias\":1.8}}",
      "docs": " A Directional light.\n\n Directional lights don't exist in reality but they are a good\n approximation for light sources VERY far away, like the sun or\n the moon.\n\n The light shines along the forward direction of the entity's transform. With a default transform\n this would be along the negative-Z axis.\n\n Valid values for `illuminance` are:\n\n | Illuminance (lux) | Surfaces illuminated by                        |\n |-------------------|------------------------------------------------|\n | 0.0001            | Moonless, overcast night sky (starlight)       |\n | 0.002             | Moonless clear night sky with airglow          |\n | 0.05–0.3          | Full moon on a clear night                     |\n | 3.4               | Dark limit of civil twilight under a clear sky |\n | 20–50             | Public areas with dark surroundings            |\n | 50                | Family living room lights                      |\n | 80                | Office building hallway/toilet lighting        |\n | 100               | Very dark overcast day                         |\n | 150               | Train station platforms                        |\n | 320–500           | Office lighting                                |\n | 400               | Sunrise or sunset on a clear day.              |\n | 1000              | Overcast day; typical TV studio lighting       |\n | 10,000–25,000     | Full daylight (not direct sun)                 |\n | 32,000–100,000    | Direct sunlight                                |\n\n Source: [Wikipedia](https://en.wikipedia.org/wiki/Lux)\n\n ## Shadows\n\n To enable shadows, set the `shadows_enabled` property to `true`.\n\n Shadows are produced via [cascaded shadow maps](https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf).\n\n To modify the cascade setup, such as the number of cascades or the maximum shadow distance,\n change the [`CascadeShadowConfig`] component of the entity with the [`DirectionalLight`].\n\n To control the resolution of the shadow maps, use the [`DirectionalLightShadowMap`] resource:\n\n ```\n # use bevy_app::prelude::*;\n # use bevy_pbr::DirectionalLightShadowMap;\n App::new()\n     .insert_resource(DirectionalLightShadowMap { size: 2048 });\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::camera::camera::SubCameraView": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "full_size",
            "type_path": "glam::UVec2",
            "docs": " Size of the entire camera view"
          },
          {
            "name": "offset",
            "type_path": "glam::Vec2",
            "docs": " Offset of the sub camera"
          },
          {
            "name": "size",
            "type_path": "glam::UVec2",
            "docs": " Size of the sub camera"
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::camera::SubCameraView",
        "short_type_path": "SubCameraView",
        "ident": "SubCameraView",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": null,
      "docs": " Settings to define a camera sub view.\n\n When [`Camera::sub_camera_view`] is `Some`, only the sub-section of the\n image defined by `size` and `offset` (relative to the `full_size` of the\n whole image) is projected to the cameras viewport.\n\n Take the example of the following multi-monitor setup:\n ```css\n ┌───┬───┐\n │ A │ B │\n ├───┼───┤\n │ C │ D │\n └───┴───┘\n ```\n If each monitor is 1920x1080, the whole image will have a resolution of\n 3840x2160. For each monitor we can use a single camera with a viewport of\n the same size as the monitor it corresponds to. To ensure that the image is\n cohesive, we can use a different sub view on each camera:\n - Camera A: `full_size` = 3840x2160, `size` = 1920x1080, `offset` = 0,0\n - Camera B: `full_size` = 3840x2160, `size` = 1920x1080, `offset` = 1920,0\n - Camera C: `full_size` = 3840x2160, `size` = 1920x1080, `offset` = 0,1080\n - Camera D: `full_size` = 3840x2160, `size` = 1920x1080, `offset` =\n   1920,1080\n\n However since only the ratio between the values is important, they could all\n be divided by 120 and still produce the same image. Camera D would for\n example have the following values:\n `full_size` = 32x18, `size` = 16x9, `offset` = 16,9",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::Vec2": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Vec2",
        "short_type_path": "Vec2",
        "ident": "Vec2",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Vec2\":[0.0,0.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::PositionType": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Relative",
            "docs": " Relative to all other nodes with the [`PositionType::Relative`] value."
          },
          {
            "kind": "unit",
            "name": "Absolute",
            "docs": " Independent of all other nodes, but relative to its parent node."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::PositionType",
        "short_type_path": "PositionType",
        "ident": "PositionType",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::PositionType\":\"Relative\"}",
      "docs": " The strategy used to position this node",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_math::primitives::dim3::Plane3d": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "normal",
            "type_path": "bevy_math::direction::Dir3",
            "docs": " The normal of the plane. The plane will be placed perpendicular to this direction"
          },
          {
            "name": "half_size",
            "type_path": "glam::Vec2",
            "docs": " Half of the width and height of the plane"
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::primitives::dim3::Plane3d",
        "short_type_path": "Plane3d",
        "ident": "Plane3d",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::primitives::dim3"
      },
      "default": "{\"bevy_math::primitives::dim3::Plane3d\":{\"normal\":[0.0,1.0,0.0],\"half_size\":[0.5,0.5]}}",
      "docs": " A bounded plane in 3D space. It forms a surface starting from the origin with a defined height and width.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::projection::ScalingMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "WindowSize",
            "docs": " Match the viewport size.\n\n With a scale of 1, lengths in world units will map 1:1 with the number of pixels used to render it.\n For example, if we have a 64x64 sprite with a [`Transform::scale`](bevy_transform::prelude::Transform) of 1.0,\n no custom size and no inherited scale, the sprite will be 64 world units wide and 64 world units tall.\n When rendered with [`OrthographicProjection::scaling_mode`] set to `WindowSize` when the window scale factor is 1\n the sprite will be rendered at 64 pixels wide and 64 pixels tall.\n\n Changing any of these properties will multiplicatively affect the final size."
          },
          {
            "kind": "struct",
            "name": "Fixed",
            "fields": [
              {
                "name": "width",
                "type_path": "f32",
                "docs": null
              },
              {
                "name": "height",
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Manually specify the projection's size, ignoring window resizing. The image will stretch.\n\n Arguments describe the area of the world that is shown (in world units)."
          },
          {
            "kind": "struct",
            "name": "AutoMin",
            "fields": [
              {
                "name": "min_width",
                "type_path": "f32",
                "docs": null
              },
              {
                "name": "min_height",
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Keeping the aspect ratio while the axes can't be smaller than given minimum.\n\n Arguments are in world units."
          },
          {
            "kind": "struct",
            "name": "AutoMax",
            "fields": [
              {
                "name": "max_width",
                "type_path": "f32",
                "docs": null
              },
              {
                "name": "max_height",
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Keeping the aspect ratio while the axes can't be bigger than given maximum.\n\n Arguments are in world units."
          },
          {
            "kind": "struct",
            "name": "FixedVertical",
            "fields": [
              {
                "name": "viewport_height",
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Keep the projection's height constant; width will be adjusted to match aspect ratio.\n\n The argument is the desired height of the projection in world units."
          },
          {
            "kind": "struct",
            "name": "FixedHorizontal",
            "fields": [
              {
                "name": "viewport_width",
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Keep the projection's width constant; height will be adjusted to match aspect ratio.\n\n The argument is the desired width of the projection in world units."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::projection::ScalingMode",
        "short_type_path": "ScalingMode",
        "ident": "ScalingMode",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::projection"
      },
      "default": null,
      "docs": " Scaling mode for [`OrthographicProjection`].\n\n The effect of these scaling modes are combined with the [`OrthographicProjection::scale`] property.\n\n For example, if the scaling mode is `ScalingMode::Fixed { width: 100.0, height: 300 }` and the scale is `2.0`,\n the projection will be 200 world units wide and 600 world units tall.\n\n # Examples\n\n Configure the orthographic projection to two world units per window height:\n\n ```\n # use bevy_render::camera::{OrthographicProjection, Projection, ScalingMode};\n let projection = Projection::Orthographic(OrthographicProjection {\n    scaling_mode: ScalingMode::FixedVertical { viewport_height: 2.0 },\n    ..OrthographicProjection::default_2d()\n });\n ```",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gizmos::config::GizmoConfig": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "enabled",
            "type_path": "bool",
            "docs": " Set to `false` to stop drawing gizmos.\n\n Defaults to `true`."
          },
          {
            "name": "line_width",
            "type_path": "f32",
            "docs": " Line width specified in pixels.\n\n If `line_perspective` is `true` then this is the size in pixels at the camera's near plane.\n\n Defaults to `2.0`."
          },
          {
            "name": "line_perspective",
            "type_path": "bool",
            "docs": " Apply perspective to gizmo lines.\n\n This setting only affects 3D, non-orthographic cameras.\n\n Defaults to `false`."
          },
          {
            "name": "line_style",
            "type_path": "bevy_gizmos::config::GizmoLineStyle",
            "docs": " Determine the style of gizmo lines."
          },
          {
            "name": "depth_bias",
            "type_path": "f32",
            "docs": " How closer to the camera than real geometry the line should be.\n\n In 2D this setting has no effect and is effectively always -1.\n\n Value between -1 and 1 (inclusive).\n * 0 means that there is no change to the line position when rendering\n * 1 means it is furthest away from camera as possible\n * -1 means that it will always render in front of other things.\n\n This is typically useful if you are drawing wireframes on top of polygons\n and your wireframe is z-fighting (flickering on/off) with your main model.\n You would set this value to a negative number close to 0."
          },
          {
            "name": "render_layers",
            "type_path": "bevy_render::view::visibility::render_layers::RenderLayers",
            "docs": " Describes which rendering layers gizmos will be rendered to.\n\n Gizmos will only be rendered to cameras with intersecting layers."
          },
          {
            "name": "line_joints",
            "type_path": "bevy_gizmos::config::GizmoLineJoint",
            "docs": " Describe how lines should join"
          }
        ]
      },
      "path_table": {
        "path": "bevy_gizmos::config::GizmoConfig",
        "short_type_path": "GizmoConfig",
        "ident": "GizmoConfig",
        "crate_name": "bevy_gizmos",
        "module_path": "bevy_gizmos::config"
      },
      "default": null,
      "docs": " A struct that stores configuration for gizmos.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::sprite::Sprite": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "image",
            "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
            "docs": " The image used to render the sprite"
          },
          {
            "name": "texture_atlas",
            "type_path": "core::option::Option<bevy_sprite::texture_atlas::TextureAtlas>",
            "docs": " The (optional) texture atlas used to render the sprite"
          },
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": " The sprite's color tint"
          },
          {
            "name": "flip_x",
            "type_path": "bool",
            "docs": " Flip the sprite along the `X` axis"
          },
          {
            "name": "flip_y",
            "type_path": "bool",
            "docs": " Flip the sprite along the `Y` axis"
          },
          {
            "name": "custom_size",
            "type_path": "core::option::Option<glam::Vec2>",
            "docs": " An optional custom size for the sprite that will be used when rendering, instead of the size\n of the sprite's image"
          },
          {
            "name": "rect",
            "type_path": "core::option::Option<bevy_math::rects::rect::Rect>",
            "docs": " An optional rectangle representing the region of the sprite's image to render, instead of rendering\n the full image. This is an easy one-off alternative to using a [`TextureAtlas`].\n\n When used with a [`TextureAtlas`], the rect\n is offset by the atlas's minimal (top-left) corner position."
          },
          {
            "name": "anchor",
            "type_path": "bevy_sprite::sprite::Anchor",
            "docs": " [`Anchor`] point of the sprite in the world"
          },
          {
            "name": "image_mode",
            "type_path": "bevy_sprite::sprite::SpriteImageMode",
            "docs": " How the sprite's image will be scaled."
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::sprite::Sprite",
        "short_type_path": "Sprite",
        "ident": "Sprite",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::sprite"
      },
      "default": "{\"bevy_sprite::sprite::Sprite\":{\"image\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}},\"texture_atlas\":null,\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"flip_x\":false,\"flip_y\":false,\"custom_size\":null,\"rect\":null,\"anchor\":\"Center\",\"image_mode\":\"Auto\"}}",
      "docs": " Describes a sprite to be rendered to a 2D camera",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::geometry::Val": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Auto",
            "docs": " Automatically determine the value based on the context and other [`Node`](crate::Node) properties."
          },
          {
            "kind": "tuple",
            "name": "Px",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Set this value in logical pixels."
          },
          {
            "kind": "tuple",
            "name": "Percent",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Set the value as a percentage of its parent node's length along a specific axis.\n\n If the UI node has no parent, the percentage is calculated based on the window's length\n along the corresponding axis.\n\n The chosen axis depends on the [`Node`](crate::Node) field set:\n * For `flex_basis`, the percentage is relative to the main-axis length determined by the `flex_direction`.\n * For `gap`, `min_size`, `size`, and `max_size`:\n   - `width` is relative to the parent's width.\n   - `height` is relative to the parent's height.\n * For `margin`, `padding`, and `border` values: the percentage is relative to the parent node's width.\n * For positions, `left` and `right` are relative to the parent's width, while `bottom` and `top` are relative to the parent's height."
          },
          {
            "kind": "tuple",
            "name": "Vw",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Set this value in percent of the viewport width"
          },
          {
            "kind": "tuple",
            "name": "Vh",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Set this value in percent of the viewport height"
          },
          {
            "kind": "tuple",
            "name": "VMin",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Set this value in percent of the viewport's smaller dimension."
          },
          {
            "kind": "tuple",
            "name": "VMax",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Set this value in percent of the viewport's larger dimension."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::geometry::Val",
        "short_type_path": "Val",
        "ident": "Val",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::geometry"
      },
      "default": "{\"bevy_ui::geometry::Val\":\"Auto\"}",
      "docs": " Represents the possible value types for layout properties.\n\n This enum allows specifying values for various [`Node`](crate::Node) properties in different units,\n such as logical pixels, percentages, or automatically determined values.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_utils::hashbrown::HashMap<bevy_ecs::entity::Entity, alloc::vec::Vec<bevy_pbr::light::Cascade>, bevy_ecs::entity::hash::EntityHash>": {
      "info": {
        "kind": "map",
        "key_type_path": "bevy_ecs::entity::Entity",
        "value_type_path": "alloc::vec::Vec<bevy_pbr::light::Cascade>"
      },
      "path_table": {
        "path": "bevy_utils::hashbrown::HashMap<bevy_ecs::entity::Entity, alloc::vec::Vec<bevy_pbr::light::Cascade>, bevy_ecs::entity::hash::EntityHash>",
        "short_type_path": "HashMap<Entity, Vec<Cascade>, EntityHash>",
        "ident": "HashMap",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils::hashbrown"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::core_3d::camera_3d::Camera3dDepthLoadOp": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Clear",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Clear with a specified value.\n Note that 0.0 is the far plane due to bevy's use of reverse-z projections."
          },
          {
            "kind": "unit",
            "name": "Load",
            "docs": " Load from memory."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::core_3d::camera_3d::Camera3dDepthLoadOp",
        "short_type_path": "Camera3dDepthLoadOp",
        "ident": "Camera3dDepthLoadOp",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::core_3d::camera_3d"
      },
      "default": null,
      "docs": " The depth clear operation to perform for the main 3d pass.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::pipeline::TextLayoutInfo": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "glyphs",
            "type_path": "alloc::vec::Vec<bevy_text::glyph::PositionedGlyph>",
            "docs": " Scaled and positioned glyphs in screenspace"
          },
          {
            "name": "size",
            "type_path": "glam::Vec2",
            "docs": " The glyphs resulting size"
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::pipeline::TextLayoutInfo",
        "short_type_path": "TextLayoutInfo",
        "ident": "TextLayoutInfo",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::pipeline"
      },
      "default": "{\"bevy_text::pipeline::TextLayoutInfo\":{\"glyphs\":[],\"size\":[0.0,0.0]}}",
      "docs": " Render information for a corresponding text block.\n\n Contains scaled glyphs and their size. Generated via [`TextPipeline::queue_text`] when an entity has\n [`TextLayout`] and [`ComputedTextBlock`] components.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevy_pbr::light::Cascade>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_pbr::light::Cascade"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_pbr::light::Cascade>",
        "short_type_path": "Vec<Cascade>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::camera::Exposure": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_render::camera::camera::Exposure"
      },
      "path_table": {
        "path": "bevy_render::camera::camera::Exposure",
        "short_type_path": "Exposure",
        "ident": "Exposure",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": null,
      "docs": " How much energy a `Camera3d` absorbs from incoming light.\n\n <https://en.wikipedia.org/wiki/Exposure_(photography)>",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "i128": {
      "info": {
        "kind": "opaque",
        "item_type_path": "i128"
      },
      "path_table": {
        "path": "i128",
        "short_type_path": "i128",
        "ident": "i128",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"i128\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_gltf::GltfPrimitive>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_gltf::GltfPrimitive>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_gltf::GltfPrimitive>",
        "short_type_path": "Handle<GltfPrimitive>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_gltf::GltfPrimitive>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "petgraph::graph::NodeIndex": {
      "info": {
        "kind": "opaque",
        "item_type_path": "petgraph::graph::NodeIndex"
      },
      "path_table": {
        "path": "petgraph::graph::NodeIndex",
        "short_type_path": "NodeIndex",
        "ident": "NodeIndex",
        "crate_name": "petgraph",
        "module_path": "petgraph::graph"
      },
      "default": "{\"petgraph::graph::NodeIndex\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<bevy_utils::Instant>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_utils::Instant",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_utils::Instant>",
        "short_type_path": "Option<Instant>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::primitives::Aabb": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "center",
            "type_path": "glam::Vec3A",
            "docs": null
          },
          {
            "name": "half_extents",
            "type_path": "glam::Vec3A",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::primitives::Aabb",
        "short_type_path": "Aabb",
        "ident": "Aabb",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::primitives"
      },
      "default": "{\"bevy_render::primitives::Aabb\":{\"center\":[0.0,0.0,0.0],\"half_extents\":[0.0,0.0,0.0]}}",
      "docs": " An axis-aligned bounding box, defined by:\n - a center,\n - the distances from the center to each faces along the axis,\n     the faces are orthogonal to the axis.\n\n It is typically used as a component on an entity to represent the local space\n occupied by this entity, with faces orthogonal to its local axis.\n\n This component is notably used during \"frustum culling\", a process to determine\n if an entity should be rendered by a [`Camera`] if its bounding box intersects\n with the camera's [`Frustum`].\n\n It will be added automatically by the systems in [`CalculateBounds`] to entities that:\n - could be subject to frustum culling, for example with a [`Mesh3d`]\n     or `Sprite` component,\n - don't have the [`NoFrustumCulling`] component.\n\n It won't be updated automatically if the space occupied by the entity changes,\n for example if the vertex positions of a [`Mesh3d`] are updated.\n\n [`Camera`]: crate::camera::Camera\n [`NoFrustumCulling`]: crate::view::visibility::NoFrustumCulling\n [`CalculateBounds`]: crate::view::visibility::VisibilitySystems::CalculateBounds\n [`Mesh3d`]: crate::mesh::Mesh",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::ScrollPosition": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "offset_x",
            "type_path": "f32",
            "docs": " How far across the node is scrolled, in pixels. (0 = not scrolled / scrolled to right)"
          },
          {
            "name": "offset_y",
            "type_path": "f32",
            "docs": " How far down the node is scrolled, in pixels. (0 = not scrolled / scrolled to top)"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::ScrollPosition",
        "short_type_path": "ScrollPosition",
        "ident": "ScrollPosition",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::ScrollPosition\":{\"offset_x\":0.0,\"offset_y\":0.0}}",
      "docs": " The scroll position of the node.\n\n Updating the values of `ScrollPosition` will reposition the children of the node by the offset amount.\n `ScrollPosition` may be updated by the layout system when a layout change makes a previously valid `ScrollPosition` invalid.\n Changing this does nothing on a `Node` without setting at least one `OverflowAxis` to `OverflowAxis::Scroll`.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_text::text::TextFont": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "font",
            "type_path": "bevy_asset::handle::Handle<bevy_text::font::Font>",
            "docs": " The specific font face to use, as a `Handle` to a [`Font`] asset.\n\n If the `font` is not specified, then\n * if `default_font` feature is enabled (enabled by default in `bevy` crate),\n   `FiraMono-subset.ttf` compiled into the library is used.\n * otherwise no text will be rendered, unless a custom font is loaded into the default font\n   handle."
          },
          {
            "name": "font_size",
            "type_path": "f32",
            "docs": " The vertical height of rasterized glyphs in the font atlas in pixels.\n\n This is multiplied by the window scale factor and `UiScale`, but not the text entity\n transform or camera projection.\n\n A new font atlas is generated for every combination of font handle and scaled font size\n which can have a strong performance impact."
          },
          {
            "name": "font_smoothing",
            "type_path": "bevy_text::text::FontSmoothing",
            "docs": " The antialiasing method to use when rendering text."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::TextFont",
        "short_type_path": "TextFont",
        "ident": "TextFont",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": "{\"bevy_text::text::TextFont\":{\"font\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}},\"font_size\":20.0,\"font_smoothing\":\"AntiAliased\"}}",
      "docs": " `TextFont` determines the style of a text span within a [`ComputedTextBlock`], specifically\n the font face, the font size, and the color.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_text::glyph::PositionedGlyph": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "position",
            "type_path": "glam::Vec2",
            "docs": " The position of the glyph in the text block's bounding box."
          },
          {
            "name": "size",
            "type_path": "glam::Vec2",
            "docs": " The width and height of the glyph in logical pixels."
          },
          {
            "name": "atlas_info",
            "type_path": "bevy_text::glyph::GlyphAtlasInfo",
            "docs": " Information about the glyph's atlas."
          },
          {
            "name": "span_index",
            "type_path": "usize",
            "docs": " The index of the glyph in the [`ComputedTextBlock`](crate::ComputedTextBlock)'s tracked spans."
          },
          {
            "name": "byte_index",
            "type_path": "usize",
            "docs": " TODO: In order to do text editing, we need access to the size of glyphs and their index in the associated String.\n For example, to figure out where to place the cursor in an input box from the mouse's position.\n Without this, it's only possible in texts where each glyph is one byte. Cosmic text has methods for this\n cosmic-texts [hit detection](https://pop-os.github.io/cosmic-text/cosmic_text/struct.Buffer.html#method.hit)"
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::glyph::PositionedGlyph",
        "short_type_path": "PositionedGlyph",
        "ident": "PositionedGlyph",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::glyph"
      },
      "default": null,
      "docs": " A glyph of a font, typically representing a single character, positioned in screen space.\n\n Contains information about how and where to render a glyph.\n\n Used in [`TextPipeline::queue_text`](crate::TextPipeline::queue_text) and [`crate::TextLayoutInfo`] for rendering glyphs.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::fxaa::Sensitivity": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Low",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Medium",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "High",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Ultra",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Extreme",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::fxaa::Sensitivity",
        "short_type_path": "Sensitivity",
        "ident": "Sensitivity",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::fxaa"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_animation::AnimationClip>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_animation::AnimationClip>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_animation::AnimationClip>",
        "short_type_path": "Handle<AnimationClip>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_animation::AnimationClip>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gizmos::config::GizmoLineStyle": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Solid",
            "docs": " A solid line without any decorators"
          },
          {
            "kind": "unit",
            "name": "Dotted",
            "docs": " A dotted line"
          }
        ]
      },
      "path_table": {
        "path": "bevy_gizmos::config::GizmoLineStyle",
        "short_type_path": "GizmoLineStyle",
        "ident": "GizmoLineStyle",
        "crate_name": "bevy_gizmos",
        "module_path": "bevy_gizmos::config"
      },
      "default": null,
      "docs": " An enum used to configure the style of gizmo lines, similar to CSS line-style",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::timer::TimerMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Once",
            "docs": " Run once and stop."
          },
          {
            "kind": "unit",
            "name": "Repeating",
            "docs": " Reset when finished."
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::timer::TimerMode",
        "short_type_path": "TimerMode",
        "ident": "TimerMode",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::timer"
      },
      "default": "{\"bevy_time::timer::TimerMode\":\"Once\"}",
      "docs": " Specifies [`Timer`] behavior.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_utils::hashbrown::HashMap<bevy_animation::AnimationTargetId, u64, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>": {
      "info": {
        "kind": "map",
        "key_type_path": "bevy_animation::AnimationTargetId",
        "value_type_path": "u64"
      },
      "path_table": {
        "path": "bevy_utils::hashbrown::HashMap<bevy_animation::AnimationTargetId, u64, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
        "short_type_path": "HashMap<AnimationTargetId, u64, DefaultHashBuilder>",
        "ident": "HashMap",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils::hashbrown"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "petgraph::graph::DiGraph<bevy_animation::graph::AnimationGraphNode, (), u32>": {
      "info": {
        "kind": "opaque",
        "item_type_path": "petgraph::graph::DiGraph<bevy_animation::graph::AnimationGraphNode, (), u32>"
      },
      "path_table": {
        "path": "petgraph::graph::DiGraph<bevy_animation::graph::AnimationGraphNode, (), u32>",
        "short_type_path": "DiGraph<AnimationGraphNode, (), u32>",
        "ident": "DiGraph",
        "crate_name": "petgraph",
        "module_path": "petgraph::graph"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::MaxTrackSizingFunction": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Px",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be a fixed pixel value"
          },
          {
            "kind": "tuple",
            "name": "Percent",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be a percentage value"
          },
          {
            "kind": "unit",
            "name": "MinContent",
            "docs": " Track maximum size should be content sized under a min-content constraint"
          },
          {
            "kind": "unit",
            "name": "MaxContent",
            "docs": " Track maximum size should be content sized under a max-content constraint"
          },
          {
            "kind": "tuple",
            "name": "FitContentPx",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be sized according to the fit-content formula with a fixed pixel limit"
          },
          {
            "kind": "tuple",
            "name": "FitContentPercent",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be sized according to the fit-content formula with a percentage limit"
          },
          {
            "kind": "unit",
            "name": "Auto",
            "docs": " Track maximum size should be automatically sized"
          },
          {
            "kind": "tuple",
            "name": "Fraction",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " The dimension as a fraction of the total available grid space (`fr` units in CSS)\n Specified value is the numerator of the fraction. Denominator is the sum of all fractions specified in that grid dimension.\n\n Spec: <https://www.w3.org/TR/css3-grid-layout/#fr-unit>"
          },
          {
            "kind": "tuple",
            "name": "VMin",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be a percent of the viewport's smaller dimension."
          },
          {
            "kind": "tuple",
            "name": "VMax",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be a percent of the viewport's smaller dimension."
          },
          {
            "kind": "tuple",
            "name": "Vh",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be a percent of the viewport's height dimension."
          },
          {
            "kind": "tuple",
            "name": "Vw",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track maximum size should be a percent of the viewport's width dimension."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::MaxTrackSizingFunction",
        "short_type_path": "MaxTrackSizingFunction",
        "ident": "MaxTrackSizingFunction",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::MaxTrackSizingFunction\":\"Auto\"}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::volumetric_fog::VolumetricFog": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "ambient_color",
            "type_path": "bevy_color::color::Color",
            "docs": " Color of the ambient light.\n\n This is separate from Bevy's [`AmbientLight`](crate::light::AmbientLight) because an\n [`EnvironmentMapLight`](crate::environment_map::EnvironmentMapLight) is\n still considered an ambient light for the purposes of volumetric fog. If you're using a\n [`EnvironmentMapLight`](crate::environment_map::EnvironmentMapLight), for best results,\n this should be a good approximation of the average color of the environment map.\n\n Defaults to white."
          },
          {
            "name": "ambient_intensity",
            "type_path": "f32",
            "docs": " The brightness of the ambient light.\n\n If there's no [`EnvironmentMapLight`](crate::environment_map::EnvironmentMapLight),\n set this to 0.\n\n Defaults to 0.1."
          },
          {
            "name": "jitter",
            "type_path": "f32",
            "docs": " The maximum distance to offset the ray origin randomly by, in meters.\n\n This is intended for use with temporal antialiasing. It helps fog look\n less blocky by varying the start position of the ray, using interleaved\n gradient noise."
          },
          {
            "name": "step_count",
            "type_path": "u32",
            "docs": " The number of raymarching steps to perform.\n\n Higher values produce higher-quality results with less banding, but\n reduce performance.\n\n The default value is 64."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::volumetric_fog::VolumetricFog",
        "short_type_path": "VolumetricFog",
        "ident": "VolumetricFog",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::volumetric_fog"
      },
      "default": "{\"bevy_pbr::volumetric_fog::VolumetricFog\":{\"ambient_color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"ambient_intensity\":0.1,\"jitter\":0.0,\"step_count\":64}}",
      "docs": " When placed on a [`bevy_core_pipeline::core_3d::Camera3d`], enables\n volumetric fog and volumetric lighting, also known as light shafts or god\n rays.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_image::image::Image": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_image::image::Image"
      },
      "path_table": {
        "path": "bevy_image::image::Image",
        "short_type_path": "Image",
        "ident": "Image",
        "crate_name": "bevy_image",
        "module_path": "bevy_image::image"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::ZIndex": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "i32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::ZIndex",
        "short_type_path": "ZIndex",
        "ident": "ZIndex",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::ZIndex\":0}",
      "docs": " Indicates that this [`Node`] entity's front-to-back ordering is not controlled solely\n by its location in the UI hierarchy. A node with a higher z-index will appear on top\n of sibling nodes with a lower z-index.\n\n UI nodes that have the same z-index will appear according to the order in which they\n appear in the UI hierarchy. In such a case, the last node to be added to its parent\n will appear in front of its siblings.\n\n Nodes without this component will be treated as if they had a value of [`ZIndex(0)`].\n\n Use [`GlobalZIndex`] if you need to order separate UI hierarchies or nodes that are\n not siblings in a given UI hierarchy.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::view::visibility::InheritedVisibility": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bool",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::visibility::InheritedVisibility",
        "short_type_path": "InheritedVisibility",
        "ident": "InheritedVisibility",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::visibility"
      },
      "default": "{\"bevy_render::view::visibility::InheritedVisibility\":false}",
      "docs": " Whether or not an entity is visible in the hierarchy.\n This will not be accurate until [`VisibilityPropagate`] runs in the [`PostUpdate`] schedule.\n\n If this is false, then [`ViewVisibility`] should also be false.\n\n [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_utils::hashbrown::HashMap<petgraph::graph::NodeIndex, f32, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>": {
      "info": {
        "kind": "map",
        "key_type_path": "petgraph::graph::NodeIndex",
        "value_type_path": "f32"
      },
      "path_table": {
        "path": "bevy_utils::hashbrown::HashMap<petgraph::graph::NodeIndex, f32, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
        "short_type_path": "HashMap<NodeIndex, f32, DefaultHashBuilder>",
        "ident": "HashMap",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils::hashbrown"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "u64": {
      "info": {
        "kind": "opaque",
        "item_type_path": "u64"
      },
      "path_table": {
        "path": "u64",
        "short_type_path": "u64",
        "ident": "u64",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"u64\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<bevy_mesh::index::Indices>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_mesh::index::Indices",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_mesh::index::Indices>",
        "short_type_path": "Option<Indices>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_scene::utils::bundle_placeholder::BundlePlaceholder": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Camera2d",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Camera3d",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "PointLight",
            "docs": null
          },
          {
            "kind": "struct",
            "name": "Text",
            "fields": [
              {
                "name": "sections",
                "type_path": "alloc::vec::Vec<alloc::string::String>",
                "docs": null
              },
              {
                "name": "node",
                "type_path": "bevy_ui::ui_node::Node",
                "docs": null
              },
              {
                "name": "visibility",
                "type_path": "bevy_render::view::visibility::Visibility",
                "docs": null
              },
              {
                "name": "layout",
                "type_path": "bevy_text::text::TextLayout",
                "docs": null
              },
              {
                "name": "background_color",
                "type_path": "core::option::Option<bevy_color::color::Color>",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "struct",
            "name": "Sprite",
            "fields": [
              {
                "name": "path",
                "type_path": "alloc::string::String",
                "docs": null
              },
              {
                "name": "image_mode",
                "type_path": "bevy_sprite::sprite::SpriteImageMode",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Scene",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::string::String",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Gltf",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::string::String",
                "docs": null
              }
            ],
            "docs": null
          },
          {
            "kind": "struct",
            "name": "Pbr",
            "fields": [
              {
                "name": "mesh",
                "type_path": "bevyhub_scene::utils::bundle_placeholder::MeshPlaceholder",
                "docs": null
              },
              {
                "name": "material",
                "type_path": "bevyhub_scene::utils::bundle_placeholder::MaterialPlaceholder",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::bundle_placeholder::BundlePlaceholder",
        "short_type_path": "BundlePlaceholder",
        "ident": "BundlePlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::bundle_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::sync_world::SyncToRenderWorld": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_render::sync_world::SyncToRenderWorld",
        "short_type_path": "SyncToRenderWorld",
        "ident": "SyncToRenderWorld",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::sync_world"
      },
      "default": null,
      "docs": " Marker component that indicates that its entity needs to be synchronized to the render world.\n\n This component is automatically added as a required component by [`ExtractComponentPlugin`] and [`SyncComponentPlugin`].\n For more information see [`SyncWorldPlugin`].\n\n NOTE: This component should persist throughout the entity's entire lifecycle.\n If this component is removed from its entity, the entity will be despawned.\n\n [`ExtractComponentPlugin`]: crate::extract_component::ExtractComponentPlugin\n [`SyncComponentPlugin`]: crate::sync_component::SyncComponentPlugin",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "usize": {
      "info": {
        "kind": "opaque",
        "item_type_path": "usize"
      },
      "path_table": {
        "path": "usize",
        "short_type_path": "usize",
        "ident": "usize",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"usize\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::ops::Range<u32>": {
      "info": {
        "kind": "opaque",
        "item_type_path": "core::ops::Range<u32>"
      },
      "path_table": {
        "path": "core::ops::Range<u32>",
        "short_type_path": "Range<u32>",
        "ident": "Range",
        "crate_name": "core",
        "module_path": "core::ops"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::view::visibility::ViewVisibility": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bool",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::visibility::ViewVisibility",
        "short_type_path": "ViewVisibility",
        "ident": "ViewVisibility",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::visibility"
      },
      "default": "{\"bevy_render::view::visibility::ViewVisibility\":false}",
      "docs": " Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering.\n\n Each frame, this will be reset to `false` during [`VisibilityPropagate`] systems in [`PostUpdate`].\n Later in the frame, systems in [`CheckVisibility`] will mark any visible entities using [`ViewVisibility::set`].\n Because of this, values of this type will be marked as changed every frame, even when they do not change.\n\n If you wish to add custom visibility system that sets this value, make sure you add it to the [`CheckVisibility`] set.\n\n [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate\n [`CheckVisibility`]: VisibilitySystems::CheckVisibility",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::fog::FogFalloff": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Linear",
            "fields": [
              {
                "name": "start",
                "type_path": "f32",
                "docs": " Distance from the camera where fog is completely transparent, in world units."
              },
              {
                "name": "end",
                "type_path": "f32",
                "docs": " Distance from the camera where fog is completely opaque, in world units."
              }
            ],
            "docs": " A linear fog falloff that grows in intensity between `start` and `end` distances.\n\n This falloff mode is simpler to control than other modes, however it can produce results that look “artificial”, depending on the scene.\n\n ## Formula\n\n The fog intensity for a given point in the scene is determined by the following formula:\n\n ```text\n let fog_intensity = 1.0 - ((end - distance) / (end - start)).clamp(0.0, 1.0);\n ```\n\n <svg width=\"370\" height=\"212\" viewBox=\"0 0 370 212\" fill=\"none\">\n <title>Plot showing how linear fog falloff behaves for start and end values of 0.8 and 2.2, respectively.</title>\n <path d=\"M331 151H42V49\" stroke=\"currentColor\" stroke-width=\"2\"/>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"136\" y=\"173.864\">1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"30\" y=\"53.8636\">1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"42\" y=\"173.864\">0</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"232\" y=\"173.864\">2</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"332\" y=\"173.864\">3</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"161\" y=\"190.864\">distance</tspan></text>\n <text font-family=\"sans-serif\" transform=\"translate(10 132) rotate(-90)\" fill=\"currentColor\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"0\" y=\"11.8636\">fog intensity</tspan></text>\n <path d=\"M43 150H117.227L263 48H331\" stroke=\"#FF00E5\"/>\n <path d=\"M118 151V49\" stroke=\"#FF00E5\" stroke-dasharray=\"1 4\"/>\n <path d=\"M263 151V49\" stroke=\"#FF00E5\" stroke-dasharray=\"1 4\"/>\n <text font-family=\"sans-serif\" fill=\"#FF00E5\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"121\" y=\"58.6364\">start</tspan></text>\n <text font-family=\"sans-serif\" fill=\"#FF00E5\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"267\" y=\"58.6364\">end</tspan></text>\n </svg>"
          },
          {
            "kind": "struct",
            "name": "Exponential",
            "fields": [
              {
                "name": "density",
                "type_path": "f32",
                "docs": " Multiplier applied to the world distance (within the exponential fog falloff calculation)."
              }
            ],
            "docs": " An exponential fog falloff with a given `density`.\n\n Initially gains intensity quickly with distance, then more slowly. Typically produces more natural results than [`FogFalloff::Linear`],\n but is a bit harder to control.\n\n To move the fog “further away”, use lower density values. To move it “closer” use higher density values.\n\n ## Tips\n\n - Use the [`FogFalloff::from_visibility()`] convenience method to create an exponential falloff with the proper\n     density for a desired visibility distance in world units;\n - It's not _unusual_ to have very large or very small values for the density, depending on the scene\n     scale. Typically, for scenes with objects in the scale of thousands of units, you might want density values\n     in the ballpark of `0.001`. Conversely, for really small scale scenes you might want really high values of\n     density;\n - Combine the `density` parameter with the [`DistanceFog`] `color`'s alpha channel for easier artistic control.\n\n ## Formula\n\n The fog intensity for a given point in the scene is determined by the following formula:\n\n ```text\n let fog_intensity = 1.0 - 1.0 / (distance * density).exp();\n ```\n\n <svg width=\"370\" height=\"212\" viewBox=\"0 0 370 212\" fill=\"none\">\n <title>Plot showing how exponential fog falloff behaves for different density values</title>\n <mask id=\"mask0_3_31\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"42\" y=\"42\" width=\"286\" height=\"108\">\n <rect x=\"42\" y=\"42\" width=\"286\" height=\"108\" fill=\"#D9D9D9\"/>\n </mask>\n <g mask=\"url(#mask0_3_31)\">\n <path d=\"M42 150C42 150 98.3894 53 254.825 53L662 53\" stroke=\"#FF003D\" stroke-width=\"1\"/>\n <path d=\"M42 150C42 150 139.499 53 409.981 53L1114 53\" stroke=\"#001AFF\" stroke-width=\"1\"/>\n <path d=\"M42 150C42 150 206.348 53 662.281 53L1849 53\" stroke=\"#14FF00\" stroke-width=\"1\"/>\n </g>\n <path d=\"M331 151H42V49\" stroke=\"currentColor\" stroke-width=\"2\"/>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"136\" y=\"173.864\">1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"30\" y=\"53.8636\">1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"42\" y=\"173.864\">0</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"232\" y=\"173.864\">2</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"332\" y=\"173.864\">3</tspan></text>\n <text font-family=\"sans-serif\" fill=\"#FF003D\" style=\"white-space: pre\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"77\" y=\"64.6364\">density = 2</tspan></text>\n <text font-family=\"sans-serif\" fill=\"#001AFF\" style=\"white-space: pre\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"236\" y=\"76.6364\">density = 1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"#14FF00\" style=\"white-space: pre\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"205\" y=\"115.636\">density = 0.5</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"161\" y=\"190.864\">distance</tspan></text>\n <text font-family=\"sans-serif\" transform=\"translate(10 132) rotate(-90)\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"0\" y=\"11.8636\">fog intensity</tspan></text>\n </svg>"
          },
          {
            "kind": "struct",
            "name": "ExponentialSquared",
            "fields": [
              {
                "name": "density",
                "type_path": "f32",
                "docs": " Multiplier applied to the world distance (within the exponential squared fog falloff calculation)."
              }
            ],
            "docs": " A squared exponential fog falloff with a given `density`.\n\n Similar to [`FogFalloff::Exponential`], but grows more slowly in intensity for closer distances\n before “catching up”.\n\n To move the fog “further away”, use lower density values. To move it “closer” use higher density values.\n\n ## Tips\n\n - Use the [`FogFalloff::from_visibility_squared()`] convenience method to create an exponential squared falloff\n     with the proper density for a desired visibility distance in world units;\n - Combine the `density` parameter with the [`DistanceFog`] `color`'s alpha channel for easier artistic control.\n\n ## Formula\n\n The fog intensity for a given point in the scene is determined by the following formula:\n\n ```text\n let fog_intensity = 1.0 - 1.0 / (distance * density).squared().exp();\n ```\n\n <svg width=\"370\" height=\"212\" viewBox=\"0 0 370 212\" fill=\"none\">\n <title>Plot showing how exponential squared fog falloff behaves for different density values</title>\n <mask id=\"mask0_1_3\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"42\" y=\"42\" width=\"286\" height=\"108\">\n <rect x=\"42\" y=\"42\" width=\"286\" height=\"108\" fill=\"#D9D9D9\"/>\n </mask>\n <g mask=\"url(#mask0_1_3)\">\n <path d=\"M42 150C75.4552 150 74.9241 53.1724 166.262 53.1724L404 53.1724\" stroke=\"#FF003D\" stroke-width=\"1\"/>\n <path d=\"M42 150C107.986 150 106.939 53.1724 287.091 53.1724L756 53.1724\" stroke=\"#001AFF\" stroke-width=\"1\"/>\n <path d=\"M42 150C166.394 150 164.42 53.1724 504.035 53.1724L1388 53.1724\" stroke=\"#14FF00\" stroke-width=\"1\"/>\n </g>\n <path d=\"M331 151H42V49\" stroke=\"currentColor\" stroke-width=\"2\"/>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"136\" y=\"173.864\">1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"30\" y=\"53.8636\">1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"42\" y=\"173.864\">0</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"232\" y=\"173.864\">2</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"332\" y=\"173.864\">3</tspan></text>\n <text font-family=\"sans-serif\" fill=\"#FF003D\" style=\"white-space: pre\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"61\" y=\"54.6364\">density = 2</tspan></text>\n <text font-family=\"sans-serif\" fill=\"#001AFF\" style=\"white-space: pre\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"168\" y=\"84.6364\">density = 1</tspan></text>\n <text font-family=\"sans-serif\" fill=\"#14FF00\" style=\"white-space: pre\" font-size=\"10\" letter-spacing=\"0em\"><tspan x=\"174\" y=\"121.636\">density = 0.5</tspan></text>\n <text font-family=\"sans-serif\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"161\" y=\"190.864\">distance</tspan></text>\n <text font-family=\"sans-serif\" transform=\"translate(10 132) rotate(-90)\" fill=\"currentColor\" style=\"white-space: pre\" font-size=\"12\" letter-spacing=\"0em\"><tspan x=\"0\" y=\"11.8636\">fog intensity</tspan></text>\n </svg>"
          },
          {
            "kind": "struct",
            "name": "Atmospheric",
            "fields": [
              {
                "name": "extinction",
                "type_path": "glam::Vec3",
                "docs": " Controls how much light is removed due to atmospheric “extinction”, i.e. loss of light due to\n photons being absorbed by atmospheric particles.\n\n Each component can be thought of as an independent per `R`/`G`/`B` channel `density` factor from\n [`FogFalloff::Exponential`]: Multiplier applied to the world distance (within the fog\n falloff calculation) for that specific channel.\n\n **Note:**\n This value is not a `Color`, since it affects the channels exponentially in a non-intuitive way.\n For artistic control, use the [`FogFalloff::from_visibility_colors()`] convenience method."
              },
              {
                "name": "inscattering",
                "type_path": "glam::Vec3",
                "docs": " Controls how much light is added due to light scattering from the sun through the atmosphere.\n\n Each component can be thought of as an independent per `R`/`G`/`B` channel `density` factor from\n [`FogFalloff::Exponential`]: A multiplier applied to the world distance (within the fog\n falloff calculation) for that specific channel.\n\n **Note:**\n This value is not a `Color`, since it affects the channels exponentially in a non-intuitive way.\n For artistic control, use the [`FogFalloff::from_visibility_colors()`] convenience method."
              }
            ],
            "docs": " A more general form of the [`FogFalloff::Exponential`] mode. The falloff formula is separated into\n two terms, `extinction` and `inscattering`, for a somewhat simplified atmospheric scattering model.\n Additionally, individual color channels can have their own density values, resulting in a total of\n six different configuration parameters.\n\n ## Tips\n\n - Use the [`FogFalloff::from_visibility_colors()`] or [`FogFalloff::from_visibility_color()`] convenience methods\n     to create an atmospheric falloff with the proper densities for a desired visibility distance in world units and\n     extinction and inscattering colors;\n - Combine the atmospheric fog parameters with the [`DistanceFog`] `color`'s alpha channel for easier artistic control.\n\n ## Formula\n\n Unlike other modes, atmospheric falloff doesn't use a simple intensity-based blend of fog color with\n object color. Instead, it calculates per-channel extinction and inscattering factors, which are\n then used to calculate the final color.\n\n ```text\n let extinction_factor = 1.0 - 1.0 / (distance * extinction).exp();\n let inscattering_factor = 1.0 - 1.0 / (distance * inscattering).exp();\n let result = input_color * (1.0 - extinction_factor) + fog_color * inscattering_factor;\n ```\n\n ## Equivalence to [`FogFalloff::Exponential`]\n\n For a density value of `D`, the following two falloff modes will produce identical visual results:\n\n ```\n # use bevy_pbr::prelude::*;\n # use bevy_math::prelude::*;\n # const D: f32 = 0.5;\n #\n let exponential = FogFalloff::Exponential {\n     density: D,\n };\n\n let atmospheric = FogFalloff::Atmospheric {\n     extinction: Vec3::new(D, D, D),\n     inscattering: Vec3::new(D, D, D),\n };\n ```\n\n **Note:** While the results are identical, [`FogFalloff::Atmospheric`] is computationally more expensive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::fog::FogFalloff",
        "short_type_path": "FogFalloff",
        "ident": "FogFalloff",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::fog"
      },
      "default": null,
      "docs": " Allows switching between different fog falloff modes, and configuring their parameters.\n\n ## Convenience Methods\n\n When using non-linear fog modes it can be hard to determine the right parameter values\n for a given scene.\n\n For easier artistic control, instead of creating the enum variants directly, you can use the\n visibility-based convenience methods:\n\n - For `FogFalloff::Exponential`:\n     - [`FogFalloff::from_visibility()`]\n     - [`FogFalloff::from_visibility_contrast()`]\n\n - For `FogFalloff::ExponentialSquared`:\n     - [`FogFalloff::from_visibility_squared()`]\n     - [`FogFalloff::from_visibility_contrast_squared()`]\n\n - For `FogFalloff::Atmospheric`:\n     - [`FogFalloff::from_visibility_color()`]\n     - [`FogFalloff::from_visibility_colors()`]\n     - [`FogFalloff::from_visibility_contrast_color()`]\n     - [`FogFalloff::from_visibility_contrast_colors()`]",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "smallvec::SmallVec<[bevy_ui::ui_node::GridTrack; 1]>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_ui::ui_node::GridTrack"
      },
      "path_table": {
        "path": "smallvec::SmallVec<[bevy_ui::ui_node::GridTrack; 1]>",
        "short_type_path": "SmallVec<[GridTrack; 1]>",
        "ident": "SmallVec",
        "crate_name": "smallvec",
        "module_path": "smallvec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::graph::AnimationGraphHandle": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_asset::handle::Handle<bevy_animation::graph::AnimationGraph>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::graph::AnimationGraphHandle",
        "short_type_path": "AnimationGraphHandle",
        "ident": "AnimationGraphHandle",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation::graph"
      },
      "default": "{\"bevy_animation::graph::AnimationGraphHandle\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A [`Handle`] to the [`AnimationGraph`] to be used by the [`AnimationPlayer`](crate::AnimationPlayer) on the same entity.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "smallvec::SmallVec<[bevy_text::text::TextEntity; 1]>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_text::text::TextEntity"
      },
      "path_table": {
        "path": "smallvec::SmallVec<[bevy_text::text::TextEntity; 1]>",
        "short_type_path": "SmallVec<[TextEntity; 1]>",
        "ident": "SmallVec",
        "crate_name": "smallvec",
        "module_path": "smallvec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_pbr::pbr_material::StandardMaterial>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_pbr::pbr_material::StandardMaterial>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_pbr::pbr_material::StandardMaterial>",
        "short_type_path": "Handle<StandardMaterial>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_pbr::pbr_material::StandardMaterial>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_render::storage::ShaderStorageBuffer>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_render::storage::ShaderStorageBuffer>",
        "short_type_path": "AssetId<ShaderStorageBuffer>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::Node": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "display",
            "type_path": "bevy_ui::ui_node::Display",
            "docs": " Which layout algorithm to use when laying out this node's contents:\n   - [`Display::Flex`]: Use the Flexbox layout algorithm\n   - [`Display::Grid`]: Use the CSS Grid layout algorithm\n   - [`Display::None`]: Hide this node and perform layout as if it does not exist.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/display>"
          },
          {
            "name": "position_type",
            "type_path": "bevy_ui::ui_node::PositionType",
            "docs": " Whether a node should be laid out in-flow with, or independently of its siblings:\n  - [`PositionType::Relative`]: Layout this node in-flow with other nodes using the usual (flexbox/grid) layout algorithm.\n  - [`PositionType::Absolute`]: Layout this node on top and independently of other nodes.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/position>"
          },
          {
            "name": "overflow",
            "type_path": "bevy_ui::ui_node::Overflow",
            "docs": " Whether overflowing content should be displayed or clipped.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/overflow>"
          },
          {
            "name": "overflow_clip_margin",
            "type_path": "bevy_ui::ui_node::OverflowClipMargin",
            "docs": " How the bounds of clipped content should be determined\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-clip-margin>"
          },
          {
            "name": "left",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The horizontal position of the left edge of the node.\n  - For relatively positioned nodes, this is relative to the node's position as computed during regular layout.\n  - For absolutely positioned nodes, this is relative to the *parent* node's bounding box.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/left>"
          },
          {
            "name": "right",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The horizontal position of the right edge of the node.\n  - For relatively positioned nodes, this is relative to the node's position as computed during regular layout.\n  - For absolutely positioned nodes, this is relative to the *parent* node's bounding box.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/right>"
          },
          {
            "name": "top",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The vertical position of the top edge of the node.\n  - For relatively positioned nodes, this is relative to the node's position as computed during regular layout.\n  - For absolutely positioned nodes, this is relative to the *parent* node's bounding box.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/top>"
          },
          {
            "name": "bottom",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The vertical position of the bottom edge of the node.\n  - For relatively positioned nodes, this is relative to the node's position as computed during regular layout.\n  - For absolutely positioned nodes, this is relative to the *parent* node's bounding box.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/bottom>"
          },
          {
            "name": "width",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The ideal width of the node. `width` is used when it is within the bounds defined by `min_width` and `max_width`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/width>"
          },
          {
            "name": "height",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The ideal height of the node. `height` is used when it is within the bounds defined by `min_height` and `max_height`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/height>"
          },
          {
            "name": "min_width",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The minimum width of the node. `min_width` is used if it is greater than `width` and/or `max_width`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/min-width>"
          },
          {
            "name": "min_height",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The minimum height of the node. `min_height` is used if it is greater than `height` and/or `max_height`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/min-height>"
          },
          {
            "name": "max_width",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The maximum width of the node. `max_width` is used if it is within the bounds defined by `min_width` and `width`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/max-width>"
          },
          {
            "name": "max_height",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The maximum height of the node. `max_height` is used if it is within the bounds defined by `min_height` and `height`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/max-height>"
          },
          {
            "name": "aspect_ratio",
            "type_path": "core::option::Option<f32>",
            "docs": " The aspect ratio of the node (defined as `width / height`)\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio>"
          },
          {
            "name": "align_items",
            "type_path": "bevy_ui::ui_node::AlignItems",
            "docs": " Used to control how each individual item is aligned by default within the space they're given.\n - For Flexbox containers, sets default cross axis alignment of the child items.\n - For CSS Grid containers, controls block (vertical) axis alignment of children of this grid container within their grid areas.\n\n This value is overridden if [`AlignSelf`] on the child node is set.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/align-items>"
          },
          {
            "name": "justify_items",
            "type_path": "bevy_ui::ui_node::JustifyItems",
            "docs": " Used to control how each individual item is aligned by default within the space they're given.\n - For Flexbox containers, this property has no effect. See `justify_content` for main axis alignment of flex items.\n - For CSS Grid containers, sets default inline (horizontal) axis alignment of child items within their grid areas.\n\n This value is overridden if [`JustifySelf`] on the child node is set.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items>"
          },
          {
            "name": "align_self",
            "type_path": "bevy_ui::ui_node::AlignSelf",
            "docs": " Used to control how the specified item is aligned within the space it's given.\n - For Flexbox items, controls cross axis alignment of the item.\n - For CSS Grid items, controls block (vertical) axis alignment of a grid item within its grid area.\n\n If set to `Auto`, alignment is inherited from the value of [`AlignItems`] set on the parent node.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/align-self>"
          },
          {
            "name": "justify_self",
            "type_path": "bevy_ui::ui_node::JustifySelf",
            "docs": " Used to control how the specified item is aligned within the space it's given.\n - For Flexbox items, this property has no effect. See `justify_content` for main axis alignment of flex items.\n - For CSS Grid items, controls inline (horizontal) axis alignment of a grid item within its grid area.\n\n If set to `Auto`, alignment is inherited from the value of [`JustifyItems`] set on the parent node.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self>"
          },
          {
            "name": "align_content",
            "type_path": "bevy_ui::ui_node::AlignContent",
            "docs": " Used to control how items are distributed.\n - For Flexbox containers, controls alignment of lines if `flex_wrap` is set to [`FlexWrap::Wrap`] and there are multiple lines of items.\n - For CSS Grid containers, controls alignment of grid rows.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/align-content>"
          },
          {
            "name": "justify_content",
            "type_path": "bevy_ui::ui_node::JustifyContent",
            "docs": " Used to control how items are distributed.\n - For Flexbox containers, controls alignment of items in the main axis.\n - For CSS Grid containers, controls alignment of grid columns.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content>"
          },
          {
            "name": "margin",
            "type_path": "bevy_ui::geometry::UiRect",
            "docs": " The amount of space around a node outside its border.\n\n If a percentage value is used, the percentage is calculated based on the width of the parent node.\n\n # Example\n ```\n # use bevy_ui::{Node, UiRect, Val};\n let node = Node {\n     margin: UiRect {\n         left: Val::Percent(10.),\n         right: Val::Percent(10.),\n         top: Val::Percent(15.),\n         bottom: Val::Percent(15.)\n     },\n     ..Default::default()\n };\n ```\n A node with this style and a parent with dimensions of 100px by 300px will have calculated margins of 10px on both left and right edges, and 15px on both top and bottom edges.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/margin>"
          },
          {
            "name": "padding",
            "type_path": "bevy_ui::geometry::UiRect",
            "docs": " The amount of space between the edges of a node and its contents.\n\n If a percentage value is used, the percentage is calculated based on the width of the parent node.\n\n # Example\n ```\n # use bevy_ui::{Node, UiRect, Val};\n let node = Node {\n     padding: UiRect {\n         left: Val::Percent(1.),\n         right: Val::Percent(2.),\n         top: Val::Percent(3.),\n         bottom: Val::Percent(4.)\n     },\n     ..Default::default()\n };\n ```\n A node with this style and a parent with dimensions of 300px by 100px will have calculated padding of 3px on the left, 6px on the right, 9px on the top and 12px on the bottom.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/padding>"
          },
          {
            "name": "border",
            "type_path": "bevy_ui::geometry::UiRect",
            "docs": " The amount of space between the margins of a node and its padding.\n\n If a percentage value is used, the percentage is calculated based on the width of the parent node.\n\n The size of the node will be expanded if there are constraints that prevent the layout algorithm from placing the border within the existing node boundary.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/border-width>"
          },
          {
            "name": "flex_direction",
            "type_path": "bevy_ui::ui_node::FlexDirection",
            "docs": " Whether a Flexbox container should be a row or a column. This property has no effect on Grid nodes.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction>"
          },
          {
            "name": "flex_wrap",
            "type_path": "bevy_ui::ui_node::FlexWrap",
            "docs": " Whether a Flexbox container should wrap its contents onto multiple lines if they overflow. This property has no effect on Grid nodes.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap>"
          },
          {
            "name": "flex_grow",
            "type_path": "f32",
            "docs": " Defines how much a flexbox item should grow if there's space available. Defaults to 0 (don't grow at all).\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-grow>"
          },
          {
            "name": "flex_shrink",
            "type_path": "f32",
            "docs": " Defines how much a flexbox item should shrink if there's not enough space available. Defaults to 1.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-shrink>"
          },
          {
            "name": "flex_basis",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The initial length of a flexbox in the main axis, before flex growing/shrinking properties are applied.\n\n `flex_basis` overrides `size` on the main axis if both are set, but it obeys the bounds defined by `min_size` and `max_size`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis>"
          },
          {
            "name": "row_gap",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The size of the gutters between items in a vertical flexbox layout or between rows in a grid layout.\n\n Note: Values of `Val::Auto` are not valid and are treated as zero.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap>"
          },
          {
            "name": "column_gap",
            "type_path": "bevy_ui::geometry::Val",
            "docs": " The size of the gutters between items in a horizontal flexbox layout or between column in a grid layout.\n\n Note: Values of `Val::Auto` are not valid and are treated as zero.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap>"
          },
          {
            "name": "grid_auto_flow",
            "type_path": "bevy_ui::ui_node::GridAutoFlow",
            "docs": " Controls whether automatically placed grid items are placed row-wise or column-wise as well as whether the sparse or dense packing algorithm is used.\n Only affects Grid layouts.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow>"
          },
          {
            "name": "grid_template_rows",
            "type_path": "alloc::vec::Vec<bevy_ui::ui_node::RepeatedGridTrack>",
            "docs": " Defines the number of rows a grid has and the sizes of those rows. If grid items are given explicit placements then more rows may\n be implicitly generated by items that are placed out of bounds. The sizes of those rows are controlled by `grid_auto_rows` property.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-rows>"
          },
          {
            "name": "grid_template_columns",
            "type_path": "alloc::vec::Vec<bevy_ui::ui_node::RepeatedGridTrack>",
            "docs": " Defines the number of columns a grid has and the sizes of those columns. If grid items are given explicit placements then more columns may\n be implicitly generated by items that are placed out of bounds. The sizes of those columns are controlled by `grid_auto_columns` property.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns>"
          },
          {
            "name": "grid_auto_rows",
            "type_path": "alloc::vec::Vec<bevy_ui::ui_node::GridTrack>",
            "docs": " Defines the size of implicitly created rows. Rows are created implicitly when grid items are given explicit placements that are out of bounds\n of the rows explicitly created using `grid_template_rows`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-rows>"
          },
          {
            "name": "grid_auto_columns",
            "type_path": "alloc::vec::Vec<bevy_ui::ui_node::GridTrack>",
            "docs": " Defines the size of implicitly created columns. Columns are created implicitly when grid items are given explicit placements that are out of bounds\n of the columns explicitly created using `grid_template_columns`.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-columns>"
          },
          {
            "name": "grid_row",
            "type_path": "bevy_ui::ui_node::GridPlacement",
            "docs": " The row in which a grid item starts and how many rows it spans.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row>"
          },
          {
            "name": "grid_column",
            "type_path": "bevy_ui::ui_node::GridPlacement",
            "docs": " The column in which a grid item starts and how many columns it spans.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column>"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::Node",
        "short_type_path": "Node",
        "ident": "Node",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::Node\":{\"display\":\"Flex\",\"position_type\":\"Relative\",\"overflow\":{\"x\":\"Visible\",\"y\":\"Visible\"},\"overflow_clip_margin\":{\"visual_box\":\"ContentBox\",\"margin\":0.0},\"left\":\"Auto\",\"right\":\"Auto\",\"top\":\"Auto\",\"bottom\":\"Auto\",\"width\":\"Auto\",\"height\":\"Auto\",\"min_width\":\"Auto\",\"min_height\":\"Auto\",\"max_width\":\"Auto\",\"max_height\":\"Auto\",\"aspect_ratio\":null,\"align_items\":\"Default\",\"justify_items\":\"Default\",\"align_self\":\"Auto\",\"justify_self\":\"Auto\",\"align_content\":\"Default\",\"justify_content\":\"Default\",\"margin\":{\"left\":{\"Px\":0.0},\"right\":{\"Px\":0.0},\"top\":{\"Px\":0.0},\"bottom\":{\"Px\":0.0}},\"padding\":{\"left\":{\"Px\":0.0},\"right\":{\"Px\":0.0},\"top\":{\"Px\":0.0},\"bottom\":{\"Px\":0.0}},\"border\":{\"left\":{\"Px\":0.0},\"right\":{\"Px\":0.0},\"top\":{\"Px\":0.0},\"bottom\":{\"Px\":0.0}},\"flex_direction\":\"Row\",\"flex_wrap\":\"NoWrap\",\"flex_grow\":0.0,\"flex_shrink\":1.0,\"flex_basis\":\"Auto\",\"row_gap\":{\"Px\":0.0},\"column_gap\":{\"Px\":0.0},\"grid_auto_flow\":\"Row\",\"grid_template_rows\":[],\"grid_template_columns\":[],\"grid_auto_rows\":[],\"grid_auto_columns\":[],\"grid_row\":{\"start\":null,\"span\":1,\"end\":null},\"grid_column\":{\"start\":null,\"span\":1,\"end\":null}}}",
      "docs": " The base component for UI entities. It describes UI layout and style properties.\n\n When defining new types of UI entities, require [`Node`] to make them behave like UI nodes.\n\n Nodes can be laid out using either Flexbox or CSS Grid Layout.\n\n See below for general learning resources and for documentation on the individual style properties.\n\n ### Flexbox\n\n - [MDN: Basic Concepts of Flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)\n - [A Complete Guide To Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) by CSS Tricks. This is detailed guide with illustrations and comprehensive written explanation of the different Flexbox properties and how they work.\n - [Flexbox Froggy](https://flexboxfroggy.com/). An interactive tutorial/game that teaches the essential parts of Flexbox in a fun engaging way.\n\n ### CSS Grid\n\n - [MDN: Basic Concepts of Grid Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout)\n - [A Complete Guide To CSS Grid](https://css-tricks.com/snippets/css/complete-guide-grid/) by CSS Tricks. This is detailed guide with illustrations and comprehensive written explanation of the different CSS Grid properties and how they work.\n - [CSS Grid Garden](https://cssgridgarden.com/). An interactive tutorial/game that teaches the essential parts of CSS Grid in a fun engaging way.\n\n # See also\n\n - [`RelativeCursorPosition`](crate::RelativeCursorPosition) to obtain the cursor position relative to this node\n - [`Interaction`](crate::Interaction) to obtain the interaction state of this node",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "char": {
      "info": {
        "kind": "opaque",
        "item_type_path": "char"
      },
      "path_table": {
        "path": "char",
        "short_type_path": "char",
        "ident": "char",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"char\":\"\\u0000\"}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<petgraph::graph::NodeIndex>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "petgraph::graph::NodeIndex",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<petgraph::graph::NodeIndex>",
        "short_type_path": "Option<NodeIndex>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "i64": {
      "info": {
        "kind": "opaque",
        "item_type_path": "i64"
      },
      "path_table": {
        "path": "i64",
        "short_type_path": "i64",
        "ident": "i64",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"i64\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_scene::dynamic_scene::DynamicScene>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_scene::dynamic_scene::DynamicScene>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_scene::dynamic_scene::DynamicScene>",
        "short_type_path": "Handle<DynamicScene>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_scene::dynamic_scene::DynamicScene>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::Vec3A": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "z",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Vec3A",
        "short_type_path": "Vec3A",
        "ident": "Vec3A",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Vec3A\":[0.0,0.0,0.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_picking::PickingPlugin": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "is_enabled",
            "type_path": "bool",
            "docs": " Enables and disables all picking features."
          },
          {
            "name": "is_input_enabled",
            "type_path": "bool",
            "docs": " Enables and disables input collection."
          },
          {
            "name": "is_focus_enabled",
            "type_path": "bool",
            "docs": " Enables and disables updating interaction states of entities."
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::PickingPlugin",
        "short_type_path": "PickingPlugin",
        "ident": "PickingPlugin",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking"
      },
      "default": "{\"bevy_picking::PickingPlugin\":{\"is_enabled\":true,\"is_input_enabled\":true,\"is_focus_enabled\":true}}",
      "docs": " This plugin sets up the core picking infrastructure. It receives input events, and provides the shared\n types used by other picking plugins.\n\n This plugin contains several settings, and is added to the wrold as a resource after initialization. You\n can configure picking settings at runtime through the resource.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_render::view::visibility::range::VisibilityRange": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "start_margin",
            "type_path": "core::ops::Range<f32>",
            "docs": " The range of distances, in world units, between which this entity will\n smoothly fade into view as the camera zooms out.\n\n If the start and end of this range are identical, the transition will be\n abrupt, with no crossfading.\n\n `start_margin.end` must be less than or equal to `end_margin.start`."
          },
          {
            "name": "end_margin",
            "type_path": "core::ops::Range<f32>",
            "docs": " The range of distances, in world units, between which this entity will\n smoothly fade out of view as the camera zooms out.\n\n If the start and end of this range are identical, the transition will be\n abrupt, with no crossfading.\n\n `end_margin.start` must be greater than or equal to `start_margin.end`."
          },
          {
            "name": "use_aabb",
            "type_path": "bool",
            "docs": " If set to true, Bevy will use the center of the axis-aligned bounding\n box ([`Aabb`]) as the position of the mesh for the purposes of\n visibility range computation.\n\n Otherwise, if this field is set to false, Bevy will use the origin of\n the mesh as the mesh's position.\n\n Usually you will want to leave this set to false, because different LODs\n may have different AABBs, and smooth crossfades between LOD levels\n require that all LODs of a mesh be at *precisely* the same position. If\n you aren't using crossfading, however, and your meshes aren't centered\n around their origins, then this flag may be useful."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::visibility::range::VisibilityRange",
        "short_type_path": "VisibilityRange",
        "ident": "VisibilityRange",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::visibility::range"
      },
      "default": null,
      "docs": " Specifies the range of distances that this entity must be from the camera in\n order to be rendered.\n\n This is also known as *hierarchical level of detail* or *HLOD*.\n\n Use this component when you want to render a high-polygon mesh when the\n camera is close and a lower-polygon mesh when the camera is far away. This\n is a common technique for improving performance, because fine details are\n hard to see in a mesh at a distance. To avoid an artifact known as *popping*\n between levels, each level has a *margin*, within which the object\n transitions gradually from invisible to visible using a dithering effect.\n\n You can also use this feature to replace multiple meshes with a single mesh\n when the camera is distant. This is the reason for the term \"*hierarchical*\n level of detail\". Reducing the number of meshes can be useful for reducing\n drawcall count. Note that you must place the [`VisibilityRange`] component\n on each entity you want to be part of a LOD group, as [`VisibilityRange`]\n isn't automatically propagated down to children.\n\n A typical use of this feature might look like this:\n\n | Entity                  | `start_margin` | `end_margin` |\n |-------------------------|----------------|--------------|\n | Root                    | N/A            | N/A          |\n | ├─ High-poly mesh       | [0, 0)         | [20, 25)     |\n | ├─ Low-poly mesh        | [20, 25)       | [70, 75)     |\n | └─ Billboard *imposter* | [70, 75)       | [150, 160)   |\n\n With this setup, the user will see a high-poly mesh when the camera is\n closer than 20 units. As the camera zooms out, between 20 units to 25 units,\n the high-poly mesh will gradually fade to a low-poly mesh. When the camera\n is 70 to 75 units away, the low-poly mesh will fade to a single textured\n quad. And between 150 and 160 units, the object fades away entirely. Note\n that the `end_margin` of a higher LOD is always identical to the\n `start_margin` of the next lower LOD; this is important for the crossfade\n effect to function properly.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_gizmos::config::GizmoLineJoint": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": " Does not draw any line joints."
          },
          {
            "kind": "unit",
            "name": "Miter",
            "docs": " Extends both lines at the joining point until they meet in a sharp point."
          },
          {
            "kind": "tuple",
            "name": "Round",
            "fields": [
              {
                "index": 0,
                "type_path": "u32",
                "docs": null
              }
            ],
            "docs": " Draws a round corner with the specified resolution between the two lines.\n\n The resolution determines the amount of triangles drawn per joint,\n e.g. `GizmoLineJoint::Round(4)` will draw 4 triangles at each line joint."
          },
          {
            "kind": "unit",
            "name": "Bevel",
            "docs": " Draws a bevel, a straight line in this case, to connect the ends of both lines."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gizmos::config::GizmoLineJoint",
        "short_type_path": "GizmoLineJoint",
        "ident": "GizmoLineJoint",
        "crate_name": "bevy_gizmos",
        "module_path": "bevy_gizmos::config"
      },
      "default": null,
      "docs": " An enum configuring how line joints will be drawn.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevyhub_scene::utils::animation_graph_placeholder::AnimationGraphPlaceholder": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "root",
            "type_path": "petgraph::graph::NodeIndex",
            "docs": null
          },
          {
            "name": "clips",
            "type_path": "alloc::vec::Vec<bevyhub_scene::utils::animation_graph_placeholder::AnimationClipPlaceholder>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::animation_graph_placeholder::AnimationGraphPlaceholder",
        "short_type_path": "AnimationGraphPlaceholder",
        "ident": "AnimationGraphPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::animation_graph_placeholder"
      },
      "default": "{\"bevyhub_scene::utils::animation_graph_placeholder::AnimationGraphPlaceholder\":{\"root\":0,\"clips\":[]}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::alpha::AlphaMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Opaque",
            "docs": " Base color alpha values are overridden to be fully opaque (1.0)."
          },
          {
            "kind": "tuple",
            "name": "Mask",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Reduce transparency to fully opaque or fully transparent\n based on a threshold.\n\n Compares the base color alpha value to the specified threshold.\n If the value is below the threshold,\n considers the color to be fully transparent (alpha is set to 0.0).\n If it is equal to or above the threshold,\n considers the color to be fully opaque (alpha is set to 1.0)."
          },
          {
            "kind": "unit",
            "name": "Blend",
            "docs": " The base color alpha value defines the opacity of the color.\n Standard alpha-blending is used to blend the fragment's color\n with the color behind it."
          },
          {
            "kind": "unit",
            "name": "Premultiplied",
            "docs": " Similar to [`AlphaMode::Blend`], however assumes RGB channel values are\n [premultiplied](https://en.wikipedia.org/wiki/Alpha_compositing#Straight_versus_premultiplied).\n\n For otherwise constant RGB values, behaves more like [`AlphaMode::Blend`] for\n alpha values closer to 1.0, and more like [`AlphaMode::Add`] for\n alpha values closer to 0.0.\n\n Can be used to avoid “border” or “outline” artifacts that can occur\n when using plain alpha-blended textures."
          },
          {
            "kind": "unit",
            "name": "AlphaToCoverage",
            "docs": " Spreads the fragment out over a hardware-dependent number of sample\n locations proportional to the alpha value. This requires multisample\n antialiasing; if MSAA isn't on, this is identical to\n [`AlphaMode::Mask`] with a value of 0.5.\n\n Alpha to coverage provides improved performance and better visual\n fidelity over [`AlphaMode::Blend`], as Bevy doesn't have to sort objects\n when it's in use. It's especially useful for complex transparent objects\n like foliage.\n\n [alpha to coverage]: https://en.wikipedia.org/wiki/Alpha_to_coverage"
          },
          {
            "kind": "unit",
            "name": "Add",
            "docs": " Combines the color of the fragments with the colors behind them in an\n additive process, (i.e. like light) producing lighter results.\n\n Black produces no effect. Alpha values can be used to modulate the result.\n\n Useful for effects like holograms, ghosts, lasers and other energy beams."
          },
          {
            "kind": "unit",
            "name": "Multiply",
            "docs": " Combines the color of the fragments with the colors behind them in a\n multiplicative process, (i.e. like pigments) producing darker results.\n\n White produces no effect. Alpha values can be used to modulate the result.\n\n Useful for effects like stained glass, window tint film and some colored liquids."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::alpha::AlphaMode",
        "short_type_path": "AlphaMode",
        "ident": "AlphaMode",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::alpha"
      },
      "default": "{\"bevy_render::alpha::AlphaMode\":\"Opaque\"}",
      "docs": " Sets how a material's base color alpha channel is used for transparency.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::time::Time<bevy_time::real::Real>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "context",
            "type_path": "bevy_time::real::Real",
            "docs": null
          },
          {
            "name": "wrap_period",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "delta_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed_wrapped",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped_f64",
            "type_path": "f64",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::time::Time<bevy_time::real::Real>",
        "short_type_path": "Time<Real>",
        "ident": "Time",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::time"
      },
      "default": null,
      "docs": " A generic clock resource that tracks how much it has advanced since its\n previous update and since its creation.\n\n Multiple instances of this resource are inserted automatically by\n [`TimePlugin`](crate::TimePlugin):\n\n - [`Time<Real>`](crate::real::Real) tracks real wall-clock time elapsed.\n - [`Time<Virtual>`](crate::virt::Virtual) tracks virtual game time that may\n   be paused or scaled.\n - [`Time<Fixed>`](crate::fixed::Fixed) tracks fixed timesteps based on\n   virtual time.\n - [`Time`] is a generic clock that corresponds to \"current\" or \"default\"\n   time for systems. It contains [`Time<Virtual>`](crate::virt::Virtual)\n   except inside the [`FixedMain`](bevy_app::FixedMain) schedule when it\n   contains [`Time<Fixed>`](crate::fixed::Fixed).\n\n The time elapsed since the previous time this clock was advanced is saved as\n [`delta()`](Time::delta) and the total amount of time the clock has advanced\n is saved as [`elapsed()`](Time::elapsed). Both are represented as exact\n [`Duration`] values with fixed nanosecond precision. The clock does not\n support time moving backwards, but it can be updated with [`Duration::ZERO`]\n which will set [`delta()`](Time::delta) to zero.\n\n These values are also available in seconds as `f32` via\n [`delta_secs()`](Time::delta_secs) and\n [`elapsed_secs()`](Time::elapsed_secs), and also in seconds as `f64`\n via [`delta_secs_f64()`](Time::delta_secs_f64) and\n [`elapsed_secs_f64()`](Time::elapsed_secs_f64).\n\n Since [`elapsed_secs()`](Time::elapsed_secs) will grow constantly and\n is `f32`, it will exhibit gradual precision loss. For applications that\n require an `f32` value but suffer from gradual precision loss there is\n [`elapsed_secs_wrapped()`](Time::elapsed_secs_wrapped) available. The\n same wrapped value is also available as [`Duration`] and `f64` for\n consistency. The wrap period is by default 1 hour, and can be set by\n [`set_wrap_period()`](Time::set_wrap_period).\n\n # Accessing clocks\n\n By default, any systems requiring current [`delta()`](Time::delta) or\n [`elapsed()`](Time::elapsed) should use `Res<Time>` to access the default\n time configured for the program. By default, this refers to\n [`Time<Virtual>`](crate::virt::Virtual) except during the\n [`FixedMain`](bevy_app::FixedMain) schedule when it refers to\n [`Time<Fixed>`](crate::fixed::Fixed). This ensures your system can be used\n either in [`Update`](bevy_app::Update) or\n [`FixedUpdate`](bevy_app::FixedUpdate) schedule depending on what is needed.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn ambivalent_system(time: Res<Time>) {\n     println!(\"this how I see time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system needs to react based on real time (wall clock time), like for\n user interfaces, it should use `Res<Time<Real>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will always\n correspond to real time and will not be affected by pause, time scaling or\n other tweaks.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn real_time_system(time: Res<Time<Real>>) {\n     println!(\"this will always be real time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system specifically needs to access fixed timestep clock, even when\n placed in `Update` schedule, you should use `Res<Time<Fixed>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will\n correspond to the latest fixed timestep that has been run.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Fixed>>) {\n     println!(\"this will always be the last executed fixed timestep: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n Finally, if your system specifically needs to know the current virtual game\n time, even if placed inside [`FixedUpdate`](bevy_app::FixedUpdate), for\n example to know if the game is [`was_paused()`](Time::was_paused) or to use\n [`effective_speed()`](Time::effective_speed), you can use\n `Res<Time<Virtual>>`. However, if the system is placed in\n [`FixedUpdate`](bevy_app::FixedUpdate), extra care must be used because your\n system might be run multiple times with the same [`delta()`](Time::delta)\n and [`elapsed()`](Time::elapsed) values as the virtual game time has not\n changed between the iterations.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Virtual>>) {\n     println!(\"this will be virtual time for this update: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n     println!(\"also the relative speed of the game is now {}\", time.effective_speed());\n }\n ```\n\n If you need to change the settings for any of the clocks, for example to\n [`pause()`](Time::pause) the game, you should use `ResMut<Time<Virtual>>`.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n #[derive(Event)]\n struct PauseEvent(bool);\n\n fn pause_system(mut time: ResMut<Time<Virtual>>, mut events: EventReader<PauseEvent>) {\n     for ev in events.read() {\n         if ev.0 {\n             time.pause();\n         } else {\n             time.unpause();\n         }\n     }\n }\n ```\n\n # Adding custom clocks\n\n New custom clocks can be created by creating your own struct as a context\n and passing it to [`new_with()`](Time::new_with). These clocks can be\n inserted as resources as normal and then accessed by systems. You can use\n the [`advance_by()`](Time::advance_by) or [`advance_to()`](Time::advance_to)\n methods to move the clock forwards based on your own logic.\n\n If you want to add methods for your time instance and they require access to\n both your context and the generic time part, it's probably simplest to add a\n custom trait for them and implement it for `Time<Custom>`.\n\n Your context struct will need to implement the [`Default`] trait because\n [`Time`] structures support reflection. It also makes initialization trivial\n by being able to call `app.init_resource::<Time<Custom>>()`.\n\n You can also replace the \"generic\" `Time` clock resource if the \"default\"\n time for your game should not be the default virtual time provided. You can\n get a \"generic\" snapshot of your clock by calling `as_generic()` and then\n overwrite the [`Time`] resource with it. The default systems added by\n [`TimePlugin`](crate::TimePlugin) will overwrite the [`Time`] clock during\n [`First`](bevy_app::First) and [`FixedUpdate`](bevy_app::FixedUpdate)\n schedules.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n # use bevy_utils::Instant;\n #\n #[derive(Debug)]\n struct Custom {\n     last_external_time: Instant,\n }\n\n impl Default for Custom {\n     fn default() -> Self {\n         Self {\n             last_external_time: Instant::now(),\n         }\n     }\n }\n\n trait CustomTime {\n     fn update_from_external(&mut self, instant: Instant);\n }\n\n impl CustomTime for Time<Custom> {\n     fn update_from_external(&mut self, instant: Instant) {\n          let delta = instant - self.context().last_external_time;\n          self.advance_by(delta);\n          self.context_mut().last_external_time = instant;\n     }\n }\n ```",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_render::view::visibility::VisibleEntities": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_render::view::visibility::VisibleEntities",
        "short_type_path": "VisibleEntities",
        "ident": "VisibleEntities",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::visibility"
      },
      "default": "{\"bevy_render::view::visibility::VisibleEntities\":{}}",
      "docs": " Collection of entities visible from the current view.\n\n This component contains all entities which are visible from the currently\n rendered view. The collection is updated automatically by the [`VisibilitySystems::CheckVisibility`]\n system set. Renderers can use the equivalent [`RenderVisibleEntities`] to optimize rendering of\n a particular view, to prevent drawing items not visible from that view.\n\n This component is intended to be attached to the same entity as the [`Camera`] and\n the [`Frustum`] defining the view.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_utils::Duration": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_utils::Duration"
      },
      "path_table": {
        "path": "bevy_utils::Duration",
        "short_type_path": "Duration",
        "ident": "Duration",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils"
      },
      "default": "{\"bevy_utils::Duration\":{\"secs\":0,\"nanos\":0}}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::light::point_light::PointLight": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": " The color of this light source."
          },
          {
            "name": "intensity",
            "type_path": "f32",
            "docs": " Luminous power in lumens, representing the amount of light emitted by this source in all directions."
          },
          {
            "name": "range",
            "type_path": "f32",
            "docs": " Cut-off for the light's area-of-effect. Fragments outside this range will not be affected by\n this light at all, so it's important to tune this together with `intensity` to prevent hard\n lighting cut-offs."
          },
          {
            "name": "radius",
            "type_path": "f32",
            "docs": " Simulates a light source coming from a spherical volume with the given\n radius.\n\n This affects the size of specular highlights created by this light, as\n well as the soft shadow penumbra size. Because of this, large values may\n not produce the intended result -- for example, light radius does not\n affect shadow softness or diffuse lighting."
          },
          {
            "name": "shadows_enabled",
            "type_path": "bool",
            "docs": " Whether this light casts shadows."
          },
          {
            "name": "shadow_depth_bias",
            "type_path": "f32",
            "docs": " A bias used when sampling shadow maps to avoid \"shadow-acne\", or false shadow occlusions\n that happen as a result of shadow-map fragments not mapping 1:1 to screen-space fragments.\n Too high of a depth bias can lead to shadows detaching from their casters, or\n \"peter-panning\". This bias can be tuned together with `shadow_normal_bias` to correct shadow\n artifacts for a given scene."
          },
          {
            "name": "shadow_normal_bias",
            "type_path": "f32",
            "docs": " A bias applied along the direction of the fragment's surface normal. It is scaled to the\n shadow map's texel size so that it can be small close to the camera and gets larger further\n away."
          },
          {
            "name": "shadow_map_near_z",
            "type_path": "f32",
            "docs": " The distance from the light to near Z plane in the shadow map.\n\n Objects closer than this distance to the light won't cast shadows.\n Setting this higher increases the shadow map's precision.\n\n This only has an effect if shadows are enabled."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::point_light::PointLight",
        "short_type_path": "PointLight",
        "ident": "PointLight",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light::point_light"
      },
      "default": "{\"bevy_pbr::light::point_light::PointLight\":{\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"intensity\":1000000.0,\"range\":20.0,\"radius\":0.0,\"shadows_enabled\":false,\"shadow_depth_bias\":0.08,\"shadow_normal_bias\":0.6,\"shadow_map_near_z\":0.1}}",
      "docs": " A light that emits light in all directions from a central point.\n\n Real-world values for `intensity` (luminous power in lumens) based on the electrical power\n consumption of the type of real-world light are:\n\n | Luminous Power (lumen) (i.e. the intensity member) | Incandescent non-halogen (Watts) | Incandescent halogen (Watts) | Compact fluorescent (Watts) | LED (Watts) |\n |------|-----|----|--------|-------|\n | 200  | 25  |    | 3-5    | 3     |\n | 450  | 40  | 29 | 9-11   | 5-8   |\n | 800  | 60  |    | 13-15  | 8-12  |\n | 1100 | 75  | 53 | 18-20  | 10-16 |\n | 1600 | 100 | 72 | 24-28  | 14-17 |\n | 2400 | 150 |    | 30-52  | 24-30 |\n | 3100 | 200 |    | 49-75  | 32    |\n | 4000 | 300 |    | 75-100 | 40.5  |\n\n Source: [Wikipedia](https://en.wikipedia.org/wiki/Lumen_(unit)#Lighting)",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::view::visibility::render_layers::RenderLayers": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "smallvec::SmallVec<[u64; 1]>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::visibility::render_layers::RenderLayers",
        "short_type_path": "RenderLayers",
        "ident": "RenderLayers",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::visibility::render_layers"
      },
      "default": "{\"bevy_render::view::visibility::render_layers::RenderLayers\":[1]}",
      "docs": " Describes which rendering layers an entity belongs to.\n\n Cameras with this component will only render entities with intersecting\n layers.\n\n Entities may belong to one or more layers, or no layer at all.\n\n The [`Default`] instance of `RenderLayers` contains layer `0`, the first layer.\n\n An entity with this component without any layers is invisible.\n\n Entities without this component belong to layer `0`.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_animation::AnimationEventTarget": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Root",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Node",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_animation::AnimationTargetId",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::AnimationEventTarget",
        "short_type_path": "AnimationEventTarget",
        "ident": "AnimationEventTarget",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_gizmos::aabb::AabbGizmoConfigGroup": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "draw_all",
            "type_path": "bool",
            "docs": " Draws all bounding boxes in the scene when set to `true`.\n\n To draw a specific entity's bounding box, you can add the [`ShowAabbGizmo`] component.\n\n Defaults to `false`."
          },
          {
            "name": "default_color",
            "type_path": "core::option::Option<bevy_color::color::Color>",
            "docs": " The default color for bounding box gizmos.\n\n A random color is chosen per box if `None`.\n\n Defaults to `None`."
          }
        ]
      },
      "path_table": {
        "path": "bevy_gizmos::aabb::AabbGizmoConfigGroup",
        "short_type_path": "AabbGizmoConfigGroup",
        "ident": "AabbGizmoConfigGroup",
        "crate_name": "bevy_gizmos",
        "module_path": "bevy_gizmos::aabb"
      },
      "default": null,
      "docs": " The [`GizmoConfigGroup`] used for debug visualizations of [`Aabb`] components on entities",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::smaa::SmaaPreset": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Low",
            "docs": " Four search steps; no diagonal or corner detection."
          },
          {
            "kind": "unit",
            "name": "Medium",
            "docs": " Eight search steps; no diagonal or corner detection."
          },
          {
            "kind": "unit",
            "name": "High",
            "docs": " Sixteen search steps, 8 diagonal search steps, and corner detection.\n\n This is the default."
          },
          {
            "kind": "unit",
            "name": "Ultra",
            "docs": " Thirty-two search steps, 8 diagonal search steps, and corner detection."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::smaa::SmaaPreset",
        "short_type_path": "SmaaPreset",
        "ident": "SmaaPreset",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::smaa"
      },
      "default": "{\"bevy_core_pipeline::smaa::SmaaPreset\":\"High\"}",
      "docs": " A preset quality level for SMAA.\n\n Higher values are slower but result in a higher-quality image.\n\n The default value is *high*.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_text::text::TextLayout": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "justify",
            "type_path": "bevy_text::text::JustifyText",
            "docs": " The text's internal alignment.\n Should not affect its position within a container."
          },
          {
            "name": "linebreak",
            "type_path": "bevy_text::text::LineBreak",
            "docs": " How the text should linebreak when running out of the bounds determined by `max_size`."
          }
        ]
      },
      "path_table": {
        "path": "bevy_text::text::TextLayout",
        "short_type_path": "TextLayout",
        "ident": "TextLayout",
        "crate_name": "bevy_text",
        "module_path": "bevy_text::text"
      },
      "default": "{\"bevy_text::text::TextLayout\":{\"justify\":\"Left\",\"linebreak\":\"WordBoundary\"}}",
      "docs": " Component with text format settings for a block of text.\n\n A block of text is composed of text spans, which each have a separate string value and [`TextFont`]. Text\n spans associated with a text block are collected into [`ComputedTextBlock`] for layout, and then inserted\n to [`TextLayoutInfo`] for rendering.\n\n See [`Text2d`](crate::Text2d) for the core component of 2d text, and `Text` in `bevy_ui` for UI text.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_math::primitives::dim3::Cylinder": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "radius",
            "type_path": "f32",
            "docs": " The radius of the cylinder"
          },
          {
            "name": "half_height",
            "type_path": "f32",
            "docs": " The half height of the cylinder"
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::primitives::dim3::Cylinder",
        "short_type_path": "Cylinder",
        "ident": "Cylinder",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::primitives::dim3"
      },
      "default": "{\"bevy_math::primitives::dim3::Cylinder\":{\"radius\":0.5,\"half_height\":0.5}}",
      "docs": " A cylinder primitive centered on the origin",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_audio::audio_source::AudioSource>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_audio::audio_source::AudioSource>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_audio::audio_source::AudioSource>",
        "short_type_path": "Handle<AudioSource>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_audio::audio_source::AudioSource>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_math::direction::Dir3": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "glam::Vec3",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_math::direction::Dir3",
        "short_type_path": "Dir3",
        "ident": "Dir3",
        "crate_name": "bevy_math",
        "module_path": "bevy_math::direction"
      },
      "default": null,
      "docs": " A normalized vector pointing in a direction in 3D space",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_mesh::skinning::SkinnedMeshInverseBindposes>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_mesh::skinning::SkinnedMeshInverseBindposes>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_mesh::skinning::SkinnedMeshInverseBindposes>",
        "short_type_path": "Handle<SkinnedMeshInverseBindposes>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_mesh::skinning::SkinnedMeshInverseBindposes>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::view::window::screenshot::ScreenshotCaptured": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_image::image::Image",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::window::screenshot::ScreenshotCaptured",
        "short_type_path": "ScreenshotCaptured",
        "ident": "ScreenshotCaptured",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::window::screenshot"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_hierarchy::components::parent::Parent": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_ecs::entity::Entity",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_hierarchy::components::parent::Parent",
        "short_type_path": "Parent",
        "ident": "Parent",
        "crate_name": "bevy_hierarchy",
        "module_path": "bevy_hierarchy::components::parent"
      },
      "default": null,
      "docs": " Holds a reference to the parent entity of this entity.\n This component should only be present on entities that actually have a parent entity.\n\n Parent entity must have this entity stored in its [`Children`] component.\n It is hard to set up parent/child relationships manually,\n consider using higher level utilities like [`BuildChildren::with_children`].\n\n See [`HierarchyQueryExt`] for hierarchy related methods on [`Query`].\n\n [`HierarchyQueryExt`]: crate::query_extension::HierarchyQueryExt\n [`Query`]: bevy_ecs::system::Query\n [`Children`]: super::children::Children\n [`BuildChildren::with_children`]: crate::child_builder::BuildChildren::with_children",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::camera::camera::Viewport": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "physical_position",
            "type_path": "glam::UVec2",
            "docs": " The physical position to render this viewport to within the [`RenderTarget`] of this [`Camera`].\n (0,0) corresponds to the top-left corner"
          },
          {
            "name": "physical_size",
            "type_path": "glam::UVec2",
            "docs": " The physical size of the viewport rectangle to render to within the [`RenderTarget`] of this [`Camera`].\n The origin of the rectangle is in the top-left corner."
          },
          {
            "name": "depth",
            "type_path": "core::ops::Range<f32>",
            "docs": " The minimum and maximum depth to render (on a scale from 0.0 to 1.0)."
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::camera::Viewport",
        "short_type_path": "Viewport",
        "ident": "Viewport",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": null,
      "docs": " Render viewport configuration for the [`Camera`] component.\n\n The viewport defines the area on the render target to which the camera renders its image.\n You can overlay multiple cameras in a single window using viewports to create effects like\n split screen, minimaps, and character viewers.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::ssao::ScreenSpaceAmbientOcclusionQualityLevel": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Low",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Medium",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "High",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Ultra",
            "docs": null
          },
          {
            "kind": "struct",
            "name": "Custom",
            "fields": [
              {
                "name": "slice_count",
                "type_path": "u32",
                "docs": " Higher slice count means less noise, but worse performance."
              },
              {
                "name": "samples_per_slice_side",
                "type_path": "u32",
                "docs": " Samples per slice side is also tweakable, but recommended to be left at 2 or 3."
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::ssao::ScreenSpaceAmbientOcclusionQualityLevel",
        "short_type_path": "ScreenSpaceAmbientOcclusionQualityLevel",
        "ident": "ScreenSpaceAmbientOcclusionQualityLevel",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::ssao"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_text::font::Font>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_text::font::Font>",
        "short_type_path": "AssetId<Font>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::sprite::Anchor": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Center",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "BottomLeft",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "BottomCenter",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "BottomRight",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "CenterLeft",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "CenterRight",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "TopLeft",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "TopCenter",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "TopRight",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Custom",
            "fields": [
              {
                "index": 0,
                "type_path": "glam::Vec2",
                "docs": null
              }
            ],
            "docs": " Custom anchor point. Top left is `(-0.5, 0.5)`, center is `(0.0, 0.0)`. The value will\n be scaled with the sprite size."
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::sprite::Anchor",
        "short_type_path": "Anchor",
        "ident": "Anchor",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::sprite"
      },
      "default": "{\"bevy_sprite::sprite::Anchor\":\"Center\"}",
      "docs": " How a sprite is positioned relative to its [`Transform`].\n It defaults to `Anchor::Center`.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_color::hsla::Hsla": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "hue",
            "type_path": "f32",
            "docs": " The hue channel. [0.0, 360.0]"
          },
          {
            "name": "saturation",
            "type_path": "f32",
            "docs": " The saturation channel. [0.0, 1.0]"
          },
          {
            "name": "lightness",
            "type_path": "f32",
            "docs": " The lightness channel. [0.0, 1.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::hsla::Hsla",
        "short_type_path": "Hsla",
        "ident": "Hsla",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::hsla"
      },
      "default": "{\"bevy_color::hsla::Hsla\":{\"hue\":0.0,\"saturation\":0.0,\"lightness\":1.0,\"alpha\":1.0}}",
      "docs": " Color in Hue-Saturation-Lightness (HSL) color space with alpha.\n Further information on this color model can be found on [Wikipedia](https://en.wikipedia.org/wiki/HSL_and_HSV).\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<petgraph::graph::NodeIndex>": {
      "info": {
        "kind": "list",
        "item_type_path": "petgraph::graph::NodeIndex"
      },
      "path_table": {
        "path": "alloc::vec::Vec<petgraph::graph::NodeIndex>",
        "short_type_path": "Vec<NodeIndex>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::bundle::CascadesVisibleEntities": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_pbr::bundle::CascadesVisibleEntities",
        "short_type_path": "CascadesVisibleEntities",
        "ident": "CascadesVisibleEntities",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::bundle"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_sprite::texture_atlas::TextureAtlasLayout>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_sprite::texture_atlas::TextureAtlasLayout>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_sprite::texture_atlas::TextureAtlasLayout>",
        "short_type_path": "Handle<TextureAtlasLayout>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_sprite::texture_atlas::TextureAtlasLayout>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::AnimationTarget": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "id",
            "type_path": "bevy_animation::AnimationTargetId",
            "docs": " The ID of this animation target.\n\n Typically, this is derived from the path."
          },
          {
            "name": "player",
            "type_path": "bevy_ecs::entity::Entity",
            "docs": " The entity containing the [`AnimationPlayer`]."
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::AnimationTarget",
        "short_type_path": "AnimationTarget",
        "ident": "AnimationTarget",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": " An entity that can be animated by an [`AnimationPlayer`].\n\n These are frequently referred to as *bones* or *joints*, because they often\n refer to individually-animatable parts of an armature.\n\n Asset loaders for armatures are responsible for adding these as necessary.\n Typically, they're generated from hashed versions of the entire name path\n from the root of the armature to the bone. See the [`AnimationTargetId`]\n documentation for more details.\n\n By convention, asset loaders add [`AnimationTarget`] components to the\n descendants of an [`AnimationPlayer`], as well as to the [`AnimationPlayer`]\n entity itself, but Bevy doesn't require this in any way. So, for example,\n it's entirely possible for an [`AnimationPlayer`] to animate a target that\n it isn't an ancestor of. If you add a new bone to or delete a bone from an\n armature at runtime, you may want to update the [`AnimationTarget`]\n component as appropriate, as Bevy won't do this automatically.\n\n Note that each entity can only be animated by one animation player at a\n time. However, you can change [`AnimationTarget`]'s `player` property at\n runtime to change which player is responsible for animating the entity.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "core::option::Option<glam::Vec2>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "glam::Vec2",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<glam::Vec2>",
        "short_type_path": "Option<Vec2>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::view::ColorGradingSection": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "saturation",
            "type_path": "f32",
            "docs": " Values below 1.0 desaturate, with a value of 0.0 resulting in a grayscale image\n with luminance defined by ITU-R BT.709.\n Values above 1.0 increase saturation."
          },
          {
            "name": "contrast",
            "type_path": "f32",
            "docs": " Adjusts the range of colors.\n\n A value of 1.0 applies no changes. Values below 1.0 move the colors more\n toward a neutral gray. Values above 1.0 spread the colors out away from\n the neutral gray."
          },
          {
            "name": "gamma",
            "type_path": "f32",
            "docs": " A nonlinear luminance adjustment, mainly affecting the high end of the\n range.\n\n This is the *n* exponent in the standard [ASC CDL] formula for color\n correction:\n\n ```text\n out = (i × s + o)ⁿ\n ```\n\n [ASC CDL]: https://en.wikipedia.org/wiki/ASC_CDL#Combined_Function"
          },
          {
            "name": "gain",
            "type_path": "f32",
            "docs": " A linear luminance adjustment, mainly affecting the middle part of the\n range.\n\n This is the *s* factor in the standard [ASC CDL] formula for color\n correction:\n\n ```text\n out = (i × s + o)ⁿ\n ```\n\n [ASC CDL]: https://en.wikipedia.org/wiki/ASC_CDL#Combined_Function"
          },
          {
            "name": "lift",
            "type_path": "f32",
            "docs": " A fixed luminance adjustment, mainly affecting the lower part of the\n range.\n\n This is the *o* term in the standard [ASC CDL] formula for color\n correction:\n\n ```text\n out = (i × s + o)ⁿ\n ```\n\n [ASC CDL]: https://en.wikipedia.org/wiki/ASC_CDL#Combined_Function"
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::ColorGradingSection",
        "short_type_path": "ColorGradingSection",
        "ident": "ColorGradingSection",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view"
      },
      "default": null,
      "docs": " A section of color grading values that can be selectively applied to\n shadows, midtones, and highlights.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::JustifySelf": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Auto",
            "docs": " Use the parent node's [`JustifyItems`] value to determine how this item should be aligned."
          },
          {
            "kind": "unit",
            "name": "Start",
            "docs": " This item will be aligned with the start of the axis."
          },
          {
            "kind": "unit",
            "name": "End",
            "docs": " This item will be aligned with the end of the axis."
          },
          {
            "kind": "unit",
            "name": "Center",
            "docs": " This item will be aligned along the center of the axis."
          },
          {
            "kind": "unit",
            "name": "Baseline",
            "docs": " This item will be aligned at the baseline."
          },
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " This item will be stretched to fill the space it's given."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::JustifySelf",
        "short_type_path": "JustifySelf",
        "ident": "JustifySelf",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::JustifySelf\":\"Auto\"}",
      "docs": " Used to control how the specified item is aligned within the space it's given.\n - For Flexbox items, this property has no effect. See `justify_content` for main axis alignment of flex items.\n - For CSS Grid items, controls inline (horizontal) axis alignment of a grid item within its grid area.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::graph::ThreadedAnimationGraph": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "threaded_graph",
            "type_path": "alloc::vec::Vec<petgraph::graph::NodeIndex>",
            "docs": " A cached postorder traversal of the graph.\n\n The node indices here are stored in postorder. Siblings are stored in\n descending order. This is because the\n [`crate::animation_curves::AnimationCurveEvaluator`] uses a stack for\n evaluation. Consider this graph:\n\n ```text\n             ┌─────┐\n             │     │\n             │  1  │\n             │     │\n             └──┬──┘\n                │\n        ┌───────┼───────┐\n        │       │       │\n        ▼       ▼       ▼\n     ┌─────┐ ┌─────┐ ┌─────┐\n     │     │ │     │ │     │\n     │  2  │ │  3  │ │  4  │\n     │     │ │     │ │     │\n     └──┬──┘ └─────┘ └─────┘\n        │\n    ┌───┴───┐\n    │       │\n    ▼       ▼\n ┌─────┐ ┌─────┐\n │     │ │     │\n │  5  │ │  6  │\n │     │ │     │\n └─────┘ └─────┘\n ```\n\n The postorder traversal in this case will be (4, 3, 6, 5, 2, 1).\n\n The fact that the children of each node are sorted in reverse ensures\n that, at each level, the order of blending proceeds in ascending order\n by node index, as we guarantee. To illustrate this, consider the way\n the graph above is evaluated. (Interpolation is represented with the ⊕\n symbol.)\n\n | Step | Node | Operation  | Stack (after operation) | Blend Register |\n | ---- | ---- | ---------- | ----------------------- | -------------- |\n | 1    | 4    | Push       | 4                       |                |\n | 2    | 3    | Push       | 4 3                     |                |\n | 3    | 6    | Push       | 4 3 6                   |                |\n | 4    | 5    | Push       | 4 3 6 5                 |                |\n | 5    | 2    | Blend 5    | 4 3 6                   | 5              |\n | 6    | 2    | Blend 6    | 4 3                     | 5 ⊕ 6          |\n | 7    | 2    | Push Blend | 4 3 2                   |                |\n | 8    | 1    | Blend 2    | 4 3                     | 2              |\n | 9    | 1    | Blend 3    | 4                       | 2 ⊕ 3          |\n | 10   | 1    | Blend 4    |                         | 2 ⊕ 3 ⊕ 4      |\n | 11   | 1    | Push Blend | 1                       |                |\n | 12   |      | Commit     |                         |                |"
          },
          {
            "name": "sorted_edge_ranges",
            "type_path": "alloc::vec::Vec<core::ops::Range<u32>>",
            "docs": " A mapping from each parent node index to the range within\n [`Self::sorted_edges`].\n\n This allows for quick lookup of the children of each node, sorted in\n ascending order of node index, without having to sort the result of the\n `petgraph` traversal functions every frame."
          },
          {
            "name": "sorted_edges",
            "type_path": "alloc::vec::Vec<petgraph::graph::NodeIndex>",
            "docs": " A list of the children of each node, sorted in ascending order."
          },
          {
            "name": "computed_masks",
            "type_path": "alloc::vec::Vec<u64>",
            "docs": " A mapping from node index to a bitfield specifying the mask groups that\n this node masks *out* (i.e. doesn't animate).\n\n A 1 in bit position N indicates that this node doesn't animate any\n targets of mask group N."
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::graph::ThreadedAnimationGraph",
        "short_type_path": "ThreadedAnimationGraph",
        "ident": "ThreadedAnimationGraph",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation::graph"
      },
      "default": null,
      "docs": " An acceleration structure for an animation graph that allows Bevy to\n evaluate it quickly.\n\n This is kept up to date as the associated [`AnimationGraph`] instance is\n added, modified, or removed.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::volumetric_fog::VolumetricLight": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_pbr::volumetric_fog::VolumetricLight",
        "short_type_path": "VolumetricLight",
        "ident": "VolumetricLight",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::volumetric_fog"
      },
      "default": "{\"bevy_pbr::volumetric_fog::VolumetricLight\":{}}",
      "docs": " Add this component to a [`DirectionalLight`](crate::DirectionalLight) with a shadow map\n (`shadows_enabled: true`) to make volumetric fog interact with it.\n\n This allows the light to generate light shafts/god rays.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_picking::backend::HitData": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "camera",
            "type_path": "bevy_ecs::entity::Entity",
            "docs": " The camera entity used to detect this hit. Useful when you need to find the ray that was\n casted for this hit when using a raycasting backend."
          },
          {
            "name": "depth",
            "type_path": "f32",
            "docs": " `depth` only needs to be self-consistent with other [`PointerHits`]s using the same\n [`RenderTarget`](bevy_render::camera::RenderTarget). However, it is recommended to use the\n distance from the pointer to the hit, measured from the near plane of the camera, to the\n point, in world space."
          },
          {
            "name": "position",
            "type_path": "core::option::Option<glam::Vec3>",
            "docs": " The position of the intersection in the world, if the data is available from the backend."
          },
          {
            "name": "normal",
            "type_path": "core::option::Option<glam::Vec3>",
            "docs": " The normal vector of the hit test, if the data is available from the backend."
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::backend::HitData",
        "short_type_path": "HitData",
        "ident": "HitData",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking::backend"
      },
      "default": null,
      "docs": " Holds data from a successful pointer hit test. See [`HitData::depth`] for important details.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_asset::handle::Handle<bevy_image::image::Image>>",
        "short_type_path": "Option<Handle<Image>>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::stopwatch::Stopwatch": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "elapsed",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "is_paused",
            "type_path": "bool",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::stopwatch::Stopwatch",
        "short_type_path": "Stopwatch",
        "ident": "Stopwatch",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::stopwatch"
      },
      "default": "{\"bevy_time::stopwatch::Stopwatch\":{\"elapsed\":{\"secs\":0,\"nanos\":0},\"is_paused\":false}}",
      "docs": " A Stopwatch is a struct that tracks elapsed time when started.\n\n Note that in order to advance the stopwatch [`tick`](Stopwatch::tick) **MUST** be called.\n # Examples\n\n ```\n # use bevy_time::*;\n use std::time::Duration;\n let mut stopwatch = Stopwatch::new();\n assert_eq!(stopwatch.elapsed_secs(), 0.0);\n\n stopwatch.tick(Duration::from_secs_f32(1.0)); // tick one second\n assert_eq!(stopwatch.elapsed_secs(), 1.0);\n\n stopwatch.pause();\n stopwatch.tick(Duration::from_secs_f32(1.0)); // paused stopwatches don't tick\n assert_eq!(stopwatch.elapsed_secs(), 1.0);\n\n stopwatch.reset(); // reset the stopwatch\n assert!(stopwatch.is_paused());\n assert_eq!(stopwatch.elapsed_secs(), 0.0);\n ```",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::option::Option<bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>>",
        "short_type_path": "Option<Handle<Mesh>>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::GridTrackRepetition": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Count",
            "fields": [
              {
                "index": 0,
                "type_path": "u16",
                "docs": null
              }
            ],
            "docs": " Repeat the track fixed number of times"
          },
          {
            "kind": "unit",
            "name": "AutoFill",
            "docs": " Repeat the track to fill available space\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/repeat#auto-fill>"
          },
          {
            "kind": "unit",
            "name": "AutoFit",
            "docs": " Repeat the track to fill available space but collapse any tracks that do not end up with\n an item placed in them.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/repeat#auto-fit>"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::GridTrackRepetition",
        "short_type_path": "GridTrackRepetition",
        "ident": "GridTrackRepetition",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::GridTrackRepetition\":{\"Count\":1}}",
      "docs": " How many times to repeat a repeated grid track\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/repeat>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::clear_color::ClearColor": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_color::color::Color",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::camera::clear_color::ClearColor",
        "short_type_path": "ClearColor",
        "ident": "ClearColor",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::clear_color"
      },
      "default": "{\"bevy_render::camera::clear_color::ClearColor\":{\"Srgba\":{\"red\":0.16862746,\"green\":0.17254902,\"blue\":0.18431373,\"alpha\":1.0}}}",
      "docs": " A [`Resource`] that stores the color that is used to clear the screen between frames.\n\n This color appears as the \"background\" color for simple apps,\n when there are portions of the screen with nothing rendered.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_core_pipeline::core_3d::camera_3d::Camera3d": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "depth_load_op",
            "type_path": "bevy_core_pipeline::core_3d::camera_3d::Camera3dDepthLoadOp",
            "docs": " The depth clear operation to perform for the main 3d pass."
          },
          {
            "name": "depth_texture_usages",
            "type_path": "bevy_core_pipeline::core_3d::camera_3d::Camera3dDepthTextureUsage",
            "docs": " The texture usages for the depth texture created for the main 3d pass."
          },
          {
            "name": "screen_space_specular_transmission_steps",
            "type_path": "usize",
            "docs": " How many individual steps should be performed in the [`Transmissive3d`](crate::core_3d::Transmissive3d) pass.\n\n Roughly corresponds to how many “layers of transparency” are rendered for screen space\n specular transmissive objects. Each step requires making one additional\n texture copy, so it's recommended to keep this number to a resonably low value. Defaults to `1`.\n\n ### Notes\n\n - No copies will be performed if there are no transmissive materials currently being rendered,\n   regardless of this setting.\n - Setting this to `0` disables the screen-space refraction effect entirely, and falls\n   back to refracting only the environment map light's texture.\n - If set to more than `0`, any opaque [`clear_color`](Camera::clear_color) will obscure the environment\n   map light's texture, preventing it from being visible “through” transmissive materials. If you'd like\n   to still have the environment map show up in your refractions, you can set the clear color's alpha to `0.0`.\n   Keep in mind that depending on the platform and your window settings, this may cause the window to become\n   transparent."
          },
          {
            "name": "screen_space_specular_transmission_quality",
            "type_path": "bevy_core_pipeline::core_3d::camera_3d::ScreenSpaceTransmissionQuality",
            "docs": " The quality of the screen space specular transmission blur effect, applied to whatever's “behind” transmissive\n objects when their `roughness` is greater than `0.0`.\n\n Higher qualities are more GPU-intensive.\n\n **Note:** You can get better-looking results at any quality level by enabling TAA. See: [`TemporalAntiAliasPlugin`](crate::experimental::taa::TemporalAntiAliasPlugin)."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::core_3d::camera_3d::Camera3d",
        "short_type_path": "Camera3d",
        "ident": "Camera3d",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::core_3d::camera_3d"
      },
      "default": "{\"bevy_core_pipeline::core_3d::camera_3d::Camera3d\":{\"depth_load_op\":{\"Clear\":0.0},\"depth_texture_usages\":16,\"screen_space_specular_transmission_steps\":1,\"screen_space_specular_transmission_quality\":\"Medium\"}}",
      "docs": " A 3D camera component. Enables the main 3D render graph for a [`Camera`].\n\n The camera coordinate space is right-handed X-right, Y-up, Z-back.\n This means \"forward\" is -Z.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_transform::components::global_transform::GlobalTransform": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "glam::Affine3A",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_transform::components::global_transform::GlobalTransform",
        "short_type_path": "GlobalTransform",
        "ident": "GlobalTransform",
        "crate_name": "bevy_transform",
        "module_path": "bevy_transform::components::global_transform"
      },
      "default": "{\"bevy_transform::components::global_transform::GlobalTransform\":[1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0]}",
      "docs": " [`GlobalTransform`] is an affine transformation from entity-local coordinates to worldspace coordinates.\n\n You cannot directly mutate [`GlobalTransform`]; instead, you change an entity's transform by manipulating\n its [`Transform`], which indirectly causes Bevy to update its [`GlobalTransform`].\n\n * To get the global transform of an entity, you should get its [`GlobalTransform`].\n * For transform hierarchies to work correctly, you must have both a [`Transform`] and a [`GlobalTransform`].\n   * ~You may use the [`TransformBundle`](crate::bundles::TransformBundle) to guarantee this.~\n     [`TransformBundle`](crate::bundles::TransformBundle) is now deprecated.\n     [`GlobalTransform`] is automatically inserted whenever [`Transform`] is inserted.\n\n ## [`Transform`] and [`GlobalTransform`]\n\n [`Transform`] transforms an entity relative to its parent's reference frame, or relative to world space coordinates,\n if it doesn't have a [`Parent`](bevy_hierarchy::Parent).\n\n [`GlobalTransform`] is managed by Bevy; it is computed by successively applying the [`Transform`] of each ancestor\n entity which has a Transform. This is done automatically by Bevy-internal systems in the system set\n [`TransformPropagate`](crate::TransformSystem::TransformPropagate).\n\n This system runs during [`PostUpdate`](bevy_app::PostUpdate). If you\n update the [`Transform`] of an entity in this schedule or after, you will notice a 1 frame lag\n before the [`GlobalTransform`] is updated.\n\n # Examples\n\n - [`transform`][transform_example]\n\n [transform_example]: https://github.com/bevyengine/bevy/blob/latest/examples/transforms/transform.rs",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_audio::audio::PlaybackMode": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Once",
            "docs": " Play the sound once. Do nothing when it ends."
          },
          {
            "kind": "unit",
            "name": "Loop",
            "docs": " Repeat the sound forever."
          },
          {
            "kind": "unit",
            "name": "Despawn",
            "docs": " Despawn the entity and its children when the sound finishes playing."
          },
          {
            "kind": "unit",
            "name": "Remove",
            "docs": " Remove the audio components from the entity, when the sound finishes playing."
          }
        ]
      },
      "path_table": {
        "path": "bevy_audio::audio::PlaybackMode",
        "short_type_path": "PlaybackMode",
        "ident": "PlaybackMode",
        "crate_name": "bevy_audio",
        "module_path": "bevy_audio::audio"
      },
      "default": null,
      "docs": " The way Bevy manages the sound playback.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::bundle::VisibleMeshEntities": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_pbr::bundle::VisibleMeshEntities",
        "short_type_path": "VisibleMeshEntities",
        "ident": "VisibleMeshEntities",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::bundle"
      },
      "default": "{\"bevy_pbr::bundle::VisibleMeshEntities\":{}}",
      "docs": " Collection of mesh entities visible for 3D lighting.\n\n This component contains all mesh entities visible from the current light view.\n The collection is updated automatically by [`crate::SimulationLightSystems`].",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevyhub_core::components::ui_terminal::OutputContainer": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevyhub_core::components::ui_terminal::OutputContainer",
        "short_type_path": "OutputContainer",
        "ident": "OutputContainer",
        "crate_name": "bevyhub_core",
        "module_path": "bevyhub_core::components::ui_terminal"
      },
      "default": "{\"bevyhub_core::components::ui_terminal::OutputContainer\":{}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::light::NotShadowCaster": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_pbr::light::NotShadowCaster",
        "short_type_path": "NotShadowCaster",
        "ident": "NotShadowCaster",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": "{\"bevy_pbr::light::NotShadowCaster\":{}}",
      "docs": " Add this component to make a [`Mesh3d`] not cast shadows.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_color::oklaba::Oklaba": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "lightness",
            "type_path": "f32",
            "docs": " The 'lightness' channel. [0.0, 1.0]"
          },
          {
            "name": "a",
            "type_path": "f32",
            "docs": " The 'a' channel. [-1.0, 1.0]"
          },
          {
            "name": "b",
            "type_path": "f32",
            "docs": " The 'b' channel. [-1.0, 1.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::oklaba::Oklaba",
        "short_type_path": "Oklaba",
        "ident": "Oklaba",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::oklaba"
      },
      "default": "{\"bevy_color::oklaba::Oklaba\":{\"lightness\":1.0,\"a\":0.0,\"b\":0.0,\"alpha\":1.0}}",
      "docs": " Color in Oklab color space, with alpha\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_animation::AnimationEvent": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_animation::AnimationEvent",
        "short_type_path": "AnimationEvent",
        "ident": "AnimationEvent",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevy_text::glyph::PositionedGlyph>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_text::glyph::PositionedGlyph"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_text::glyph::PositionedGlyph>",
        "short_type_path": "Vec<PositionedGlyph>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::GridTrack": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "min_sizing_function",
            "type_path": "bevy_ui::ui_node::MinTrackSizingFunction",
            "docs": null
          },
          {
            "name": "max_sizing_function",
            "type_path": "bevy_ui::ui_node::MaxTrackSizingFunction",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::GridTrack",
        "short_type_path": "GridTrack",
        "ident": "GridTrack",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::GridTrack\":{\"min_sizing_function\":\"Auto\",\"max_sizing_function\":\"Auto\"}}",
      "docs": " A [`GridTrack`] is a Row or Column of a CSS Grid. This struct specifies what size the track should be.\n See below for the different \"track sizing functions\" you can specify.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::material::OpaqueRendererMethod": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Forward",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Deferred",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Auto",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::material::OpaqueRendererMethod",
        "short_type_path": "OpaqueRendererMethod",
        "ident": "OpaqueRendererMethod",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::material"
      },
      "default": null,
      "docs": " Render method used for opaque materials.\n\n The forward rendering main pass draws each mesh entity and shades it according to its\n corresponding material and the lights that affect it. Some render features like Screen Space\n Ambient Occlusion require running depth and normal prepasses, that are 'deferred'-like\n prepasses over all mesh entities to populate depth and normal textures. This means that when\n using render features that require running prepasses, multiple passes over all visible geometry\n are required. This can be slow if there is a lot of geometry that cannot be batched into few\n draws.\n\n Deferred rendering runs a prepass to gather not only geometric information like depth and\n normals, but also all the material properties like base color, emissive color, reflectance,\n metalness, etc, and writes them into a deferred 'g-buffer' texture. The deferred main pass is\n then a fullscreen pass that reads data from these textures and executes shading. This allows\n for one pass over geometry, but is at the cost of not being able to use MSAA, and has heavier\n bandwidth usage which can be unsuitable for low end mobile or other bandwidth-constrained devices.\n\n If a material indicates `OpaqueRendererMethod::Auto`, `DefaultOpaqueRendererMethod` will be used.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_picking::pointer::PointerInteraction": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "sorted_entities",
            "type_path": "alloc::vec::Vec<(bevy_ecs::entity::Entity, bevy_picking::backend::HitData)>",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::pointer::PointerInteraction",
        "short_type_path": "PointerInteraction",
        "ident": "PointerInteraction",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking::pointer"
      },
      "default": "{\"bevy_picking::pointer::PointerInteraction\":{\"sorted_entities\":[]}}",
      "docs": " Holds a list of entities this pointer is currently interacting with, sorted from nearest to\n farthest.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_gltf::Gltf>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_gltf::Gltf>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_gltf::Gltf>",
        "short_type_path": "Handle<Gltf>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_gltf::Gltf>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_render::storage::ShaderStorageBuffer>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_render::storage::ShaderStorageBuffer>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_render::storage::ShaderStorageBuffer>",
        "short_type_path": "Handle<ShaderStorageBuffer>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_render::storage::ShaderStorageBuffer>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "i16": {
      "info": {
        "kind": "opaque",
        "item_type_path": "i16"
      },
      "path_table": {
        "path": "i16",
        "short_type_path": "i16",
        "ident": "i16",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"i16\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "alloc::vec::Vec<bevy_animation::transition::AnimationTransition>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_animation::transition::AnimationTransition"
      },
      "path_table": {
        "path": "alloc::vec::Vec<bevy_animation::transition::AnimationTransition>",
        "short_type_path": "Vec<AnimationTransition>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::parallax::ParallaxMappingMethod": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Occlusion",
            "docs": " A simple linear interpolation, using a single texture sample.\n\n This method is named \"Parallax Occlusion Mapping\".\n\n Unlike [`ParallaxMappingMethod::Relief`], only requires a single lookup,\n but may skip small details and result in writhing material artifacts."
          },
          {
            "kind": "struct",
            "name": "Relief",
            "fields": [
              {
                "name": "max_steps",
                "type_path": "u32",
                "docs": " How many additional steps to use at most to find the depth value."
              }
            ],
            "docs": " Discovers the best depth value based on binary search.\n\n Each iteration incurs a texture sample.\n The result has fewer visual artifacts than [`ParallaxMappingMethod::Occlusion`].\n\n This method is named \"Relief Mapping\"."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::parallax::ParallaxMappingMethod",
        "short_type_path": "ParallaxMappingMethod",
        "ident": "ParallaxMappingMethod",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::parallax"
      },
      "default": null,
      "docs": " The [parallax mapping] method to use to compute depth based on the\n material's [`depth_map`].\n\n Parallax Mapping uses a depth map texture to give the illusion of depth\n variation on a mesh surface that is geometrically flat.\n\n See the `parallax_mapping.wgsl` shader code for implementation details\n and explanation of the methods used.\n\n [`depth_map`]: crate::StandardMaterial::depth_map\n [parallax mapping]: https://en.wikipedia.org/wiki/Parallax_mapping",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::material::DefaultOpaqueRendererMethod": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_pbr::material::OpaqueRendererMethod",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::material::DefaultOpaqueRendererMethod",
        "short_type_path": "DefaultOpaqueRendererMethod",
        "ident": "DefaultOpaqueRendererMethod",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::material"
      },
      "default": "{\"bevy_pbr::material::DefaultOpaqueRendererMethod\":\"Forward\"}",
      "docs": " Default render method used for opaque materials.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_animation::AnimationClip": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "events",
            "type_path": "bevy_utils::hashbrown::HashMap<bevy_animation::AnimationEventTarget, alloc::vec::Vec<bevy_animation::TimedAnimationEvent>, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
            "docs": null
          },
          {
            "name": "duration",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_animation::AnimationClip",
        "short_type_path": "AnimationClip",
        "ident": "AnimationClip",
        "crate_name": "bevy_animation",
        "module_path": "bevy_animation"
      },
      "default": null,
      "docs": " A list of [`VariableCurve`]s and the [`AnimationTargetId`]s to which they\n apply.\n\n Because animation clips refer to targets by UUID, they can target any\n [`AnimationTarget`] with that ID.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_core_pipeline::bloom::settings::BloomPrefilter": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "threshold",
            "type_path": "f32",
            "docs": " Baseline of the quadratic threshold curve (default: 0.0).\n\n RGB values under the threshold curve will not contribute to the effect."
          },
          {
            "name": "threshold_softness",
            "type_path": "f32",
            "docs": " Controls how much to blend between the thresholded and non-thresholded colors (default: 0.0).\n\n 0.0 = Abrupt threshold, no blending\n 1.0 = Fully soft threshold\n\n Values outside of the range [0.0, 1.0] will be clamped."
          }
        ]
      },
      "path_table": {
        "path": "bevy_core_pipeline::bloom::settings::BloomPrefilter",
        "short_type_path": "BloomPrefilter",
        "ident": "BloomPrefilter",
        "crate_name": "bevy_core_pipeline",
        "module_path": "bevy_core_pipeline::bloom::settings"
      },
      "default": null,
      "docs": " Applies a threshold filter to the input image to extract the brightest\n regions before blurring them and compositing back onto the original image.\n These settings are useful when emulating the 1990s-2000s game look.\n\n # Considerations\n * Changing these settings creates a physically inaccurate image\n * Changing these settings makes it easy to make the final result look worse\n * Non-default prefilter settings should be used in conjunction with [`BloomCompositeMode::Additive`]",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::camera::camera::CameraRenderGraph": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_render::camera::camera::CameraRenderGraph"
      },
      "path_table": {
        "path": "bevy_render::camera::camera::CameraRenderGraph",
        "short_type_path": "CameraRenderGraph",
        "ident": "CameraRenderGraph",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::camera::camera"
      },
      "default": null,
      "docs": " Configures the [`RenderGraph`](crate::render_graph::RenderGraph) name assigned to be run for a given [`Camera`] entity.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "core::option::Option<core::num::NonZeroI16>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": null
          },
          {
            "kind": "tuple",
            "name": "Some",
            "fields": [
              {
                "index": 0,
                "type_path": "core::num::NonZeroI16",
                "docs": null
              }
            ],
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "core::option::Option<core::num::NonZeroI16>",
        "short_type_path": "Option<NonZeroI16>",
        "ident": "Option",
        "crate_name": "core",
        "module_path": "core::option"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::path::AssetPath": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_asset::path::AssetPath"
      },
      "path_table": {
        "path": "bevy_asset::path::AssetPath",
        "short_type_path": "AssetPath",
        "ident": "AssetPath",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::path"
      },
      "default": null,
      "docs": " Represents a path to an asset in a \"virtual filesystem\".\n\n Asset paths consist of three main parts:\n * [`AssetPath::source`]: The name of the [`AssetSource`](crate::io::AssetSource) to load the asset from.\n     This is optional. If one is not set the default source will be used (which is the `assets` folder by default).\n * [`AssetPath::path`]: The \"virtual filesystem path\" pointing to an asset source file.\n * [`AssetPath::label`]: An optional \"named sub asset\". When assets are loaded, they are\n     allowed to load \"sub assets\" of any type, which are identified by a named \"label\".\n\n Asset paths are generally constructed (and visualized) as strings:\n\n ```no_run\n # use bevy_asset::{Asset, AssetServer, Handle};\n # use bevy_reflect::TypePath;\n #\n # #[derive(Asset, TypePath, Default)]\n # struct Mesh;\n #\n # #[derive(Asset, TypePath, Default)]\n # struct Scene;\n #\n # let asset_server: AssetServer = panic!();\n // This loads the `my_scene.scn` base asset from the default asset source.\n let scene: Handle<Scene> = asset_server.load(\"my_scene.scn\");\n\n // This loads the `PlayerMesh` labeled asset from the `my_scene.scn` base asset in the default asset source.\n let mesh: Handle<Mesh> = asset_server.load(\"my_scene.scn#PlayerMesh\");\n\n // This loads the `my_scene.scn` base asset from a custom 'remote' asset source.\n let scene: Handle<Scene> = asset_server.load(\"remote://my_scene.scn\");\n ```\n\n [`AssetPath`] implements [`From`] for `&'static str`, `&'static Path`, and `&'a String`,\n which allows us to optimize the static cases.\n This means that the common case of `asset_server.load(\"my_scene.scn\")` when it creates and\n clones internal owned [`AssetPaths`](AssetPath).\n This also means that you should use [`AssetPath::parse`] in cases where `&str` is the explicit type.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "()": {
      "info": {
        "kind": "tuple",
        "fields": []
      },
      "path_table": {
        "path": "()",
        "short_type_path": "()",
        "ident": null,
        "crate_name": null,
        "module_path": null
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::texture_slice::border_rect::BorderRect": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "left",
            "type_path": "f32",
            "docs": " Pixel padding to the left"
          },
          {
            "name": "right",
            "type_path": "f32",
            "docs": " Pixel padding to the right"
          },
          {
            "name": "top",
            "type_path": "f32",
            "docs": " Pixel padding to the top"
          },
          {
            "name": "bottom",
            "type_path": "f32",
            "docs": " Pixel padding to the bottom"
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::texture_slice::border_rect::BorderRect",
        "short_type_path": "BorderRect",
        "ident": "BorderRect",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::texture_slice::border_rect"
      },
      "default": null,
      "docs": " Struct defining a [`Sprite`](crate::Sprite) border with padding values",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_gltf::GltfPrimitive>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_gltf::GltfPrimitive>",
        "short_type_path": "AssetId<GltfPrimitive>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "glam::Vec3": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "y",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "z",
            "type_path": "f32",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Vec3",
        "short_type_path": "Vec3",
        "ident": "Vec3",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Vec3\":[0.0,0.0,0.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::light::CascadeShadowConfig": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "bounds",
            "type_path": "alloc::vec::Vec<f32>",
            "docs": " The (positive) distance to the far boundary of each cascade."
          },
          {
            "name": "overlap_proportion",
            "type_path": "f32",
            "docs": " The proportion of overlap each cascade has with the previous cascade."
          },
          {
            "name": "minimum_distance",
            "type_path": "f32",
            "docs": " The (positive) distance to the near boundary of the first cascade."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::CascadeShadowConfig",
        "short_type_path": "CascadeShadowConfig",
        "ident": "CascadeShadowConfig",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": "{\"bevy_pbr::light::CascadeShadowConfig\":{\"bounds\":[5.0,29.24018,170.99762,1000.0001],\"overlap_proportion\":0.2,\"minimum_distance\":0.1}}",
      "docs": " Controls how cascaded shadow mapping works.\n Prefer using [`CascadeShadowConfigBuilder`] to construct an instance.\n\n ```\n # use bevy_pbr::CascadeShadowConfig;\n # use bevy_pbr::CascadeShadowConfigBuilder;\n # use bevy_utils::default;\n #\n let config: CascadeShadowConfig = CascadeShadowConfigBuilder {\n   maximum_distance: 100.0,\n   ..default()\n }.into();\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::light::spot_light::SpotLight": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": " The color of the light.\n\n By default, this is white."
          },
          {
            "name": "intensity",
            "type_path": "f32",
            "docs": " Luminous power in lumens, representing the amount of light emitted by this source in all directions."
          },
          {
            "name": "range",
            "type_path": "f32",
            "docs": " Range in meters that this light illuminates.\n\n Note that this value affects resolution of the shadow maps; generally, the\n higher you set it, the lower-resolution your shadow maps will be.\n Consequently, you should set this value to be only the size that you need."
          },
          {
            "name": "radius",
            "type_path": "f32",
            "docs": " Simulates a light source coming from a spherical volume with the given\n radius.\n\n This affects the size of specular highlights created by this light, as\n well as the soft shadow penumbra size. Because of this, large values may\n not produce the intended result -- for example, light radius does not\n affect shadow softness or diffuse lighting."
          },
          {
            "name": "shadows_enabled",
            "type_path": "bool",
            "docs": " Whether this light casts shadows.\n\n Note that shadows are rather expensive and become more so with every\n light that casts them. In general, it's best to aggressively limit the\n number of lights with shadows enabled to one or two at most."
          },
          {
            "name": "shadow_depth_bias",
            "type_path": "f32",
            "docs": " A value that adjusts the tradeoff between self-shadowing artifacts and\n proximity of shadows to their casters.\n\n This value frequently must be tuned to the specific scene; this is\n normal and a well-known part of the shadow mapping workflow. If set too\n low, unsightly shadow patterns appear on objects not in shadow as\n objects incorrectly cast shadows on themselves, known as *shadow acne*.\n If set too high, shadows detach from the objects casting them and seem\n to \"fly\" off the objects, known as *Peter Panning*."
          },
          {
            "name": "shadow_normal_bias",
            "type_path": "f32",
            "docs": " A bias applied along the direction of the fragment's surface normal. It is scaled to the\n shadow map's texel size so that it can be small close to the camera and gets larger further\n away."
          },
          {
            "name": "shadow_map_near_z",
            "type_path": "f32",
            "docs": " The distance from the light to the near Z plane in the shadow map.\n\n Objects closer than this distance to the light won't cast shadows.\n Setting this higher increases the shadow map's precision.\n\n This only has an effect if shadows are enabled."
          },
          {
            "name": "outer_angle",
            "type_path": "f32",
            "docs": " Angle defining the distance from the spot light direction to the outer limit\n of the light's cone of effect.\n `outer_angle` should be < `PI / 2.0`.\n `PI / 2.0` defines a hemispherical spot light, but shadows become very blocky as the angle\n approaches this limit."
          },
          {
            "name": "inner_angle",
            "type_path": "f32",
            "docs": " Angle defining the distance from the spot light direction to the inner limit\n of the light's cone of effect.\n Light is attenuated from `inner_angle` to `outer_angle` to give a smooth falloff.\n `inner_angle` should be <= `outer_angle`"
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::spot_light::SpotLight",
        "short_type_path": "SpotLight",
        "ident": "SpotLight",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light::spot_light"
      },
      "default": "{\"bevy_pbr::light::spot_light::SpotLight\":{\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"intensity\":1000000.0,\"range\":20.0,\"radius\":0.0,\"shadows_enabled\":false,\"shadow_depth_bias\":0.02,\"shadow_normal_bias\":1.8,\"shadow_map_near_z\":0.1,\"outer_angle\":0.7853982,\"inner_angle\":0.0}}",
      "docs": " A light that emits light in a given direction from a central point.\n\n Behaves like a point light in a perfectly absorbent housing that\n shines light only in a given direction. The direction is taken from\n the transform, and can be specified with [`Transform::looking_at`](Transform::looking_at).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::bundle::CubemapVisibleEntities": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_pbr::bundle::CubemapVisibleEntities",
        "short_type_path": "CubemapVisibleEntities",
        "ident": "CubemapVisibleEntities",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::bundle"
      },
      "default": "{\"bevy_pbr::bundle::CubemapVisibleEntities\":{}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "u8": {
      "info": {
        "kind": "opaque",
        "item_type_path": "u8"
      },
      "path_table": {
        "path": "u8",
        "short_type_path": "u8",
        "ident": "u8",
        "crate_name": null,
        "module_path": null
      },
      "default": "{\"u8\":0}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_color::hwba::Hwba": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "hue",
            "type_path": "f32",
            "docs": " The hue channel. [0.0, 360.0]"
          },
          {
            "name": "whiteness",
            "type_path": "f32",
            "docs": " The whiteness channel. [0.0, 1.0]"
          },
          {
            "name": "blackness",
            "type_path": "f32",
            "docs": " The blackness channel. [0.0, 1.0]"
          },
          {
            "name": "alpha",
            "type_path": "f32",
            "docs": " The alpha channel. [0.0, 1.0]"
          }
        ]
      },
      "path_table": {
        "path": "bevy_color::hwba::Hwba",
        "short_type_path": "Hwba",
        "ident": "Hwba",
        "crate_name": "bevy_color",
        "module_path": "bevy_color::hwba"
      },
      "default": "{\"bevy_color::hwba::Hwba\":{\"hue\":0.0,\"whiteness\":0.0,\"blackness\":1.0,\"alpha\":1.0}}",
      "docs": " Color in Hue-Whiteness-Blackness (HWB) color space with alpha.\n Further information on this color model can be found on [Wikipedia](https://en.wikipedia.org/wiki/HWB_color_model).\n <div>\n </div>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::widget::label::Label": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_ui::widget::label::Label",
        "short_type_path": "Label",
        "ident": "Label",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::widget::label"
      },
      "default": "{\"bevy_ui::widget::label::Label\":{}}",
      "docs": " Marker struct for labels",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "smallvec::SmallVec<[bevy_ecs::entity::Entity; 8]>": {
      "info": {
        "kind": "list",
        "item_type_path": "bevy_ecs::entity::Entity"
      },
      "path_table": {
        "path": "smallvec::SmallVec<[bevy_ecs::entity::Entity; 8]>",
        "short_type_path": "SmallVec<[Entity; 8]>",
        "ident": "SmallVec",
        "crate_name": "smallvec",
        "module_path": "smallvec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::cluster::ClusterConfig": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "None",
            "docs": " Disable cluster calculations for this view"
          },
          {
            "kind": "unit",
            "name": "Single",
            "docs": " One single cluster. Optimal for low-light complexity scenes or scenes where\n most lights affect the entire scene."
          },
          {
            "kind": "struct",
            "name": "XYZ",
            "fields": [
              {
                "name": "dimensions",
                "type_path": "glam::UVec3",
                "docs": null
              },
              {
                "name": "z_config",
                "type_path": "bevy_pbr::cluster::ClusterZConfig",
                "docs": null
              },
              {
                "name": "dynamic_resizing",
                "type_path": "bool",
                "docs": " Specify if clusters should automatically resize in `X/Y` if there is a risk of exceeding\n the available cluster-object index limit"
              }
            ],
            "docs": " Explicit `X`, `Y` and `Z` counts (may yield non-square `X/Y` clusters depending on the aspect ratio)"
          },
          {
            "kind": "struct",
            "name": "FixedZ",
            "fields": [
              {
                "name": "total",
                "type_path": "u32",
                "docs": null
              },
              {
                "name": "z_slices",
                "type_path": "u32",
                "docs": null
              },
              {
                "name": "z_config",
                "type_path": "bevy_pbr::cluster::ClusterZConfig",
                "docs": null
              },
              {
                "name": "dynamic_resizing",
                "type_path": "bool",
                "docs": " Specify if clusters should automatically resize in `X/Y` if there is a risk of exceeding\n the available clusterable object index limit"
              }
            ],
            "docs": " Fixed number of `Z` slices, `X` and `Y` calculated to give square clusters\n with at most total clusters. For top-down games where lights will generally always be within a\n short depth range, it may be useful to use this configuration with 1 or few `Z` slices. This\n would reduce the number of lights per cluster by distributing more clusters in screen space\n `X/Y` which matches how lights are distributed in the scene."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::cluster::ClusterConfig",
        "short_type_path": "ClusterConfig",
        "ident": "ClusterConfig",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::cluster"
      },
      "default": "{\"bevy_pbr::cluster::ClusterConfig\":{\"FixedZ\":{\"total\":4096,\"z_slices\":24,\"z_config\":{\"first_slice_depth\":5.0,\"far_z_mode\":\"MaxClusterableObjectRange\"},\"dynamic_resizing\":true}}}",
      "docs": " Configuration of the clustering strategy for clustered forward rendering",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::focus::RelativeCursorPosition": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "normalized_visible_node_rect",
            "type_path": "bevy_math::rects::rect::Rect",
            "docs": " Visible area of the Node relative to the size of the entire Node."
          },
          {
            "name": "normalized",
            "type_path": "core::option::Option<glam::Vec2>",
            "docs": " Cursor position relative to the size and position of the Node.\n A None value indicates that the cursor position is unknown."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::focus::RelativeCursorPosition",
        "short_type_path": "RelativeCursorPosition",
        "ident": "RelativeCursorPosition",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::focus"
      },
      "default": "{\"bevy_ui::focus::RelativeCursorPosition\":{\"normalized_visible_node_rect\":{\"min\":[0.0,0.0],\"max\":[0.0,0.0]},\"normalized\":null}}",
      "docs": " A component storing the position of the mouse relative to the node, (0., 0.) being the top-left corner and (1., 1.) being the bottom-right\n If the mouse is not over the node, the value will go beyond the range of (0., 0.) to (1., 1.)\n\n It can be used alongside [`Interaction`] to get the position of the press.\n\n The component is updated when it is in the same entity with [`Node`](crate::Node).",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_sprite::mesh2d::color_material::ColorMaterial>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_sprite::mesh2d::color_material::ColorMaterial>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_sprite::mesh2d::color_material::ColorMaterial>",
        "short_type_path": "Handle<ColorMaterial>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_sprite::mesh2d::color_material::ColorMaterial>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "core::ops::Range<f32>": {
      "info": {
        "kind": "opaque",
        "item_type_path": "core::ops::Range<f32>"
      },
      "path_table": {
        "path": "core::ops::Range<f32>",
        "short_type_path": "Range<f32>",
        "ident": "Range",
        "crate_name": "core",
        "module_path": "core::ops"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::texture_atlas::TextureAtlas": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "layout",
            "type_path": "bevy_asset::handle::Handle<bevy_sprite::texture_atlas::TextureAtlasLayout>",
            "docs": " Texture atlas layout handle"
          },
          {
            "name": "index",
            "type_path": "usize",
            "docs": " Texture atlas section index"
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::texture_atlas::TextureAtlas",
        "short_type_path": "TextureAtlas",
        "ident": "TextureAtlas",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::texture_atlas"
      },
      "default": "{\"bevy_sprite::texture_atlas::TextureAtlas\":{\"layout\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}},\"index\":0}}",
      "docs": " An index into a [`TextureAtlasLayout`], which corresponds to a specific section of a texture.\n\n It stores a handle to [`TextureAtlasLayout`] and the index of the current section of the atlas.\n The texture atlas contains various *sections* of a given texture, allowing users to have a single\n image file for either sprite animation or global mapping.\n You can change the texture [`index`](Self::index) of the atlas to animate the sprite or display only a *section* of the texture\n for efficient rendering of related game objects.\n\n Check the following examples for usage:\n - [`animated sprite sheet example`](https://github.com/bevyengine/bevy/blob/latest/examples/2d/sprite_sheet.rs)\n - [`sprite animation event example`](https://github.com/bevyengine/bevy/blob/latest/examples/2d/sprite_animation.rs)\n - [`texture atlas example`](https://github.com/bevyengine/bevy/blob/latest/examples/2d/texture_atlas.rs)",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ecs::entity::Entity": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_ecs::entity::Entity"
      },
      "path_table": {
        "path": "bevy_ecs::entity::Entity",
        "short_type_path": "Entity",
        "ident": "Entity",
        "crate_name": "bevy_ecs",
        "module_path": "bevy_ecs::entity"
      },
      "default": null,
      "docs": " Lightweight identifier of an [entity](crate::entity).\n\n The identifier is implemented using a [generational index]: a combination of an index and a generation.\n This allows fast insertion after data removal in an array while minimizing loss of spatial locality.\n\n These identifiers are only valid on the [`World`] it's sourced from. Attempting to use an `Entity` to\n fetch entity components or metadata from a different world will either fail or return unexpected results.\n\n [generational index]: https://lucassardois.medium.com/generational-indices-guide-8e3c5f7fd594\n\n # Stability warning\n For all intents and purposes, `Entity` should be treated as an opaque identifier. The internal bit\n representation is liable to change from release to release as are the behaviors or performance\n characteristics of any of its trait implementations (i.e. `Ord`, `Hash`, etc.). This means that changes in\n `Entity`'s representation, though made readable through various functions on the type, are not considered\n breaking changes under [SemVer].\n\n In particular, directly serializing with `Serialize` and `Deserialize` make zero guarantee of long\n term wire format compatibility. Changes in behavior will cause serialized `Entity` values persisted\n to long term storage (i.e. disk, databases, etc.) will fail to deserialize upon being updated.\n\n # Usage\n\n This data type is returned by iterating a `Query` that has `Entity` as part of its query fetch type parameter ([learn more]).\n It can also be obtained by calling [`EntityCommands::id`] or [`EntityWorldMut::id`].\n\n ```\n # use bevy_ecs::prelude::*;\n # #[derive(Component)]\n # struct SomeComponent;\n fn setup(mut commands: Commands) {\n     // Calling `spawn` returns `EntityCommands`.\n     let entity = commands.spawn(SomeComponent).id();\n }\n\n fn exclusive_system(world: &mut World) {\n     // Calling `spawn` returns `EntityWorldMut`.\n     let entity = world.spawn(SomeComponent).id();\n }\n #\n # bevy_ecs::system::assert_is_system(setup);\n # bevy_ecs::system::assert_is_system(exclusive_system);\n ```\n\n It can be used to refer to a specific entity to apply [`EntityCommands`], or to call [`Query::get`] (or similar methods) to access its components.\n\n ```\n # use bevy_ecs::prelude::*;\n #\n # #[derive(Component)]\n # struct Expired;\n #\n fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {\n     for food_entity in &query {\n         commands.entity(food_entity).despawn();\n     }\n }\n #\n # bevy_ecs::system::assert_is_system(dispose_expired_food);\n ```\n\n [learn more]: crate::system::Query#entity-id-access\n [`EntityCommands::id`]: crate::system::EntityCommands::id\n [`EntityWorldMut::id`]: crate::world::EntityWorldMut::id\n [`EntityCommands`]: crate::system::EntityCommands\n [`Query::get`]: crate::system::Query::get\n [`World`]: crate::world::World\n [SemVer]: https://semver.org/",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_picking::pointer::PointerPress": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "primary",
            "type_path": "bool",
            "docs": null
          },
          {
            "name": "secondary",
            "type_path": "bool",
            "docs": null
          },
          {
            "name": "middle",
            "type_path": "bool",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_picking::pointer::PointerPress",
        "short_type_path": "PointerPress",
        "ident": "PointerPress",
        "crate_name": "bevy_picking",
        "module_path": "bevy_picking::pointer"
      },
      "default": "{\"bevy_picking::pointer::PointerPress\":{\"primary\":false,\"secondary\":false,\"middle\":false}}",
      "docs": " Tracks the state of the pointer's buttons in response to [`PointerInput`] events.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_image::image::Image>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "path",
            "type_path": "alloc::string::String",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevyhub_scene::utils::asset_placeholder::AssetPlaceholder<bevy_image::image::Image>",
        "short_type_path": "AssetPlaceholder<Image>",
        "ident": "AssetPlaceholder",
        "crate_name": "bevyhub_scene",
        "module_path": "bevyhub_scene::utils::asset_placeholder"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::MinTrackSizingFunction": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Px",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track minimum size should be a fixed pixel value"
          },
          {
            "kind": "tuple",
            "name": "Percent",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track minimum size should be a percentage value"
          },
          {
            "kind": "unit",
            "name": "MinContent",
            "docs": " Track minimum size should be content sized under a min-content constraint"
          },
          {
            "kind": "unit",
            "name": "MaxContent",
            "docs": " Track minimum size should be content sized under a max-content constraint"
          },
          {
            "kind": "unit",
            "name": "Auto",
            "docs": " Track minimum size should be automatically sized"
          },
          {
            "kind": "tuple",
            "name": "VMin",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track minimum size should be a percent of the viewport's smaller dimension."
          },
          {
            "kind": "tuple",
            "name": "VMax",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track minimum size should be a percent of the viewport's larger dimension."
          },
          {
            "kind": "tuple",
            "name": "Vh",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track minimum size should be a percent of the viewport's height dimension."
          },
          {
            "kind": "tuple",
            "name": "Vw",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Track minimum size should be a percent of the viewport's width dimension."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::MinTrackSizingFunction",
        "short_type_path": "MinTrackSizingFunction",
        "ident": "MinTrackSizingFunction",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::MinTrackSizingFunction\":\"Auto\"}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::handle::Handle<bevy_text::font::Font>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "tuple",
            "name": "Strong",
            "fields": [
              {
                "index": 0,
                "type_path": "alloc::sync::Arc<bevy_asset::handle::StrongHandle>",
                "docs": null
              }
            ],
            "docs": " A \"strong\" reference to a live (or loading) [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. Strong handles also provide access to additional asset metadata."
          },
          {
            "kind": "tuple",
            "name": "Weak",
            "fields": [
              {
                "index": 0,
                "type_path": "bevy_asset::id::AssetId<bevy_text::font::Font>",
                "docs": null
              }
            ],
            "docs": " A \"weak\" reference to an [`Asset`]. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive."
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::handle::Handle<bevy_text::font::Font>",
        "short_type_path": "Handle<Font>",
        "ident": "Handle",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::handle"
      },
      "default": "{\"bevy_asset::handle::Handle<bevy_text::font::Font>\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}}}",
      "docs": " A strong or weak handle to a specific [`Asset`]. If a [`Handle`] is [`Handle::Strong`], the [`Asset`] will be kept\n alive until the [`Handle`] is dropped. If a [`Handle`] is [`Handle::Weak`], it does not necessarily reference a live [`Asset`],\n nor will it keep assets alive.\n\n [`Handle`] can be cloned. If a [`Handle::Strong`] is cloned, the referenced [`Asset`] will not be freed until _all_ instances\n of the [`Handle`] are dropped.\n\n [`Handle::Strong`] also provides access to useful [`Asset`] metadata, such as the [`AssetPath`] (if it exists).",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::TargetCamera": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_ecs::entity::Entity",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::TargetCamera",
        "short_type_path": "TargetCamera",
        "ident": "TargetCamera",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": null,
      "docs": " Indicates that this root [`Node`] entity should be rendered to a specific camera.\n\n UI then will be laid out respecting the camera's viewport and scale factor, and\n rendered to this camera's [`bevy_render::camera::RenderTarget`].\n\n Setting this component on a non-root node will have no effect. It will be overridden\n by the root node's component.\n\n Optional if there is only one camera in the world. Required otherwise.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::light::DirectionalLightShadowMap": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "size",
            "type_path": "usize",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::DirectionalLightShadowMap",
        "short_type_path": "DirectionalLightShadowMap",
        "ident": "DirectionalLightShadowMap",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": "{\"bevy_pbr::light::DirectionalLightShadowMap\":{\"size\":2048}}",
      "docs": " Controls the resolution of [`DirectionalLight`] shadow maps.",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_ui::widget::image::ImageNode": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "color",
            "type_path": "bevy_color::color::Color",
            "docs": " The tint color used to draw the image.\n\n This is multiplied by the color of each pixel in the image.\n The field value defaults to solid white, which will pass the image through unmodified."
          },
          {
            "name": "image",
            "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
            "docs": " Handle to the texture.\n\n This defaults to a [`TRANSPARENT_IMAGE_HANDLE`], which points to a fully transparent 1x1 texture."
          },
          {
            "name": "texture_atlas",
            "type_path": "core::option::Option<bevy_sprite::texture_atlas::TextureAtlas>",
            "docs": " The (optional) texture atlas used to render the image."
          },
          {
            "name": "flip_x",
            "type_path": "bool",
            "docs": " Whether the image should be flipped along its x-axis."
          },
          {
            "name": "flip_y",
            "type_path": "bool",
            "docs": " Whether the image should be flipped along its y-axis."
          },
          {
            "name": "rect",
            "type_path": "core::option::Option<bevy_math::rects::rect::Rect>",
            "docs": " An optional rectangle representing the region of the image to render, instead of rendering\n the full image. This is an easy one-off alternative to using a [`TextureAtlas`].\n\n When used with a [`TextureAtlas`], the rect\n is offset by the atlas's minimal (top-left) corner position."
          },
          {
            "name": "image_mode",
            "type_path": "bevy_ui::widget::image::NodeImageMode",
            "docs": " Controls how the image is altered to fit within the layout and how the layout algorithm determines the space to allocate for the image."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::widget::image::ImageNode",
        "short_type_path": "ImageNode",
        "ident": "ImageNode",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::widget::image"
      },
      "default": "{\"bevy_ui::widget::image::ImageNode\":{\"color\":{\"LinearRgba\":{\"red\":1.0,\"green\":1.0,\"blue\":1.0,\"alpha\":1.0}},\"image\":{\"Weak\":{\"Uuid\":{\"uuid\":\"7467b61f-c116-4fa5-7a3d-0584a707da20\"}}},\"texture_atlas\":null,\"flip_x\":false,\"flip_y\":false,\"rect\":null,\"image_mode\":\"Auto\"}}",
      "docs": " A UI Node that renders an image.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::AlignSelf": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Auto",
            "docs": " Use the parent node's [`AlignItems`] value to determine how this item should be aligned."
          },
          {
            "kind": "unit",
            "name": "Start",
            "docs": " This item will be aligned with the start of the axis."
          },
          {
            "kind": "unit",
            "name": "End",
            "docs": " This item will be aligned with the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexStart",
            "docs": " This item will be aligned with the start of the axis, unless the flex direction is reversed;\n then it will be aligned with the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexEnd",
            "docs": " This item will be aligned with the end of the axis, unless the flex direction is reversed;\n then it will be aligned with the start of the axis."
          },
          {
            "kind": "unit",
            "name": "Center",
            "docs": " This item will be aligned along the center of the axis."
          },
          {
            "kind": "unit",
            "name": "Baseline",
            "docs": " This item will be aligned at the baseline."
          },
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " This item will be stretched to fill the container."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::AlignSelf",
        "short_type_path": "AlignSelf",
        "ident": "AlignSelf",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::AlignSelf\":\"Auto\"}",
      "docs": " Used to control how the specified item is aligned within the space it's given.\n - For Flexbox items, controls cross axis alignment of the item.\n - For CSS Grid items, controls block (vertical) axis alignment of a grid item within its grid area.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/align-self>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_mesh::morph::MorphWeights": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "weights",
            "type_path": "alloc::vec::Vec<f32>",
            "docs": null
          },
          {
            "name": "first_mesh",
            "type_path": "core::option::Option<bevy_asset::handle::Handle<bevy_mesh::mesh::Mesh>>",
            "docs": " The first mesh primitive assigned to these weights"
          }
        ]
      },
      "path_table": {
        "path": "bevy_mesh::morph::MorphWeights",
        "short_type_path": "MorphWeights",
        "ident": "MorphWeights",
        "crate_name": "bevy_mesh",
        "module_path": "bevy_mesh::morph"
      },
      "default": "{\"bevy_mesh::morph::MorphWeights\":{\"weights\":[],\"first_mesh\":null}}",
      "docs": " Controls the [morph targets] for all child `Mesh3d` entities. In most cases, [`MorphWeights`] should be considered\n the \"source of truth\" when writing morph targets for meshes. However you can choose to write child [`MeshMorphWeights`]\n if your situation requires more granularity. Just note that if you set [`MorphWeights`], it will overwrite child\n [`MeshMorphWeights`] values.\n\n This exists because Bevy's [`Mesh`] corresponds to a _single_ surface / material, whereas morph targets\n as defined in the GLTF spec exist on \"multi-primitive meshes\" (where each primitive is its own surface with its own material).\n Therefore in Bevy [`MorphWeights`] an a parent entity are the \"canonical weights\" from a GLTF perspective, which then\n synchronized to child `Mesh3d` / [`MeshMorphWeights`] (which correspond to \"primitives\" / \"surfaces\" from a GLTF perspective).\n\n Add this to the parent of one or more [`Entities`](`Entity`) with a `Mesh3d` with a [`MeshMorphWeights`].\n\n [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevyhub_core::components::ui_terminal::OutputItem": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevyhub_core::components::ui_terminal::OutputItem",
        "short_type_path": "OutputItem",
        "ident": "OutputItem",
        "crate_name": "bevyhub_core",
        "module_path": "bevyhub_core::components::ui_terminal"
      },
      "default": "{\"bevyhub_core::components::ui_terminal::OutputItem\":{}}",
      "docs": null,
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_asset::id::AssetId<bevy_scene::scene::Scene>": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "struct",
            "name": "Index",
            "fields": [
              {
                "name": "index",
                "type_path": "bevy_asset::assets::AssetIndex",
                "docs": null
              }
            ],
            "docs": " A small / efficient runtime identifier that can be used to efficiently look up an asset stored in [`Assets`]. This is\n the \"default\" identifier used for assets. The alternative(s) (ex: [`AssetId::Uuid`]) will only be used if assets are\n explicitly registered that way.\n\n [`Assets`]: crate::Assets"
          },
          {
            "kind": "struct",
            "name": "Uuid",
            "fields": [
              {
                "name": "uuid",
                "type_path": "uuid::Uuid",
                "docs": null
              }
            ],
            "docs": " A stable-across-runs / const asset identifier. This will only be used if an asset is explicitly registered in [`Assets`]\n with one.\n\n [`Assets`]: crate::Assets"
          }
        ]
      },
      "path_table": {
        "path": "bevy_asset::id::AssetId<bevy_scene::scene::Scene>",
        "short_type_path": "AssetId<Scene>",
        "ident": "AssetId",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::id"
      },
      "default": null,
      "docs": " A unique runtime-only identifier for an [`Asset`]. This is cheap to [`Copy`]/[`Clone`] and is not directly tied to the\n lifetime of the Asset. This means it _can_ point to an [`Asset`] that no longer exists.\n\n For an identifier tied to the lifetime of an asset, see [`Handle`](`crate::Handle`).\n\n For an \"untyped\" / \"generic-less\" id, see [`UntypedAssetId`].",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::light_probe::LightProbe": {
      "info": {
        "kind": "struct",
        "fields": []
      },
      "path_table": {
        "path": "bevy_pbr::light_probe::LightProbe",
        "short_type_path": "LightProbe",
        "ident": "LightProbe",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light_probe"
      },
      "default": "{\"bevy_pbr::light_probe::LightProbe\":{}}",
      "docs": " A marker component for a light probe, which is a cuboid region that provides\n global illumination to all fragments inside it.\n\n Note that a light probe will have no effect unless the entity contains some\n kind of illumination, which can either be an [`EnvironmentMapLight`] or an\n [`IrradianceVolume`].\n\n The light probe range is conceptually a unit cube (1×1×1) centered on the\n origin. The [`Transform`] applied to this entity can scale, rotate, or translate\n that cube so that it contains all fragments that should take this light probe into account.\n\n When multiple sources of indirect illumination can be applied to a fragment,\n the highest-quality one is chosen. Diffuse and specular illumination are\n considered separately, so, for example, Bevy may decide to sample the\n diffuse illumination from an irradiance volume and the specular illumination\n from a reflection probe. From highest priority to lowest priority, the\n ranking is as follows:\n\n | Rank | Diffuse              | Specular             |\n | ---- | -------------------- | -------------------- |\n | 1    | Lightmap             | Lightmap             |\n | 2    | Irradiance volume    | Reflection probe     |\n | 3    | Reflection probe     | View environment map |\n | 4    | View environment map |                      |\n\n Note that ambient light is always added to the diffuse component and does\n not participate in the ranking. That is, ambient light is applied in\n addition to, not instead of, the light sources above.\n\n A terminology note: Unfortunately, there is little agreement across game and\n graphics engines as to what to call the various techniques that Bevy groups\n under the term *light probe*. In Bevy, a *light probe* is the generic term\n that encompasses both *reflection probes* and *irradiance volumes*. In\n object-oriented terms, *light probe* is the superclass, and *reflection\n probe* and *irradiance volume* are subclasses. In other engines, you may see\n the term *light probe* refer to an irradiance volume with a single voxel, or\n perhaps some other technique, while in Bevy *light probe* refers not to a\n specific technique but rather to a class of techniques. Developers familiar\n with other engines should be aware of this terminology difference.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "glam::Mat2": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x_axis",
            "type_path": "glam::Vec2",
            "docs": null
          },
          {
            "name": "y_axis",
            "type_path": "glam::Vec2",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "glam::Mat2",
        "short_type_path": "Mat2",
        "ident": "Mat2",
        "crate_name": "glam",
        "module_path": "glam"
      },
      "default": "{\"glam::Mat2\":[1.0,0.0,0.0,1.0]}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_sprite::mesh2d::material::AlphaMode2d": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Opaque",
            "docs": " Base color alpha values are overridden to be fully opaque (1.0)."
          },
          {
            "kind": "tuple",
            "name": "Mask",
            "fields": [
              {
                "index": 0,
                "type_path": "f32",
                "docs": null
              }
            ],
            "docs": " Reduce transparency to fully opaque or fully transparent\n based on a threshold.\n\n Compares the base color alpha value to the specified threshold.\n If the value is below the threshold,\n considers the color to be fully transparent (alpha is set to 0.0).\n If it is equal to or above the threshold,\n considers the color to be fully opaque (alpha is set to 1.0)."
          },
          {
            "kind": "unit",
            "name": "Blend",
            "docs": " The base color alpha value defines the opacity of the color.\n Standard alpha-blending is used to blend the fragment's color\n with the color behind it."
          }
        ]
      },
      "path_table": {
        "path": "bevy_sprite::mesh2d::material::AlphaMode2d",
        "short_type_path": "AlphaMode2d",
        "ident": "AlphaMode2d",
        "crate_name": "bevy_sprite",
        "module_path": "bevy_sprite::mesh2d::material"
      },
      "default": "{\"bevy_sprite::mesh2d::material::AlphaMode2d\":\"Opaque\"}",
      "docs": " Sets how a 2d material's base color alpha channel is used for transparency.\n Currently, this only works with [`Mesh2d`]. Sprites are always transparent.\n\n This is very similar to [`AlphaMode`](bevy_render::alpha::AlphaMode) but this only applies to 2d meshes.\n We use a separate type because 2d doesn't support all the transparency modes that 3d does.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_render::view::Msaa": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Off",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Sample2",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Sample4",
            "docs": null
          },
          {
            "kind": "unit",
            "name": "Sample8",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::Msaa",
        "short_type_path": "Msaa",
        "ident": "Msaa",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view"
      },
      "default": "{\"bevy_render::view::Msaa\":\"Sample4\"}",
      "docs": " Component for configuring the number of samples for [Multi-Sample Anti-Aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing)\n for a [`Camera`](crate::camera::Camera).\n\n Defaults to 4 samples. A higher number of samples results in smoother edges.\n\n Some advanced rendering features may require that MSAA is disabled.\n\n Note that the web currently only supports 1 or 4 samples.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::CalculatedClip": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "clip",
            "type_path": "bevy_math::rects::rect::Rect",
            "docs": " The rect of the clip"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::CalculatedClip",
        "short_type_path": "CalculatedClip",
        "ident": "CalculatedClip",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::CalculatedClip\":{\"clip\":{\"min\":[0.0,0.0],\"max\":[0.0,0.0]}}}",
      "docs": " The calculated clip of the node",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_pbr::light_probe::environment_map::EnvironmentMapLight": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "diffuse_map",
            "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
            "docs": " The blurry image that represents diffuse radiance surrounding a region."
          },
          {
            "name": "specular_map",
            "type_path": "bevy_asset::handle::Handle<bevy_image::image::Image>",
            "docs": " The typically-sharper, mipmapped image that represents specular radiance\n surrounding a region."
          },
          {
            "name": "intensity",
            "type_path": "f32",
            "docs": " Scale factor applied to the diffuse and specular light generated by this component.\n\n After applying this multiplier, the resulting values should\n be in units of [cd/m^2](https://en.wikipedia.org/wiki/Candela_per_square_metre).\n\n See also <https://google.github.io/filament/Filament.html#lighting/imagebasedlights/iblunit>."
          },
          {
            "name": "rotation",
            "type_path": "glam::Quat",
            "docs": " World space rotation applied to the environment light cubemaps.\n This is useful for users who require a different axis, such as the Z-axis, to serve\n as the vertical axis."
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light_probe::environment_map::EnvironmentMapLight",
        "short_type_path": "EnvironmentMapLight",
        "ident": "EnvironmentMapLight",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light_probe::environment_map"
      },
      "default": "{\"bevy_pbr::light_probe::environment_map::EnvironmentMapLight\":{\"diffuse_map\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}},\"specular_map\":{\"Weak\":{\"Uuid\":{\"uuid\":\"97128bb1-2588-480b-bdc6-87b4adbec477\"}}},\"intensity\":0.0,\"rotation\":[0.0,0.0,0.0,1.0]}}",
      "docs": " A pair of cubemap textures that represent the surroundings of a specific\n area in space.\n\n See [`crate::environment_map`] for detailed information.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_render::view::window::screenshot::Screenshot": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_render::camera::camera::RenderTarget",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_render::view::window::screenshot::Screenshot",
        "short_type_path": "Screenshot",
        "ident": "Screenshot",
        "crate_name": "bevy_render",
        "module_path": "bevy_render::view::window::screenshot"
      },
      "default": null,
      "docs": " A component that signals to the renderer to capture a screenshot this frame.\n\n This component should be spawned on a new entity with an observer that will trigger\n with [`ScreenshotCaptured`] when the screenshot is ready.\n\n Screenshots are captured asynchronously and may not be available immediately after the frame\n that the component is spawned on. The observer should be used to handle the screenshot when it\n is ready.\n\n Note that the screenshot entity will be despawned after the screenshot is captured and the\n observer is triggered.\n\n # Usage\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_render::view::screenshot::{save_to_disk, Screenshot};\n\n fn take_screenshot(mut commands: Commands) {\n    commands.spawn(Screenshot::primary_window())\n       .observe(save_to_disk(\"screenshot.png\"));\n }\n ```",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_utils::hashbrown::HashMap<bevy_animation::AnimationEventTarget, alloc::vec::Vec<bevy_animation::TimedAnimationEvent>, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>": {
      "info": {
        "kind": "map",
        "key_type_path": "bevy_animation::AnimationEventTarget",
        "value_type_path": "alloc::vec::Vec<bevy_animation::TimedAnimationEvent>"
      },
      "path_table": {
        "path": "bevy_utils::hashbrown::HashMap<bevy_animation::AnimationEventTarget, alloc::vec::Vec<bevy_animation::TimedAnimationEvent>, bevy_utils::hashbrown::hash_map::DefaultHashBuilder>",
        "short_type_path": "HashMap<AnimationEventTarget, Vec<TimedAnimationEvent>, DefaultHashBuilder>",
        "ident": "HashMap",
        "crate_name": "bevy_utils",
        "module_path": "bevy_utils::hashbrown"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_ui::ui_node::Overflow": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "x",
            "type_path": "bevy_ui::ui_node::OverflowAxis",
            "docs": " Whether to show or clip overflowing items on the x axis"
          },
          {
            "name": "y",
            "type_path": "bevy_ui::ui_node::OverflowAxis",
            "docs": " Whether to show or clip overflowing items on the y axis"
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::Overflow",
        "short_type_path": "Overflow",
        "ident": "Overflow",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::Overflow\":{\"x\":\"Visible\",\"y\":\"Visible\"}}",
      "docs": " Whether to show or hide overflowing items",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_pbr::light::PointLightShadowMap": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "size",
            "type_path": "usize",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_pbr::light::PointLightShadowMap",
        "short_type_path": "PointLightShadowMap",
        "ident": "PointLightShadowMap",
        "crate_name": "bevy_pbr",
        "module_path": "bevy_pbr::light"
      },
      "default": "{\"bevy_pbr::light::PointLightShadowMap\":{\"size\":1024}}",
      "docs": null,
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "bevy_ui::ui_node::BorderColor": {
      "info": {
        "kind": "tupleStruct",
        "fields": [
          {
            "index": 0,
            "type_path": "bevy_color::color::Color",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::BorderColor",
        "short_type_path": "BorderColor",
        "ident": "BorderColor",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::BorderColor\":{\"LinearRgba\":{\"red\":0.0,\"green\":0.0,\"blue\":0.0,\"alpha\":0.0}}}",
      "docs": " The border color of the UI node.",
      "traits": {
        "component": true,
        "resource": false
      }
    },
    "bevy_ui::ui_node::AlignContent": {
      "info": {
        "kind": "enum",
        "variants": [
          {
            "kind": "unit",
            "name": "Default",
            "docs": " The items are packed in their default position as if no alignment was applied."
          },
          {
            "kind": "unit",
            "name": "Start",
            "docs": " The items are packed towards the start of the axis."
          },
          {
            "kind": "unit",
            "name": "End",
            "docs": " The items are packed towards the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexStart",
            "docs": " The items are packed towards the start of the axis, unless the flex direction is reversed;\n then the items are packed towards the end of the axis."
          },
          {
            "kind": "unit",
            "name": "FlexEnd",
            "docs": " The items are packed towards the end of the axis, unless the flex direction is reversed;\n then the items are packed towards the start of the axis."
          },
          {
            "kind": "unit",
            "name": "Center",
            "docs": " The items are packed along the center of the axis."
          },
          {
            "kind": "unit",
            "name": "Stretch",
            "docs": " The items are stretched to fill the container along the axis."
          },
          {
            "kind": "unit",
            "name": "SpaceBetween",
            "docs": " The items are distributed such that the gap between any two items is equal."
          },
          {
            "kind": "unit",
            "name": "SpaceEvenly",
            "docs": " The items are distributed such that the gap between and around any two items is equal."
          },
          {
            "kind": "unit",
            "name": "SpaceAround",
            "docs": " The items are distributed such that the gap between and around any two items is equal, with half-size gaps on either end."
          }
        ]
      },
      "path_table": {
        "path": "bevy_ui::ui_node::AlignContent",
        "short_type_path": "AlignContent",
        "ident": "AlignContent",
        "crate_name": "bevy_ui",
        "module_path": "bevy_ui::ui_node"
      },
      "default": "{\"bevy_ui::ui_node::AlignContent\":\"Default\"}",
      "docs": " Used to control how items are distributed.\n - For Flexbox containers, controls alignment of lines if `flex_wrap` is set to [`FlexWrap::Wrap`] and there are multiple lines of items.\n - For CSS Grid containers, controls alignment of grid rows.\n\n <https://developer.mozilla.org/en-US/docs/Web/CSS/align-content>",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_asset::render_asset::RenderAssetUsages": {
      "info": {
        "kind": "opaque",
        "item_type_path": "bevy_asset::render_asset::RenderAssetUsages"
      },
      "path_table": {
        "path": "bevy_asset::render_asset::RenderAssetUsages",
        "short_type_path": "RenderAssetUsages",
        "ident": "RenderAssetUsages",
        "crate_name": "bevy_asset",
        "module_path": "bevy_asset::render_asset"
      },
      "default": null,
      "docs": " Defines where the asset will be used.\n\n If an asset is set to the `RENDER_WORLD` but not the `MAIN_WORLD`, the asset will be\n unloaded from the asset server once it's been extracted and prepared in the render world.\n\n Unloading the asset saves on memory, as for most cases it is no longer necessary to keep\n it in RAM once it's been uploaded to the GPU's VRAM. However, this means you can no longer\n access the asset from the CPU (via the `Assets<T>` resource) once unloaded (without re-loading it).\n\n If you never need access to the asset from the CPU past the first frame it's loaded on,\n or only need very infrequent access, then set this to `RENDER_WORLD`. Otherwise, set this to\n `RENDER_WORLD | MAIN_WORLD`.\n\n If you have an asset that doesn't actually need to end up in the render world, like an Image\n that will be decoded into another Image asset, use `MAIN_WORLD` only.\n\n ## Platform-specific\n\n On Wasm, it is not possible for now to free reserved memory. To control memory usage, load assets\n in sequence and unload one before loading the next. See this\n [discussion about memory management](https://github.com/WebAssembly/design/issues/1397) for more\n details.",
      "traits": {
        "component": false,
        "resource": false
      }
    },
    "bevy_time::time::Time<bevy_time::fixed::Fixed>": {
      "info": {
        "kind": "struct",
        "fields": [
          {
            "name": "context",
            "type_path": "bevy_time::fixed::Fixed",
            "docs": null
          },
          {
            "name": "wrap_period",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "delta_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "delta_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_f64",
            "type_path": "f64",
            "docs": null
          },
          {
            "name": "elapsed_wrapped",
            "type_path": "bevy_utils::Duration",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped",
            "type_path": "f32",
            "docs": null
          },
          {
            "name": "elapsed_secs_wrapped_f64",
            "type_path": "f64",
            "docs": null
          }
        ]
      },
      "path_table": {
        "path": "bevy_time::time::Time<bevy_time::fixed::Fixed>",
        "short_type_path": "Time<Fixed>",
        "ident": "Time",
        "crate_name": "bevy_time",
        "module_path": "bevy_time::time"
      },
      "default": "{\"bevy_time::time::Time<bevy_time::fixed::Fixed>\":{\"context\":{\"timestep\":{\"secs\":0,\"nanos\":15625000},\"overstep\":{\"secs\":0,\"nanos\":0}},\"wrap_period\":{\"secs\":3600,\"nanos\":0},\"delta\":{\"secs\":0,\"nanos\":0},\"delta_secs\":0.0,\"delta_secs_f64\":0.0,\"elapsed\":{\"secs\":0,\"nanos\":0},\"elapsed_secs\":0.0,\"elapsed_secs_f64\":0.0,\"elapsed_wrapped\":{\"secs\":0,\"nanos\":0},\"elapsed_secs_wrapped\":0.0,\"elapsed_secs_wrapped_f64\":0.0}}",
      "docs": " A generic clock resource that tracks how much it has advanced since its\n previous update and since its creation.\n\n Multiple instances of this resource are inserted automatically by\n [`TimePlugin`](crate::TimePlugin):\n\n - [`Time<Real>`](crate::real::Real) tracks real wall-clock time elapsed.\n - [`Time<Virtual>`](crate::virt::Virtual) tracks virtual game time that may\n   be paused or scaled.\n - [`Time<Fixed>`](crate::fixed::Fixed) tracks fixed timesteps based on\n   virtual time.\n - [`Time`] is a generic clock that corresponds to \"current\" or \"default\"\n   time for systems. It contains [`Time<Virtual>`](crate::virt::Virtual)\n   except inside the [`FixedMain`](bevy_app::FixedMain) schedule when it\n   contains [`Time<Fixed>`](crate::fixed::Fixed).\n\n The time elapsed since the previous time this clock was advanced is saved as\n [`delta()`](Time::delta) and the total amount of time the clock has advanced\n is saved as [`elapsed()`](Time::elapsed). Both are represented as exact\n [`Duration`] values with fixed nanosecond precision. The clock does not\n support time moving backwards, but it can be updated with [`Duration::ZERO`]\n which will set [`delta()`](Time::delta) to zero.\n\n These values are also available in seconds as `f32` via\n [`delta_secs()`](Time::delta_secs) and\n [`elapsed_secs()`](Time::elapsed_secs), and also in seconds as `f64`\n via [`delta_secs_f64()`](Time::delta_secs_f64) and\n [`elapsed_secs_f64()`](Time::elapsed_secs_f64).\n\n Since [`elapsed_secs()`](Time::elapsed_secs) will grow constantly and\n is `f32`, it will exhibit gradual precision loss. For applications that\n require an `f32` value but suffer from gradual precision loss there is\n [`elapsed_secs_wrapped()`](Time::elapsed_secs_wrapped) available. The\n same wrapped value is also available as [`Duration`] and `f64` for\n consistency. The wrap period is by default 1 hour, and can be set by\n [`set_wrap_period()`](Time::set_wrap_period).\n\n # Accessing clocks\n\n By default, any systems requiring current [`delta()`](Time::delta) or\n [`elapsed()`](Time::elapsed) should use `Res<Time>` to access the default\n time configured for the program. By default, this refers to\n [`Time<Virtual>`](crate::virt::Virtual) except during the\n [`FixedMain`](bevy_app::FixedMain) schedule when it refers to\n [`Time<Fixed>`](crate::fixed::Fixed). This ensures your system can be used\n either in [`Update`](bevy_app::Update) or\n [`FixedUpdate`](bevy_app::FixedUpdate) schedule depending on what is needed.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn ambivalent_system(time: Res<Time>) {\n     println!(\"this how I see time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system needs to react based on real time (wall clock time), like for\n user interfaces, it should use `Res<Time<Real>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will always\n correspond to real time and will not be affected by pause, time scaling or\n other tweaks.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn real_time_system(time: Res<Time<Real>>) {\n     println!(\"this will always be real time: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n If your system specifically needs to access fixed timestep clock, even when\n placed in `Update` schedule, you should use `Res<Time<Fixed>>`. The\n [`delta()`](Time::delta) and [`elapsed()`](Time::elapsed) values will\n correspond to the latest fixed timestep that has been run.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Fixed>>) {\n     println!(\"this will always be the last executed fixed timestep: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n }\n ```\n\n Finally, if your system specifically needs to know the current virtual game\n time, even if placed inside [`FixedUpdate`](bevy_app::FixedUpdate), for\n example to know if the game is [`was_paused()`](Time::was_paused) or to use\n [`effective_speed()`](Time::effective_speed), you can use\n `Res<Time<Virtual>>`. However, if the system is placed in\n [`FixedUpdate`](bevy_app::FixedUpdate), extra care must be used because your\n system might be run multiple times with the same [`delta()`](Time::delta)\n and [`elapsed()`](Time::elapsed) values as the virtual game time has not\n changed between the iterations.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n fn fixed_time_system(time: Res<Time<Virtual>>) {\n     println!(\"this will be virtual time for this update: delta {:?}, elapsed {:?}\", time.delta(), time.elapsed());\n     println!(\"also the relative speed of the game is now {}\", time.effective_speed());\n }\n ```\n\n If you need to change the settings for any of the clocks, for example to\n [`pause()`](Time::pause) the game, you should use `ResMut<Time<Virtual>>`.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n #\n #[derive(Event)]\n struct PauseEvent(bool);\n\n fn pause_system(mut time: ResMut<Time<Virtual>>, mut events: EventReader<PauseEvent>) {\n     for ev in events.read() {\n         if ev.0 {\n             time.pause();\n         } else {\n             time.unpause();\n         }\n     }\n }\n ```\n\n # Adding custom clocks\n\n New custom clocks can be created by creating your own struct as a context\n and passing it to [`new_with()`](Time::new_with). These clocks can be\n inserted as resources as normal and then accessed by systems. You can use\n the [`advance_by()`](Time::advance_by) or [`advance_to()`](Time::advance_to)\n methods to move the clock forwards based on your own logic.\n\n If you want to add methods for your time instance and they require access to\n both your context and the generic time part, it's probably simplest to add a\n custom trait for them and implement it for `Time<Custom>`.\n\n Your context struct will need to implement the [`Default`] trait because\n [`Time`] structures support reflection. It also makes initialization trivial\n by being able to call `app.init_resource::<Time<Custom>>()`.\n\n You can also replace the \"generic\" `Time` clock resource if the \"default\"\n time for your game should not be the default virtual time provided. You can\n get a \"generic\" snapshot of your clock by calling `as_generic()` and then\n overwrite the [`Time`] resource with it. The default systems added by\n [`TimePlugin`](crate::TimePlugin) will overwrite the [`Time`] clock during\n [`First`](bevy_app::First) and [`FixedUpdate`](bevy_app::FixedUpdate)\n schedules.\n\n ```\n # use bevy_ecs::prelude::*;\n # use bevy_time::prelude::*;\n # use bevy_utils::Instant;\n #\n #[derive(Debug)]\n struct Custom {\n     last_external_time: Instant,\n }\n\n impl Default for Custom {\n     fn default() -> Self {\n         Self {\n             last_external_time: Instant::now(),\n         }\n     }\n }\n\n trait CustomTime {\n     fn update_from_external(&mut self, instant: Instant);\n }\n\n impl CustomTime for Time<Custom> {\n     fn update_from_external(&mut self, instant: Instant) {\n          let delta = instant - self.context().last_external_time;\n          self.advance_by(delta);\n          self.context_mut().last_external_time = instant;\n     }\n }\n ```",
      "traits": {
        "component": false,
        "resource": true
      }
    },
    "alloc::vec::Vec<alloc::string::String>": {
      "info": {
        "kind": "list",
        "item_type_path": "alloc::string::String"
      },
      "path_table": {
        "path": "alloc::vec::Vec<alloc::string::String>",
        "short_type_path": "Vec<String>",
        "ident": "Vec",
        "crate_name": "alloc",
        "module_path": "alloc::vec"
      },
      "default": null,
      "docs": null,
      "traits": {
        "component": false,
        "resource": false
      }
    }
  }
}